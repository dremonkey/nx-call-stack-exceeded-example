export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Amount: any;
  CVV: any;
  CountryCode: any;
  CountryCodeAlpha2: any;
  CreditCardLast4: any;
  CreditCardNumber: any;
  CurrencyCodeAlpha: any;
  CustomFieldName: any;
  Date: any;
  Duration: any;
  ECommerceIndicator: any;
  EmailAddress: any;
  ExchangeRate: any;
  Language: any;
  Month: any;
  Percentage: any;
  ThreeDSecureCavvAlgorithm: any;
  ThreeDSecureStatusCode: any;
  ThreeDSecureVersion: any;
  Timestamp: any;
  URL: any;
  UsBankAccountNumber: any;
  UsBankRoutingNumber: any;
  UsZipCode: any;
  Year: any;
};

/** A NACHA standard entry class (SEC) code, which designates how an ACH transaction was authorized. */
export enum AchStandardEntryClassCode {
  /** Corporate credit or debit. */
  Ccd = 'CCD',
  /** Prearranged payment and deposit. */
  Ppd = 'PPD',
  /** Telephone-initiated. */
  Tel = 'TEL',
  /** Internet-initiated/mobile. */
  Web = 'WEB'
}

/** The authentication context class reference that indcates how a universal access token can be used. */
export enum AcrType {
  Client = 'CLIENT',
  Server = 'SERVER'
}

/** Top-level input fields for accepting a dispute. */
export type AcceptDisputeInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the dispute to be accepted. */
  disputeId: Scalars['ID'];
};

/** Top-level field returned when accepting a dispute. */
export type AcceptDisputePayload = {
  __typename?: 'AcceptDisputePayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Information about the dispute that was accepted. */
  dispute?: Maybe<Dispute>;
};

/** An OAuth access token. */
export type AccessToken = {
  __typename?: 'AccessToken';
  /** The access token. */
  accessToken?: Maybe<Scalars['String']>;
  /** Expiration in ISO time format. */
  expiresAt?: Maybe<Scalars['String']>;
  /** The refresh token for getting a new access token. */
  refreshToken?: Maybe<Scalars['String']>;
  /** The type of token. */
  tokenType?: Maybe<OAuthTokenType>;
};

/** The status of the business account creation request. */
export enum AccountCreationStatus {
  Completed = 'COMPLETED',
  Declined = 'DECLINED',
  InSetup = 'IN_SETUP',
  InVetting = 'IN_VETTING',
  Submitted = 'SUBMITTED'
}

/** Input fields for searching for BusinessAccountCreationRequests by their `AccountCreationStatus`. */
export type AccountCreationStatusSearchInput = {
  /** The creation status is one of these values. */
  in?: InputMaybe<Array<AccountCreationStatus>>;
  /** The creation status is exactly this value. */
  is?: InputMaybe<AccountCreationStatus>;
};

/** Representation of an address. */
export type Address = {
  __typename?: 'Address';
  /** The first line of the street address, such as street number, street name. */
  addressLine1?: Maybe<Scalars['String']>;
  /** Extended address information, such as an apartment number or suite number. */
  addressLine2?: Maybe<Scalars['String']>;
  /** Highest level subdivision, such as state, province, or ISO-3166-2 subdivison. */
  adminArea1?: Maybe<Scalars['String']>;
  /** A city, town, or village. */
  adminArea2?: Maybe<Scalars['String']>;
  /** Company name. */
  company?: Maybe<Scalars['String']>;
  /** Country code for the address. */
  countryCode?: Maybe<Scalars['CountryCode']>;
  /**
   * Extended address information, such as an apartment or suite number.
   * @deprecated Use `addressLine2` instead.
   */
  extendedAddress?: Maybe<Scalars['String']>;
  /**
   * First name.
   * @deprecated Use `fullName` instead.
   */
  firstName?: Maybe<Scalars['String']>;
  /** Full name. */
  fullName?: Maybe<Scalars['String']>;
  /**
   * Last name.
   * @deprecated Use `fullName` instead.
   */
  lastName?: Maybe<Scalars['String']>;
  /**
   * Locality/city.
   * @deprecated Use `adminArea2` instead.
   */
  locality?: Maybe<Scalars['String']>;
  /** Phone number. */
  phoneNumber?: Maybe<Scalars['String']>;
  /** Postal code, otherwise known as CAP, CEP, Eircode, NPA, PIN, PLZ, or ZIP code. */
  postalCode?: Maybe<Scalars['String']>;
  /**
   * State or province.
   * @deprecated Use `adminArea1` instead.
   */
  region?: Maybe<Scalars['String']>;
  /**
   * The street address.
   * @deprecated Use `addressLine1` instead.
   */
  streetAddress?: Maybe<Scalars['String']>;
};

/** Input fields for an Address. */
export type AddressInput = {
  /** The first line of the street address, such as street number, street name. 255 character maximum. */
  addressLine1?: InputMaybe<Scalars['String']>;
  /** Extended address information, such as apartment number or suite number. 255 character maximum. */
  addressLine2?: InputMaybe<Scalars['String']>;
  /** Highest level subdivision, such as state, province or ISO-3166-2 subdivision. 255 character maximum. */
  adminArea1?: InputMaybe<Scalars['String']>;
  /** A city, town or village. 255 character maximum. */
  adminArea2?: InputMaybe<Scalars['String']>;
  /** Company name. 255 character maximum. */
  company?: InputMaybe<Scalars['String']>;
  /**
   * Country code for the address.
   *
   * *Required for Level 3 processing*.
   */
  countryCode?: InputMaybe<Scalars['CountryCode']>;
  /**
   * Deprecated: This field is included for supporting legacy clients. Please use `countryCode` instead.
   *
   * Country code for the address in ISO 3166-1 alpha-2 format.
   */
  countryCodeAlpha2?: InputMaybe<Scalars['String']>;
  /**
   * Deprecated: This field is included for supporting legacy clients. Please use `countryCode` instead.
   *
   * Country code for the address in ISO 3166-1 alpha-3 format.
   */
  countryCodeAlpha3?: InputMaybe<Scalars['String']>;
  /**
   * Deprecated: This field is included for supporting legacy clients. Please use `countryCode` instead.
   *
   * Country code for the address in ISO 3166-1 numeric format.
   */
  countryCodeNumeric?: InputMaybe<Scalars['String']>;
  /**
   * Deprecated: This field is included for supporting legacy clients. Please use `countryCode` instead.
   *
   * Country name for the address.
   */
  countryName?: InputMaybe<Scalars['String']>;
  /** Extended address information, such as an apartment or suite number. 255 character maximum. */
  extendedAddress?: InputMaybe<Scalars['String']>;
  /** First name. 255 character maximum. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Last name. 255 character maximum. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Locality/city. 255 character maximum. */
  locality?: InputMaybe<Scalars['String']>;
  /**
   * Postal code in any country's format, otherwise known as CAP, CEP, Eircode, NPA, PIN, PLZ, or ZIP code. Nine alphanumeric characters maximum, may also contain spaces and hyphens.
   *
   * *Required for Level 3 processing*.
   */
  postalCode?: InputMaybe<Scalars['String']>;
  /** State or province. 255 character maximum. */
  region?: InputMaybe<Scalars['String']>;
  /** The street address. 255 character maximum. */
  streetAddress?: InputMaybe<Scalars['String']>;
};

/** Configuration for Apple Pay on iOS. */
export type ApplePayConfiguration = {
  __typename?: 'ApplePayConfiguration';
  /** The country code of the acquiring bank where the transaction is likely to be processed. */
  countryCode?: Maybe<Scalars['CountryCodeAlpha2']>;
  /** The merchant's Apple Pay currency code. */
  currencyCode?: Maybe<Scalars['CurrencyCodeAlpha']>;
  /** The merchant identifier that must be supplied when making an Apple Pay request. */
  merchantIdentifier?: Maybe<Scalars['String']>;
  /** The environment being used for Apple Pay. */
  status?: Maybe<ApplePayStatus>;
  /** A list of card brands supported by the merchant for Apple Pay. */
  supportedCardBrands?: Maybe<Array<CreditCardBrandCode>>;
};

/** Additional information about the payment method specific to Apple Pay. */
export type ApplePayOriginDetails = {
  __typename?: 'ApplePayOriginDetails';
  /** The first 6 digits of the credit card, known as the Bank Identification Number. This BIN may differ from the BIN of the customer's actual card. */
  bin?: Maybe<Scalars['String']>;
  /** A human-readable description of the Apple Pay payment method. This usually consists of the Apple Pay card type and its last four digits. If there is no underlying credit card, this will describe the customer's payment method and the parent CreditCardDetail object's last4 field will be null. */
  paymentInstrumentName?: Maybe<Scalars['String']>;
};

/** The environment being used for Apple Pay. */
export enum ApplePayStatus {
  Mock = 'MOCK',
  Off = 'OFF',
  Production = 'PRODUCTION'
}

/** Configuration for Apple Pay on web. */
export type ApplePayWebConfiguration = {
  __typename?: 'ApplePayWebConfiguration';
  /** The merchant's Apple Pay country code. */
  countryCode?: Maybe<Scalars['CountryCodeAlpha2']>;
  /** The merchant's Apple Pay currency code. */
  currencyCode?: Maybe<Scalars['CurrencyCodeAlpha']>;
  /** The merchant identifier that must be supplied when making an Apple Pay request. */
  merchantIdentifier?: Maybe<Scalars['String']>;
  /** A list of card brands supported by the merchant for Apple Pay. */
  supportedCardBrands?: Maybe<Array<CreditCardBrandCode>>;
};

/** The purpose of the merchant application bank account. */
export enum ApplicationBankAccountPurpose {
  Checking = 'CHECKING',
  Savings = 'SAVINGS'
}

/** The status of a merchant account application. */
export enum ApplicationStatus {
  Approved = 'APPROVED',
  Processing = 'PROCESSING',
  Rejected = 'REJECTED'
}

/** Information about the [customer authentication regulation environment](https://developers.braintreepayments.com/guides/3d-secure/migration/javascript/v3#authentication-insight) that applies to the payment method when processed with the provided merchant account. */
export type AuthenticationInsight = {
  __typename?: 'AuthenticationInsight';
  /** A value indicating when to perform further customer authentication. */
  customerAuthenticationIndicator?: Maybe<CustomerAuthenticationIndicator>;
  /** The customer authentication regulation environment that applies when transacting with this payment method and merchant account. */
  customerAuthenticationRegulationEnvironment?: Maybe<CustomerAuthenticationRegulationEnvironment>;
  /** The merchant account used to determine authentication insight. */
  merchantAccountId?: Maybe<Scalars['String']>;
};

/** Input fields when requesting authentication insight for a payment method. */
export type AuthenticationInsightInput = {
  /** The intended transaction amount to be authorized on this payment method. */
  amount?: InputMaybe<Scalars['Amount']>;
  /** ID of the merchant account that will be used when charging this payment method. */
  merchantAccountId: Scalars['ID'];
  /** A flag indicating whether the customer has consented to further recurring transactions. */
  recurringCustomerConsent?: InputMaybe<Scalars['Boolean']>;
  /** The maximum amount permitted for recurring transactions set by the customer. */
  recurringMaxAmount?: InputMaybe<Scalars['Amount']>;
};

/** Records of authorization adjustments performed when a transaction is captured for less or more than its original authorization amount. */
export type AuthorizationAdjustment = {
  __typename?: 'AuthorizationAdjustment';
  /** Difference between the authorized amount and the amount captured. Negative values indicate the authorized amount was adjusted down. */
  amount?: Maybe<MonetaryAmount>;
  /** Processor response from this adjustment. */
  processorResponse?: Maybe<TransactionAuthorizationAdjustmentProcessorResponse>;
  /** Indicates if the adjustment was successful or not. */
  successful?: Maybe<Scalars['Boolean']>;
  /** Date and time when this adjustment was performed. */
  timestamp?: Maybe<Scalars['Timestamp']>;
};

/** Accompanying information for an authorization expired transaction. */
export type AuthorizationExpiredEvent = PaymentStatusEvent & {
  __typename?: 'AuthorizationExpiredEvent';
  /** The amount of the transaction for this status event. */
  amount?: Maybe<MonetaryAmount>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the authorization for this transaction was marked expired. */
  timestamp?: Maybe<Scalars['Timestamp']>;
};

/** Top-level input fields for creating a transaction by authorizing a credit card. */
export type AuthorizeCreditCardInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields related to the credit card being authorized. */
  options?: InputMaybe<CreditCardTransactionOptionsInput>;
  /** ID of a credit card payment method to be authorized. */
  paymentMethodId: Scalars['ID'];
  /** Input fields for the authorization, with details that will define the resulting transaction. */
  transaction: TransactionInput;
};

/** Top-level input fields for creating a transaction by authorizing a PayPal account. */
export type AuthorizePayPalAccountInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields related to the PayPal account being authorized. */
  options?: InputMaybe<AuthorizePayPalAccountOptionsInput>;
  /** ID of a PayPal payment method to be authorized. */
  paymentMethodId: Scalars['ID'];
  /** Input fields for the authorization, with details that will define the resulting transaction. */
  transaction: TransactionInput;
};

/** Input fields for authorizing a PayPal account. */
export type AuthorizePayPalAccountOptionsInput = {
  /** Variable passed directly to PayPal for your own tracking purposes. Customers do not see this value. */
  customField?: InputMaybe<Scalars['String']>;
  /** Description of the transaction that is displayed to customers in PayPal email receipts. */
  description?: InputMaybe<Scalars['String']>;
  /** Deprecated: This field is no longer supported. */
  payee?: InputMaybe<PayPalPayeeOptionsInput>;
};

/** Top-level input fields for creating a transaction by authorizing a payment method. */
export type AuthorizePaymentMethodInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of a payment method to be authorized. */
  paymentMethodId: Scalars['ID'];
  /** Input fields for the authorization, with details that will define the resulting transaction. */
  transaction: TransactionInput;
};

/** Top-level input fields for creating a transaction by authorizing a Venmo account. */
export type AuthorizeVenmoAccountInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields related to the Venmo account being authorized. */
  options?: InputMaybe<AuthorizeVenmoAccountOptionsInput>;
  /** ID of a Venmo payment method to be authorized. */
  paymentMethodId: Scalars['ID'];
  /** Input fields for the authorization, with details that will define the resulting transaction. */
  transaction: TransactionInput;
};

/** Input fields for authorizing a Venmo account. */
export type AuthorizeVenmoAccountOptionsInput = {
  /** Specifies which Venmo business profile to use for the transaction. */
  profileId?: InputMaybe<Scalars['String']>;
};

/** Accompanying information for an authorized transaction. */
export type AuthorizedEvent = PaymentStatusEvent & {
  __typename?: 'AuthorizedEvent';
  /** The amount the transaction was authorized for. This will match the amount on the transaction itself. In most cases, you can't request to settle more than this amount. */
  amount?: Maybe<MonetaryAmount>;
  /** The date/time the transaction will expire if it has the authorized status. For more details on authorization expiration timeframes, see the [Statuses reference](https://developers.braintreepayments.com/reference/general/statuses#authorization-expired). */
  authorizationExpiresAt?: Maybe<Scalars['Timestamp']>;
  /** Fields describing the network response to the authorization request. */
  networkResponse?: Maybe<PaymentNetworkResponse>;
  /** Fields describing the payment processor response to the authorization request. */
  processorResponse?: Maybe<TransactionAuthorizationProcessorResponse>;
  /** Risk decision for this transaction. */
  riskDecision?: Maybe<RiskDecision>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the transaction was authorized. */
  timestamp?: Maybe<Scalars['Timestamp']>;
  /** User name of the person who performed an action that triggered the status change of the transaction. */
  userName?: Maybe<Scalars['String']>;
};

/** Response codes from the processing bank's Address Verification System (AVS) and CVV verification. */
export enum AvsCvvResponseCode {
  /** AVS or CVV checks were skipped via the API. */
  Bypass = 'BYPASS',
  DoesNotMatch = 'DOES_NOT_MATCH',
  IssuerDoesNotParticipate = 'ISSUER_DOES_NOT_PARTICIPATE',
  Matches = 'MATCHES',
  NotApplicable = 'NOT_APPLICABLE',
  NotProvided = 'NOT_PROVIDED',
  NotVerified = 'NOT_VERIFIED',
  SystemError = 'SYSTEM_ERROR'
}

/** Information about the credit card based on its BIN. */
export type BinRecord = {
  __typename?: 'BinRecord';
  /** Whether or not the card is a commercial card and capable of processing Level 2 transactions. */
  commercial?: Maybe<BinRecordValue>;
  /** The country code of the country that issued the card. */
  countryOfIssuance?: Maybe<Scalars['CountryCode']>;
  /** Whether or not the card is a debit card. */
  debit?: Maybe<BinRecordValue>;
  /** Whether the card is regulated by the Durbin Amendment due to the bank's assets, and therefore has a maximum interchange rate. */
  durbinRegulated?: Maybe<BinRecordValue>;
  /** Whether the card is designated only to be used for healthcare expenses. */
  healthcare?: Maybe<BinRecordValue>;
  /** The name of the bank that issued the card. */
  issuingBank?: Maybe<Scalars['String']>;
  /** Whether or not the card is designated for employee wages. */
  payroll?: Maybe<BinRecordValue>;
  /** Whether or not the card is prepaid, such as a gift card. */
  prepaid?: Maybe<BinRecordValue>;
  /** A code representing any special program from the card issuer the card is part of. */
  productId?: Maybe<Scalars['String']>;
};

/** A boolean-like value that includes `UNKNOWN` in the case where the information isn't available. */
export enum BinRecordValue {
  No = 'NO',
  Unknown = 'UNKNOWN'
}

/** Configuration for payment methods in legacy clients. */
export type BraintreeApiConfiguration = {
  __typename?: 'BraintreeApiConfiguration';
  /** The authentication for tokenizing payment methods. */
  accessToken?: Maybe<Scalars['String']>;
  /** The URL for tokenizing payment methods. */
  url?: Maybe<Scalars['String']>;
};

/** Record of onboarding request. */
export type BusinessAccountCreationRequest = Node & {
  __typename?: 'BusinessAccountCreationRequest';
  /** The account creation status for this account. */
  creationStatus?: Maybe<AccountCreationStatus>;
  /** Unique identifier generated by PayPal for the onboarding request. */
  id: Scalars['ID'];
  /** Information about the merchant account that is being created as a result of the request. */
  merchantAccount?: Maybe<MerchantAccount>;
};

/** A paginated list of BusinessAccountCreationRequests. */
export type BusinessAccountCreationRequestConnection = {
  __typename?: 'BusinessAccountCreationRequestConnection';
  /** A list of BusinessAccountCreationRequests. */
  edges?: Maybe<Array<Maybe<BusinessAccountCreationRequestConnectionEdge>>>;
  /** Information about the page of BusinessAccountCreationRequests contained in `edges`. */
  pageInfo: PageInfo;
};

/** A BusinessAccountCreationRequest within a BusinessAccountCreationRequestConnection. */
export type BusinessAccountCreationRequestConnectionEdge = {
  __typename?: 'BusinessAccountCreationRequestConnectionEdge';
  /** This BusinessAccountCreationRequest's location within the BusinessAccountCreationRequestConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The business account creation request. */
  node?: Maybe<BusinessAccountCreationRequest>;
};

/** Input fields for searching for BusinessAccountCreationRequests. */
export type BusinessAccountCreationRequestSearchInput = {
  /** Find BusinessAccountCreationRequests by their external ID or IDs. */
  externalId?: InputMaybe<SearchValueInput>;
  /** Find BusinessAccountCreationRequests with an ID or IDs. */
  id?: InputMaybe<SearchValueInput>;
  /** Find BusinessAccountCreationRequests by their creation status. */
  status?: InputMaybe<AccountCreationStatusSearchInput>;
};

/** The type of the business. */
export enum BusinessType {
  GovernmentAgency = 'GOVERNMENT_AGENCY',
  LimitedLiabilityCorporation = 'LIMITED_LIABILITY_CORPORATION',
  Nonprofit = 'NONPROFIT',
  Partnership = 'PARTNERSHIP',
  /** @deprecated No longer applicable, use PARTNERSHIP instead. */
  PartnershipLlp = 'PARTNERSHIP_LLP',
  PrivateCorporation = 'PRIVATE_CORPORATION',
  PublicCorporation = 'PUBLIC_CORPORATION',
  SoleProprietorship = 'SOLE_PROPRIETORSHIP',
  /** @deprecated No longer applicable, use NONPROFIT instead. */
  TaxExempt = 'TAX_EXEMPT'
}

/** Top-level input fields for capturing an authorized transaction. */
export type CaptureTransactionInput = {
  /**
   * Deprecated: This field is included for supporting legacy clients. Please use `transaction.amount` instead.
   *
   * The amount to capture on the transaction. Must be greater than 0. You can't capture more than the authorized amount unless your industry and processor support settlement adjustment (capturing a certain percentage over the authorized amount); [contact us for assistance](https://help.braintreepayments.com?issue=TransactionProcessingQuestion). If you capture an amount that is less than what was authorized, the transaction object will return the amount captured.
   */
  amount?: InputMaybe<Scalars['Amount']>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for the capture, with details that will define the resulting transaction. */
  transaction?: InputMaybe<CaptureTransactionOptionsInput>;
  /** ID of the transaction to be captured. */
  transactionId: Scalars['ID'];
};

/** Input fields for a capture, with details that will define the resulting transaction. */
export type CaptureTransactionOptionsInput = {
  /** The amount to capture on the transaction. Must be greater than 0. You can't capture more than the authorized amount unless your industry and processor support settlement adjustment (capturing a certain percentage over the authorized amount); [contact us for assistance](https://help.braintreepayments.com?issue=TransactionProcessingQuestion). If you capture an amount that is less than what was authorized, the transaction object will return the amount captured. */
  amount?: InputMaybe<Scalars['Amount']>;
  /** Fields used to define what will appear on a customer's bank statement for a specific purchase. If specified, this will update the existing descriptor on the transaction. */
  descriptor?: InputMaybe<TransactionDescriptorInput>;
  /**
   * Discount amount that was included in the total transaction amount. Does not add to the total amount the payment method will be charged. This value can't be negative. Please note that this field is not used on PayPal transactions.
   *
   * *Required for Level 3 processing*.
   */
  discountAmount?: InputMaybe<Scalars['String']>;
  /**
   * Line items for this transaction. Up to 249 line items may be specified.
   *
   * *Required for Level 3 processing*.
   */
  lineItems?: InputMaybe<Array<TransactionLineItemInput>>;
  /** Additional information about the transaction. On PayPal transactions, this field maps to the PayPal invoice number. PayPal invoice numbers must be unique in your PayPal business account. Maximum 255 characters or 127 for PayPal transactions. If specified, this will update the existing order ID on the transaction. */
  orderId?: InputMaybe<Scalars['String']>;
  /**
   * A purchase order identification value you associate with this transaction.
   *
   * *Required for Level 2 processing*.
   */
  purchaseOrderNumber?: InputMaybe<Scalars['String']>;
  /**
   * Shipping information.
   *
   * *Required for Level 3 processing*.
   */
  shipping?: InputMaybe<TransactionShippingInput>;
  /**
   * Tax information about the transaction.
   *
   * *Required for Level 2 processing*.
   */
  tax?: InputMaybe<TransactionTaxInput>;
};

/** The type of account to be used when transacting with a combo card. */
export enum CardAccountType {
  Credit = 'CREDIT',
  Debit = 'DEBIT'
}

/** Additional information about a card present payment method supplied by an in-store payment reader. */
export type CardPresentOriginDetails = InStoreReaderOriginDetails & {
  __typename?: 'CardPresentOriginDetails';
  /** The authorization mode used to perform the transaction on the payment reader. */
  authorizationMode?: Maybe<InStoreReaderAuthorizationMode>;
  /** The input mode used on the payment reader to facilitate an in-store transaction. */
  inputMode?: Maybe<PaymentReaderInputMode>;
  /** An indicator for whether the transaction was verified via pin. */
  pinVerified?: Maybe<Scalars['Boolean']>;
  /** The ID of the terminal that was processed this transaction. */
  terminalId?: Maybe<Scalars['String']>;
};

/** A list of challenges that are required by the current merchant to process a given credit card. */
export enum Challenge {
  Cvv = 'CVV',
  PostalCode = 'POSTAL_CODE'
}

/** Top-level input fields for creating a transaction by charging a credit card. */
export type ChargeCreditCardInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for creating a credit card transaction. */
  options?: InputMaybe<CreditCardTransactionOptionsInput>;
  /** ID of a credit card payment method to be charged. */
  paymentMethodId: Scalars['ID'];
  /** Input fields for the charge, with details that will define the resulting transaction. */
  transaction: TransactionInput;
};

/** Top-level input fields for creating a transaction by charging a PayPal account. */
export type ChargePayPalAccountInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields related to the PayPal account being charged. */
  options?: InputMaybe<ChargePayPalAccountOptionsInput>;
  /** The ID of an existing PayPal account. */
  paymentMethodId: Scalars['ID'];
  /** Input fields for the charge, with details that will define the resulting transaction. */
  transaction: TransactionInput;
};

/** Input fields for creating a transaction with a PayPal account. */
export type ChargePayPalAccountOptionsInput = {
  /** Variable passed directly to PayPal for your own tracking purposes. Customers do not see this value. */
  customField?: InputMaybe<Scalars['String']>;
  /** Description of the transaction that is displayed to customers in PayPal email receipts. */
  description?: InputMaybe<Scalars['String']>;
  /** Deprecated: This field is no longer supported. */
  payee?: InputMaybe<PayPalPayeeOptionsInput>;
  /** Buyer selected PayPal financing option. */
  selectedFinancingOption?: InputMaybe<SelectedPayPalFinancingOptionInput>;
};

/** Top-level input fields for creating a transaction by charging a payment method. */
export type ChargePaymentMethodInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of a payment method to be charged. */
  paymentMethodId: Scalars['ID'];
  /** Input fields for the charge, with details that will define the resulting transaction. */
  transaction: TransactionInput;
};

/** Top-level input fields for creating a transaction by charging a US bank account. */
export type ChargeUsBankAccountInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields related to the US bank account being charged. */
  options?: InputMaybe<ChargeUsBankAccountOptionsInput>;
  /** The ID of an existing US bank account. */
  paymentMethodId: Scalars['ID'];
  /** Input fields for the charge, with details that will define the resulting transaction. */
  transaction: TransactionInput;
};

/** Input fields for creating a transaction with a US bank account. */
export type ChargeUsBankAccountOptionsInput = {
  /** A NACHA standard entry class (SEC) code, which designates how the transaction was authorized. Most internet-based sales should use the `WEB` code. */
  standardEntryClassCode?: InputMaybe<AchStandardEntryClassCode>;
};

/** Top-level input fields for creating a transaction by charging a Venmo account. */
export type ChargeVenmoAccountInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for creating a Pay with Venmo transaction. */
  options?: InputMaybe<ChargeVenmoAccountOptionsInput>;
  /** The ID of an existing Venmo account. */
  paymentMethodId: Scalars['ID'];
  /** Input fields for the charge, with details that will define the resulting transaction. */
  transaction: TransactionInput;
};

/** Input fields for creating a Pay with Venmo transaction. */
export type ChargeVenmoAccountOptionsInput = {
  /** Specifies which Venmo business profile to use for the transaction. */
  profileId?: InputMaybe<Scalars['String']>;
};

/** The chargeback protection level indicates the transaction or dispute's protection status. */
export enum ChargebackProtectionLevel {
  /** The transaction or dispute is protected by the effortless chargeback protection product. */
  Effortless = 'EFFORTLESS',
  /** The merchant has not enrolled any chargeback protection products, or the merchant is registered, but the transaction or dispute is not protected. */
  NotProtected = 'NOT_PROTECTED',
  /** The transaction or dispute is protected by the standard chargeback protection product. */
  Standard = 'STANDARD'
}

/** A partial capture's relationship to its original authorization transaction. */
export type ChildCapture = {
  __typename?: 'ChildCapture';
  /** The original authorization whose funds have been partially captured. */
  parentAuthorization?: Maybe<Transaction>;
};

/** Top-level fields returned from the client configuration query. */
export type ClientConfiguration = {
  __typename?: 'ClientConfiguration';
  /**
   * URL to send analytics.
   * @deprecated This field is included for supporting SDKs that send analytics.
   */
  analyticsUrl?: Maybe<Scalars['String']>;
  /** Configuration for Apple Pay on iOS. */
  applePay?: Maybe<ApplePayConfiguration>;
  /** Configuration for Apple Pay on the web. */
  applePayWeb?: Maybe<ApplePayWebConfiguration>;
  /** A URL pointing to the base path of Braintree's web pages used for various browser switches and popups. */
  assetsUrl?: Maybe<Scalars['String']>;
  /**
   * Configuration for payment methods in legacy clients.
   * @deprecated This field is included for supporting legacy clients.
   */
  braintreeApi?: Maybe<BraintreeApiConfiguration>;
  /** A list of challenges that are required by the current merchant to process a given credit card. */
  challenges?: Maybe<Array<Challenge>>;
  /**
   * A URL pointing to the base path of Braintree's client API.
   * @deprecated This field is included for supporting legacy clients.
   */
  clientApiUrl?: Maybe<Scalars['String']>;
  /** Configuration for credit card tokenization. */
  creditCard?: Maybe<CreditCardConfiguration>;
  /** The enum of the current environment. */
  environment?: Maybe<ClientConfigurationEnvironment>;
  /** Configuration for fraud protection provider. */
  fraudProvider?: Maybe<FraudProviderConfiguration>;
  /** Configuration for Google Pay on Android and the web. */
  googlePay?: Maybe<GooglePayConfiguration>;
  /**
   * Deprecated, this field will always be null.
   * @deprecated This field is included for supporting legacy clients.
   */
  ideal?: Maybe<IDealConfiguration>;
  /**
   * Deprecated, formerly configuration for Kount fraud tools, now this configuration lives under fraudProvider.
   * @deprecated This field is included for supporting legacy clients.
   */
  kount?: Maybe<KountConfiguration>;
  /** Configuration for Masterpass. */
  masterpass?: Maybe<MasterpassConfiguration>;
  /** The merchant ID. */
  merchantId?: Maybe<Scalars['String']>;
  /** Configuration for PayPal. */
  paypal?: Maybe<PayPalConfiguration>;
  /** Configuration for Samsung Pay. */
  samsungPay?: Maybe<SamsungPayConfiguration>;
  /**
   * A list of client features the merchant supports.
   * @deprecated This field is included for supporting legacy clients.
   */
  supportedFeatures?: Maybe<Array<ClientFeature>>;
  /** Configuration for UnionPay cards. */
  unionPay?: Maybe<UnionPayConfiguration>;
  /** Configuration for US bank account processing. */
  usBankAccount?: Maybe<UsBankAccountConfiguration>;
  /** Configuration for Pay with Venmo. */
  venmo?: Maybe<VenmoConfiguration>;
  /** Configuration for Visa Checkout. */
  visaCheckout?: Maybe<VisaCheckoutConfiguration>;
};

/** The client configuration environment being used. */
export enum ClientConfigurationEnvironment {
  Development = 'DEVELOPMENT',
  Production = 'PRODUCTION',
  Qa = 'QA',
  Sandbox = 'SANDBOX',
  Test = 'TEST'
}

/** A value used by Braintree client SDKs to determine what operations are supported through this GraphQL API. */
export enum ClientFeature {
  TokenizeCreditCards = 'TOKENIZE_CREDIT_CARDS'
}

/** Input fields for creating a client token. */
export type ClientTokenInput = {
  /** The ID of an existing customer. Including this will allow your customer to vault and manage their payment methods. */
  customerId?: InputMaybe<Scalars['ID']>;
  /** The merchant account ID used to create the client token. Defaults to your default merchant account ID. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
};

/** Top-level input field for confirming micro-transfer values. */
export type ConfirmMicroTransferAmountsInput = {
  /** The amounts, in cents, of two deposits made into the customer's bank account after initiating a MICRO_TRANSFERS verification. These values should be collected from your customer. */
  amountsInCents: Array<Scalars['Int']>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the verification from vaulting the bank account. */
  verificationId: Scalars['ID'];
};

/** Top-level output field from confirming micro-transfer amounts on bank account. */
export type ConfirmMicroTransferAmountsPayload = {
  __typename?: 'ConfirmMicroTransferAmountsPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The status of the micro-transfer amounts confirmation. */
  status?: Maybe<ConfirmMicroTransferAmountsStatus>;
  /** The verification that was run on the payment method prior to vaulting. */
  verification?: Maybe<Verification>;
};

/** The status of a micro-transfer amount confirmation. */
export enum ConfirmMicroTransferAmountsStatus {
  AmountsDoNotMatch = 'AMOUNTS_DO_NOT_MATCH',
  Confirmed = 'CONFIRMED',
  TooManyAttempts = 'TOO_MANY_ATTEMPTS'
}

/** The alignment of the confirmation prompt text when displayed on the in-store reader. */
export enum ConfirmationPromptAlignment {
  Center = 'CENTER',
  Left = 'LEFT'
}

/** Top-level input field for generating a client token. */
export type CreateClientTokenInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for creating a client token. */
  clientToken?: InputMaybe<ClientTokenInput>;
};

/** Top-level fields returned when creating a client token. */
export type CreateClientTokenPayload = {
  __typename?: 'CreateClientTokenPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A Base64 encoded string used to initialize client SDKs. */
  clientToken?: Maybe<Scalars['String']>;
};

/** Top-level field for creating a customer. */
export type CreateCustomerInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for creating a customer. */
  customer?: InputMaybe<CustomerInput>;
};

/** Top-level fields returned when creating a customer. */
export type CreateCustomerPayload = {
  __typename?: 'CreateCustomerPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Information about the customer that was created. Can be used when vaulting payment methods or creating transactions to associate those objects. */
  customer?: Maybe<Customer>;
};

/** Top-level input fields for adding file evidence to a dispute. */
export type CreateDisputeFileEvidenceInput = {
  /** The category for the evidence file. */
  category?: InputMaybe<DisputeFileEvidenceCategory>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the dispute to be accepted. */
  disputeId: Scalars['ID'];
};

/** Top-level field returned when creating file evidence for a dispute. */
export type CreateDisputeFileEvidencePayload = {
  __typename?: 'CreateDisputeFileEvidencePayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Information about the dispute the evidence is attached to. */
  dispute?: Maybe<Dispute>;
  /** The evidence object created. */
  evidence?: Maybe<DisputeFileEvidence>;
};

/** Top-level input fields for creating text evidence for a dispute. */
export type CreateDisputeTextEvidenceInput = {
  /** The category of the text evidence. */
  category?: InputMaybe<DisputeTextEvidenceCategory>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The content of the text evidence. */
  content: Scalars['String'];
  /** The ID of the dispute to create the evidence for. */
  disputeId: Scalars['ID'];
};

/** Top-level field returned when creating text evidence for a dispute. */
export type CreateDisputeTextEvidencePayload = {
  __typename?: 'CreateDisputeTextEvidencePayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The evidence object created. */
  evidence?: Maybe<DisputeTextEvidence>;
};

/** Input fields for creating an in store location. */
export type CreateInStoreLocationInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields to create an in-store Location. */
  location: InStoreLocationInput;
};

/** Top-level fields returned when creating an in-store location. */
export type CreateInStoreLocationPayload = {
  __typename?: 'CreateInStoreLocationPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The in-store location. */
  location?: Maybe<InStoreLocation>;
};

/** Top-level input fields for creating a non-instant local payment context. */
export type CreateNonInstantLocalPaymentContextInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for creating a non-instant local payment context. */
  paymentContext: NonInstantLocalPaymentContextInput;
};

/** The result of a request to make a local payment context. */
export type CreateNonInstantLocalPaymentContextPayload = {
  __typename?: 'CreateNonInstantLocalPaymentContextPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Details about the local payment context. */
  paymentContext?: Maybe<LocalPaymentContext>;
};

/** Top-level input field for creating a PayPal Billing Agreement Token. */
export type CreatePayPalBillingAgreementInput = {
  /** URL for redirect back to merchant app on the client indicating unsuccessful approval. */
  cancelUrl: Scalars['URL'];
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the PayPal Billing Agreement, displayed to the PayPal user on paypal.com and other PayPal user experiences. */
  description?: InputMaybe<Scalars['String']>;
  /** Email of the payer (if known). This will prepopulate the input field in the PayPal approval page. */
  email?: InputMaybe<Scalars['EmailAddress']>;
  /** Braintree merchant account ID associated with the PayPal account to be used for the Billing Agreement creation. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Indicates whether PayPal Credit should be offered in the PayPal approval flow. */
  offerPayPalCredit?: InputMaybe<Scalars['Boolean']>;
  /** Defines the experience profile used to render the billing agreement approval flow. */
  paypalExperienceProfile?: InputMaybe<PayPalBillingAgreementExperienceProfileInput>;
  /** Product attributes input for PayPal billing agreement. */
  paypalProductAttributes?: InputMaybe<PayPalProductAttributesInput>;
  /** PayPal Risk correlation ID (also known as the Client Metadata ID). */
  paypalRiskCorrelationId?: InputMaybe<Scalars['ID']>;
  /** URL for redirect back to merchant app on the client indicating successful approval. */
  returnUrl: Scalars['URL'];
  /** Merchant-provided shipping address. Fields addressLine1, adminArea2, and countryCode are required for Billing Agreements. */
  shippingAddress?: InputMaybe<AddressInput>;
};

/** Top-level fields returned from setting up a PayPal Billing Agreement Token. */
export type CreatePayPalBillingAgreementPayload = {
  __typename?: 'CreatePayPalBillingAgreementPayload';
  /** The URL for getting user approval of the PayPal Billing Agreement. */
  approvalUrl?: Maybe<Scalars['URL']>;
  /** The Billing Agreement token. */
  billingAgreementToken?: Maybe<Scalars['ID']>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Top-level input field for creating a PayPal One-Time Payment. */
export type CreatePayPalOneTimePaymentInput = {
  /** Total amount for payment to be charged to consumer. */
  amount: MonetaryAmountInput;
  /** A description of the Billing Agreement being requested. This is displayed to the customer on paypal.com when `requestBillingAgreement` is true. Maximum 127 characters. */
  billingAgreementDescription?: InputMaybe<Scalars['String']>;
  /** URL for redirect back to merchant app on the client indicating unsuccessful approval. */
  cancelUrl: Scalars['URL'];
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Email of the payer. This will prepopulate the input field in the PayPal approval login page. */
  email?: InputMaybe<Scalars['EmailAddress']>;
  /** The payment intent. */
  intent: PayPalIntent;
  /** The line items for this transaction. Maximum 249 line items. */
  lineItems?: InputMaybe<Array<PayPalLineItemInput>>;
  /** Braintree merchant account ID associated with the PayPal account to be used for the One-Time payment creation. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Indicates whether PayPal Pay Later should be offered in the PayPal approval flow. */
  offerPayLater?: InputMaybe<Scalars['Boolean']>;
  /** Defines the experience profile used to render the approval flow. */
  paypalExperienceProfile?: InputMaybe<PayPalExperienceProfileInput>;
  /** PayPal Risk correlation ID (also known as the Client Metadata ID). */
  paypalRiskCorrelationId?: InputMaybe<Scalars['ID']>;
  /** Indicates whether this payment uses the [Billing Agreement with Purchase flow](https://developers.braintreepayments.com/guides/paypal/checkout-with-paypal/javascript/v3#checkout-using-paypal-billing-agreement-with-purchase-flow). This will request Billing Agreement approval from the customer, and a multi-use PayPal payment method will be created alongside the transaction. */
  requestBillingAgreement?: InputMaybe<Scalars['Boolean']>;
  /** URL for redirect back to merchant app on the client indicating successful approval. */
  returnUrl: Scalars['URL'];
  /** Merchant-provided shipping address. If passing a shipping address, fields addressLine1, adminArea2, and countryCode are required. */
  shippingAddress?: InputMaybe<AddressInput>;
  /** List of shipping options offered by the payee or merchant to the payer to ship or pick up their items. **Note:** `shippingOptions` may not be passed with intent `ORDER` payments. */
  shippingOptions?: InputMaybe<Array<PayPalShippingOptionInput>>;
};

/** Top-level fields returned from setting up a PayPal One-Time Payment. */
export type CreatePayPalOneTimePaymentPayload = {
  __typename?: 'CreatePayPalOneTimePaymentPayload';
  /** The URL for getting user approval of the PayPal payment. */
  approvalUrl?: Maybe<Scalars['URL']>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The PayPal payment ID. This ID is prefixed with "PAYID-". */
  paymentId?: Maybe<Scalars['String']>;
};

/** Top-level input field for generating a PayPal access token. */
export type CreateUniversalAccessTokenInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of an existing customer. Including this will allow the access token to interact with this customer's data. */
  customerId?: InputMaybe<Scalars['ID']>;
  /** Authentication context class reference for the universal access token. */
  type: AcrType;
};

/** Top-level fields returned when creating a universal access token. */
export type CreateUniversalAccessTokenPayload = {
  __typename?: 'CreateUniversalAccessTokenPayload';
  /** The created universal access token. */
  accessToken?: Maybe<AccessToken>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** A code identifying the card brand. */
export enum CreditCardBrandCode {
  AmericanExpress = 'AMERICAN_EXPRESS',
  Citi = 'CITI',
  Diners = 'DINERS',
  Discover = 'DISCOVER',
  Elo = 'ELO',
  Hiper = 'HIPER',
  Hipercard = 'HIPERCARD',
  InternationalMaestro = 'INTERNATIONAL_MAESTRO',
  Jcb = 'JCB',
  Mastercard = 'MASTERCARD',
  Solo = 'SOLO',
  Switch = 'SWITCH',
  UkMaestro = 'UK_MAESTRO',
  UnionPay = 'UNION_PAY',
  Unknown = 'UNKNOWN',
  Visa = 'VISA'
}

/** Configuration for credit card tokenization. */
export type CreditCardConfiguration = {
  __typename?: 'CreditCardConfiguration';
  /** A list of challenges that are required by the merchant to process a given credit card. */
  challenges?: Maybe<Array<Challenge>>;
  /** Whether or not fraud data collection is enabled for the merchant. */
  fraudDataCollectionEnabled?: Maybe<Scalars['Boolean']>;
  /** A list of card brands supported by the merchant for credit card processing. */
  supportedCardBrands?: Maybe<Array<CreditCardBrandCode>>;
  /** Configuration for 3D Secure. */
  threeDSecure?: Maybe<ThreeDSecureConfiguration>;
  /**
   * Whether or not the merchant supports 3D Secure.
   * @deprecated Use `threeDSecure` instead.
   */
  threeDSecureEnabled?: Maybe<Scalars['Boolean']>;
};

/** Details about a credit card. */
export type CreditCardDetails = {
  __typename?: 'CreditCardDetails';
  /** The billing address associated with the credit card. */
  billingAddress?: Maybe<Address>;
  /** The first 6 digits of the credit card number, known as the Bank Identification Number. If this card originates from a third party such as a wallet provider, this BIN may not be present and the PaymentMethodOriginDetails will contain a BIN instead. */
  bin?: Maybe<Scalars['String']>;
  /** Information about the card based on its BIN. */
  binData?: Maybe<BinRecord>;
  /**
   * The display name of the card brand, e.g. "Visa" or "American Express".
   * @deprecated Use `brandCode` instead.
   */
  brand?: Maybe<Scalars['String']>;
  /** A static code identifying the card brand. */
  brandCode?: Maybe<CreditCardBrandCode>;
  /** Indicates whether the card on file is network tokenized. */
  cardOnFileNetworkTokenized?: Maybe<Scalars['Boolean']>;
  /** The cardholder's name. */
  cardholderName?: Maybe<Scalars['String']>;
  /** The month of the expiration date, formatted MM. */
  expirationMonth?: Maybe<Scalars['String']>;
  /** The year of the expiration date, formatted YYYY. */
  expirationYear?: Maybe<Scalars['String']>;
  /**
   * A URL to an image logo representing the card brand.
   * @deprecated This field is included for supporting legacy clients.
   */
  imageUrl?: Maybe<Scalars['String']>;
  /** The last four digits of the card number. */
  last4?: Maybe<Scalars['String']>;
  /** Additional information if the credit card was provided from a third-party origin, such as Apple Pay, Google Pay, or another digital wallet. */
  origin?: Maybe<PaymentMethodOrigin>;
  /** 3D Secure information for the payment method. */
  threeDSecure?: Maybe<ThreeDSecureDetails>;
  /** An identifier that uniquely represents any credit card number, for cards stored in a merchant's vault. If the same credit card is added to a merchant's vault multiple times, each will have the same identifier. This identifier will only be returned if the field "origin" is null. */
  uniqueNumberIdentifier?: Maybe<Scalars['String']>;
};

/** Input fields that allow you to skip certain fraud checks. These will override Control Panel settings. */
export type CreditCardFraudToolsOptionsInput = {
  /** Skip [advanced fraud checks](https://developers.braintreepayments.com/guides/advanced-fraud-management-tools/overview). */
  skipAdvancedFraudChecking?: InputMaybe<Scalars['Boolean']>;
  /** Skip AVS checks. Will result in an `avsPostalCodeResponse` of `BYPASS` in the response from the processor. */
  skipAvs?: InputMaybe<Scalars['Boolean']>;
  /** Skip CVV checks. Will result in a `cvvResponse` of `BYPASS` in the response from the processor. */
  skipCvv?: InputMaybe<Scalars['Boolean']>;
};

/** Input fields for a credit card. */
export type CreditCardInput = {
  /** The billing address for the credit card. */
  billingAddress?: InputMaybe<AddressInput>;
  /** When supplied, the cardholder name that will be tokenized with the contents of the fields. */
  cardholderName?: InputMaybe<Scalars['String']>;
  /** A three- or four-digit card verification value assigned to credit cards. The CVV will never be stored, but it can be provided with one-time requests to verify the card. */
  cvv?: InputMaybe<Scalars['String']>;
  /** The expiration month of a credit card, formatted `MM`. */
  expirationMonth?: InputMaybe<Scalars['String']>;
  /** The two- or four-digit year associated with a credit card, formatted `YYYY` or `YY`. */
  expirationYear?: InputMaybe<Scalars['String']>;
  /** The 12-to-19-digit value that uniquely identifies this credit card, also known as the primary account number or PAN. */
  number?: InputMaybe<Scalars['String']>;
};

/** Credit card specific details on a transaction or verification. */
export type CreditCardTransactionDetails = {
  __typename?: 'CreditCardTransactionDetails';
  /** The remaining balance in the account after this transaction. This field is only returned for payment methods such as prepaid cards. */
  accountBalance?: Maybe<MonetaryAmount>;
  /** For combo cards, what account type was used for this specific transaction. */
  accountType?: Maybe<CardAccountType>;
  /** Reference value assigned to a card transaction once it has been processed. */
  acquirerReferenceNumber?: Maybe<Scalars['String']>;
  /** The details of the credit card itself. */
  creditCard?: Maybe<CreditCardDetails>;
  /** The network transaction identifier provided by the payment network. If this transaction was created in order to verify a payment method before storing it in an external vault, then this value can be pased when creating subsequent transactions with the same payment method. */
  networkTransactionId?: Maybe<Scalars['String']>;
  /** Indicates whether the transaction was processed with a card on file network token. */
  processedWithCardOnFileNetworkToken?: Maybe<Scalars['Boolean']>;
};

/** Input fields for creating a transaction by authorizing or charging a credit card. */
export type CreditCardTransactionOptionsInput = {
  /** The type of account to be used when transacting with a combo card. */
  accountType?: InputMaybe<CardAccountType>;
  /** A billing address to use for the transaction. If a billing address was provided when tokenizing or is present on the vaulted credit card, it will be *merged* with this input value, with priority given to this input value. */
  billingAddress?: InputMaybe<AddressInput>;
  /** Details about this transaction if it's being created from a credit card that is or will be stored in an non-Braintree vault. */
  externalVault?: InputMaybe<TransactionExternalVaultOptionsInput>;
  /** Control which fraud tools will be applied to this transaction. Fraud tools cannot be retroactively applied to a transaction if skipped. */
  fraudTools?: InputMaybe<CreditCardFraudToolsOptionsInput>;
  /** Number of monthly installments (can be anywhere between 2 and 12). */
  installmentCount?: InputMaybe<Scalars['Int']>;
  /** The type of Strong Customer Authentication Exemption requested. */
  scaExemption?: InputMaybe<ScaExemptionType>;
  /** 3D Secure authentication information performed for this transaction. Only use these fields if you are charging or authorizing a single-use payment method ID that was *not* generated by a 3DS flow on on the client. */
  threeDSecureAuthentication?: InputMaybe<ThreeDSecureAuthenticationInput>;
  /** The CVV for the credit card to be used when creating this transction, securely tokenized with the `tokenizeCvv` mutation. */
  tokenizedCvv?: InputMaybe<Scalars['ID']>;
};

/** Information specific to verifications of credit card payment methods. */
export type CreditCardVerificationDetails = {
  __typename?: 'CreditCardVerificationDetails';
  /** The amount used when performing the verification. May be 0. */
  amount?: Maybe<MonetaryAmount>;
};

/** Input fields that specify options for verifying the credit card. */
export type CreditCardVerificationOptionsInput = {
  /** The type of account to be used when verifying a combo card. */
  accountType?: InputMaybe<CardAccountType>;
  /** The amount to use to verify the credit card. */
  amount?: InputMaybe<Scalars['Amount']>;
  /** Control which fraud tools will be applied to this verification. Fraud tools cannot be retroactively applied to a verification if skipped. */
  fraudTools?: InputMaybe<CreditCardFraudToolsOptionsInput>;
  /**
   * Deprecated: Please use `merchantAccountId` in the base input instead.
   *
   * ID of the merchant account to use when verifying the credit card.
   */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Customer device information, which is sent directly to supported processors for fraud analysis. */
  riskData?: InputMaybe<RiskDataInput>;
  /** Whether to opt out of verifying the credit card. Defaults to `false`. Clients should only pass `true` in the uncommon scenario that the credit card has been verified externally to Braintree. */
  skip?: InputMaybe<Scalars['Boolean']>;
  /** The CVV for the credit card to be used when verifying the credit card, securely tokenized with the `tokenizeCvv` mutation. */
  tokenizedCvv?: InputMaybe<Scalars['ID']>;
};

/** Top-level fields returned from a Custom Actions payment context. */
export type CustomActionsPaymentContext = Node & PaymentContext & {
  __typename?: 'CustomActionsPaymentContext';
  /** Date and time when the payment context was created. */
  createdAt: Scalars['Timestamp'];
  /** A list of fields stored on a PaymentContext during execution of a Custom Actions handler (Five (5) entries maximum). */
  customFields?: Maybe<Array<CustomActionsPaymentContextField>>;
  /** The identifier of the payment context. */
  id: Scalars['ID'];
  /** Date and time when the payment context was updated. */
  updatedAt: Scalars['Timestamp'];
};

/** Fields returned by the createPaymentContext custom actions event handler. */
export type CustomActionsPaymentContextField = {
  __typename?: 'CustomActionsPaymentContextField';
  /** An alphanumeric string used as a key to lookup a CustomField value (255 characters maximum). */
  name: Scalars['String'];
  /** An alphanumeric string used to store a CustomField value (7168 characters maximum). */
  value: Scalars['String'];
};

/** Fields that are provided when creating the payment context. */
export type CustomActionsPaymentContextFieldInput = {
  /** An alphanumeric string used as a key to lookup a CustomField value (255 characters maximum). */
  name: Scalars['String'];
  /** An alphanumeric string used to store a CustomField value (7168 characters maximum). */
  value: Scalars['String'];
};

/** Details about a custom actions payment method. */
export type CustomActionsPaymentMethodDetails = {
  __typename?: 'CustomActionsPaymentMethodDetails';
  /** The action to be invoked when using the payment method. */
  actionName?: Maybe<Scalars['String']>;
  /** Fields that your action requires. */
  fields?: Maybe<Array<CustomActionsPaymentMethodField>>;
};

/** Fields that are provided during tokenization and are presented to the invoked action to be consumed. */
export type CustomActionsPaymentMethodField = {
  __typename?: 'CustomActionsPaymentMethodField';
  /** The value displayed in the Control Panel or API, e.g. "*****6789". */
  displayValue?: Maybe<Scalars['String']>;
  /** The name of this field, e.g. "accountNumber". */
  name?: Maybe<Scalars['String']>;
};

/** Fields that are provided during tokenization and are presented to the invoked action to be consumed. */
export type CustomActionsPaymentMethodFieldInput = {
  /** The value displayed in the Control Panel or API. e.g. "*****6789". */
  displayValue: Scalars['String'];
  /** The name of this field. e.g. "accountNumber". */
  name: Scalars['String'];
  /** The value of this field. e.g. "123456789". */
  value: Scalars['String'];
};

/** Input fields for a Custom Actions payment method. */
export type CustomActionsPaymentMethodInput = {
  /** The action you wish to invoke when using the tokenized payment method. */
  actionName: Scalars['String'];
  /** Fields that your action requires. */
  fields: Array<CustomActionsPaymentMethodFieldInput>;
};

/** A merchant-defined custom field to store additional information. */
export type CustomField = {
  __typename?: 'CustomField';
  /** The name of the custom field. */
  name?: Maybe<Scalars['String']>;
  /** The value of the custom field. */
  value?: Maybe<Scalars['String']>;
};

/** Custom field name/value pairs. Maximum 255 characters. You must [set up each custom field in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#creating-a-custom-field) prior to passing it with a request. */
export type CustomFieldInput = {
  /** Name of the custom field as defined in the Control Panel. */
  name: Scalars['CustomFieldName'];
  /** Value for the named custom field. A null value will ignore (on create) or remove (on update) the custom field. */
  value?: InputMaybe<Scalars['String']>;
};

/** Information about a customer and their associated payment methods and transactions. */
export type Customer = Node & {
  __typename?: 'Customer';
  /** Company or business name associated with this customer. */
  company?: Maybe<Scalars['String']>;
  /** Date and time at which the customer was created. */
  createdAt?: Maybe<Scalars['Timestamp']>;
  /** Collection of custom field/value pairs. Custom fields are [defined in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#store-and-pass-back-fields). */
  customFields?: Maybe<Array<CustomField>>;
  /** Customer's default payment method. */
  defaultPaymentMethod?: Maybe<PaymentMethod>;
  /** Email address for this customer. */
  email?: Maybe<Scalars['String']>;
  /** Customer's first name. */
  firstName?: Maybe<Scalars['String']>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Customer's last name. */
  lastName?: Maybe<Scalars['String']>;
  /** Legacy unique identifier. */
  legacyId: Scalars['ID'];
  /** Payment methods belonging to this customer. */
  paymentMethods?: Maybe<PaymentMethodConnection>;
  /** The phone number for this customer. */
  phoneNumber?: Maybe<Scalars['String']>;
  /** Transactions associated with this customer. This includes transactions created by charging a vaulted payment method that belongs or belonged to the customer, or by passing a customer ID when charging a single-use payment method. */
  transactions?: Maybe<TransactionConnection>;
};


/** Information about a customer and their associated payment methods and transactions. */
export type CustomerPaymentMethodsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Information about a customer and their associated payment methods and transactions. */
export type CustomerTransactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
};

/** A value indicating when to perform further customer authentication. */
export enum CustomerAuthenticationIndicator {
  /** Indicates further authentication is optional. */
  Optional = 'OPTIONAL',
  /** Indicates further authentication should be performed. */
  Required = 'REQUIRED',
  /** Customer authentication indicator information is unavailable at this time. */
  Unavailable = 'UNAVAILABLE'
}

/** The customer authentication regulation environment that applies to the transaction, such as [PSD2](https://www.braintreepayments.com/blog/understanding-and-preparing-for-psd2-strong-customer-authentication/). */
export enum CustomerAuthenticationRegulationEnvironment {
  /** EU Regulation [PSD2 Strong Customer Authentication](https://www.braintreepayments.com/blog/understanding-and-preparing-for-psd2-strong-customer-authentication/) applies to this transaction. */
  Psdtwo = 'PSDTWO',
  /** Reserve Bank of India regulations apply to this transactions. */
  Rbi = 'RBI',
  /** Customer authentication regulation environment information is unavailable for this transaction at this time. */
  Unavailable = 'UNAVAILABLE',
  /** No customer authentication regulations apply to this transaction. */
  Unregulated = 'UNREGULATED'
}

/** A paginated list of customers. */
export type CustomerConnection = {
  __typename?: 'CustomerConnection';
  /** A list of customers. */
  edges?: Maybe<Array<Maybe<CustomerConnectionEdge>>>;
  /** Information about the page of customers contained in `edges`. */
  pageInfo: PageInfo;
};

/** A customer within a CustomerConnection. */
export type CustomerConnectionEdge = {
  __typename?: 'CustomerConnectionEdge';
  /** This customer's location within the CustomerConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The customer. */
  node?: Maybe<Customer>;
};

/** Input fields for creating or updating a customer. On update, omitted fields will not be updated. Passing a null value will assign null to that field. */
export type CustomerInput = {
  /** Company or business name associated with the customer. */
  company?: InputMaybe<Scalars['String']>;
  /** Collection of custom field/value pairs. You must [set up each custom field in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#creating-a-custom-field) prior to passing it with a request. */
  customFields?: InputMaybe<Array<CustomFieldInput>>;
  /** Email address for the customer. */
  email?: InputMaybe<Scalars['String']>;
  /** Customer's first name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Customer's last name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** The customer's phone number. */
  phoneNumber?: InputMaybe<Scalars['String']>;
  /**
   * A set of country code ID pairs, analogous to Social Security numbers in the United States.
   *
   * A customer may have multiple tax identifiers, but only one per tax jurisdiction. The values provided for an update will be stored and previous entries will be updated.
   *
   * **Note:** You will only need to use these fields for processing in certain countries.
   */
  taxIdentifiers?: InputMaybe<Array<CustomerTaxIdentifierInput>>;
};

/** Input fields for searching for customers. */
export type CustomerSearchInput = {
  /** Find customers with a given company or business name. */
  company?: InputMaybe<SearchTextInput>;
  /** Find customers with a given created at time. */
  createdAt?: InputMaybe<SearchTimestampInput>;
  /** Find customers with a given email address. */
  email?: InputMaybe<SearchTextInput>;
  /** Find customers with a given first name. */
  firstName?: InputMaybe<SearchTextInput>;
  /** Find customers with an id or ids. */
  id?: InputMaybe<SearchValueInput>;
  /** Find customers with a given last name. */
  lastName?: InputMaybe<SearchTextInput>;
  /** Find customers with a given phone number. */
  phoneNumber?: InputMaybe<SearchTextInput>;
};

/** The customer's tax identifer for a given tax jurisdiction. */
export type CustomerTaxIdentifierInput = {
  /** The country code of the tax jurisdiction for this tax identifier. */
  countryCode: Scalars['CountryCode'];
  /** The identifier provided in the format required for the given tax jurisdiction. */
  identifier: Scalars['String'];
};

/** Top-level input fields for deleting a customer. */
export type DeleteCustomerInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the customer to be deleted. */
  customerId: Scalars['ID'];
};

/** Top-level output field from deleting a customer. */
export type DeleteCustomerPayload = {
  __typename?: 'DeleteCustomerPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Input fields for deleting dispute evidence. */
export type DeleteDisputeEvidenceInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the dispute that the evidence belongs to. */
  disputeId: Scalars['ID'];
  /** The ID of the evidence to be deleted. */
  evidenceId: Scalars['ID'];
};

/** Top-level field returned when deleting evidence from a dispute. */
export type DeleteDisputeEvidencePayload = {
  __typename?: 'DeleteDisputeEvidencePayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Top-level input fields for deleting a payment method referenced by a single-use token. */
export type DeletePaymentMethodFromSingleUseTokenInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A single-use token ID referencing a payment method. */
  singleUseTokenId: Scalars['ID'];
};

/** Top-level output field from deleting a payment method referenced by a single-use token. */
export type DeletePaymentMethodFromSingleUseTokenPayload = {
  __typename?: 'DeletePaymentMethodFromSingleUseTokenPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Top-level input fields for deleting a multi-use payment method from the vault. */
export type DeletePaymentMethodFromVaultInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Additionally request deletion of all related payment methods (ones that store the same underlying payment instrument as the one specified by `paymentMethodId`) across all customers for current merchant. */
  deleteRelatedPaymentMethods?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if this deletion is related to suspected fraud, as determined by the merchant. */
  fraudRelated?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether this deletion was initiated by the merchant or the customer (via the merchant site/app). */
  initiatedBy?: InputMaybe<PaymentMethodDeletionInitiator>;
  /** The ID of the multi-use payment method to be deleted. */
  paymentMethodId: Scalars['ID'];
};

/** Top-level output field from deleting a multi-use payment method. */
export type DeletePaymentMethodFromVaultPayload = {
  __typename?: 'DeletePaymentMethodFromVaultPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Specific input fields for describing a detached refund. */
export type DetachedRefundInput = {
  /** The amount to refund. */
  amount: Scalars['Amount'];
  /** Collection of custom field/value pairs. You must [set up each custom field in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#creating-a-custom-field) prior to passing it with a request. */
  customFields?: InputMaybe<Array<CustomFieldInput>>;
  /** Fields used to define what will appear on a customer's statement (for instance, credit card or bank statement) for this refund. This should match the original transaction if possible. */
  descriptor?: InputMaybe<TransactionDescriptorInput>;
  /** ID of the merchant account that will be used when performing the refund. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** The refund's order ID. */
  orderId?: InputMaybe<Scalars['String']>;
};

/** Details about the disbursement bank account. */
export type DisbursementBankAccount = {
  __typename?: 'DisbursementBankAccount';
  /** The last four digits of the bank account number. */
  last4?: Maybe<Scalars['String']>;
  /** The routing number of the bank. */
  routingNumber?: Maybe<Scalars['String']>;
};

/** Disbursement details contain information about how and when the transaction was disbursed, including timing and currency information. This field is only available if you have an eligible merchant account. */
export type DisbursementDetails = {
  __typename?: 'DisbursementDetails';
  /** Amount of money disbursed in the settlement currency, which may be different than the transaction's [presentment currency](https://articles.braintreepayments.com/get-started/currencies). */
  amount?: Maybe<MonetaryAmount>;
  /** The date that the funds associated with this transaction were disbursed. */
  date?: Maybe<Scalars['Date']>;
  /** The exchange rate from the presentment currency to the settlement currency. If the currencies are the same, this will be 1. */
  exchangeRate?: Maybe<Scalars['String']>;
  /** Indicates whether funds have been withheld from a disbursement to the merchant's account. */
  fundsHeld?: Maybe<Scalars['Boolean']>;
};

/** The display item type to be displayed on the in-store reader. */
export enum DisplayItemType {
  Charge = 'CHARGE',
  Discount = 'DISCOUNT',
  LineBreak = 'LINE_BREAK',
  Text = 'TEXT'
}

/** [A case raised by a customer to either request information about or to challenge a charge](https://articles.braintreepayments.com/risk-and-security/chargebacks-retrievals/overview). These are initiated via a customer's payment provider, such as their bank, and require a merchant to provide evidence or further information. */
export type Dispute = Node & {
  __typename?: 'Dispute';
  /** The amount of money from the original charge that the customer is disputing. Can be 0. This amount is debited from a merchant's account and held in a third-party account until the dispute is resolved, at which time it is sent to either the merchant or customer. */
  amountDisputed?: Maybe<MonetaryAmount>;
  /** If an amount was disputed, the amount of money awarded back to the merchant if the dispute was reversed. */
  amountWon?: Maybe<MonetaryAmount>;
  /** The case number for the dispute. */
  caseNumber?: Maybe<Scalars['String']>;
  /**
   * The chargeback protection status of the dispute.
   * @deprecated Use `protectionLevel` instead.
   */
  chargebackProtectionLevel?: Maybe<ChargebackProtectionLevel>;
  /** Date and time at which the dispute was created. */
  createdAt?: Maybe<Scalars['Timestamp']>;
  /** Evidence records submitted by the merchant for the dispute. */
  evidence?: Maybe<Array<DisputeEvidence>>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Legacy unique identifier. */
  legacyId: Scalars['ID'];
  /** If this dispute is a follow-up to a previous chargeback or retrieval, the original dispute. */
  originalDispute?: Maybe<Dispute>;
  /** The pre-dispute program of the dispute. */
  preDisputeProgram?: Maybe<PreDisputeProgram>;
  /** Additional information from the payment processor. */
  processorResponse?: Maybe<DisputeProcessorResponse>;
  /** The protection level of the dispute. */
  protectionLevel?: Maybe<DisputeProtectionLevel>;
  /** Date the dispute was received by the merchant. */
  receivedDate?: Maybe<Scalars['Date']>;
  /** The transaction reference number for the dispute. */
  referenceNumber?: Maybe<Scalars['String']>;
  /** The reply by date for the merchant to submit a response to the dispute. */
  replyByDate?: Maybe<Scalars['Date']>;
  /** The deadline for the merchant to submit a response to the dispute. */
  responseDeadline?: Maybe<Scalars['Timestamp']>;
  /** The status of the dispute. */
  status?: Maybe<DisputeStatus>;
  /** A log of history events containing status changes by date for this dispute. */
  statusHistory?: Maybe<Array<DisputeStatusEvent>>;
  /** The disputed transaction which the customer is either requesting further information on or challenging. */
  transaction?: Maybe<Transaction>;
  /** The type of dispute. */
  type?: Maybe<DisputeType>;
};

/** A paginated list of disputes. */
export type DisputeConnection = {
  __typename?: 'DisputeConnection';
  /** A list of disputes. */
  edges?: Maybe<Array<Maybe<DisputeConnectionEdge>>>;
  /** Information about the page of disputes contained in `edges`. */
  pageInfo: PageInfo;
};

/** A dispute within a DisputeConnection. */
export type DisputeConnectionEdge = {
  __typename?: 'DisputeConnectionEdge';
  /** This dispute's location within the DisputeConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The dispute. */
  node?: Maybe<Dispute>;
};

/** Evidence provided by a merchant to respond to a dispute. */
export type DisputeEvidence = {
  /** The evidence category. */
  category?: Maybe<DisputeEvidenceCategory>;
  /** Date and time when the evidence was created with Braintree. */
  createdAt?: Maybe<Scalars['Timestamp']>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Legacy unique identifier. */
  legacyId: Scalars['ID'];
  /** Date and time when the evidence was sent to the processor. */
  sentToProcessorAt?: Maybe<Scalars['Timestamp']>;
};

/** The evidence category that specifies which requirement it satisfies. */
export enum DisputeEvidenceCategory {
  AvsResponse = 'AVS_RESPONSE',
  CarrierName = 'CARRIER_NAME',
  CarrierNameOther = 'CARRIER_NAME_OTHER',
  CreditIssuedAmount = 'CREDIT_ISSUED_AMOUNT',
  CreditIssuedDateTime = 'CREDIT_ISSUED_DATE_TIME',
  DeviceId = 'DEVICE_ID',
  DeviceName = 'DEVICE_NAME',
  DownloadDateTime = 'DOWNLOAD_DATE_TIME',
  EvidenceType = 'EVIDENCE_TYPE',
  General = 'GENERAL',
  GeographicalLocation = 'GEOGRAPHICAL_LOCATION',
  LegitPaymentsForSameMerchandise = 'LEGIT_PAYMENTS_FOR_SAME_MERCHANDISE',
  MerchantWebsiteOrAppAccess = 'MERCHANT_WEBSITE_OR_APP_ACCESS',
  PriorDigitalGoodsTransactionArn = 'PRIOR_DIGITAL_GOODS_TRANSACTION_ARN',
  PriorDigitalGoodsTransactionDateTime = 'PRIOR_DIGITAL_GOODS_TRANSACTION_DATE_TIME',
  PriorDigitalGoodsTransactionId = 'PRIOR_DIGITAL_GOODS_TRANSACTION_ID',
  PriorNonDisputedTransactionArn = 'PRIOR_NON_DISPUTED_TRANSACTION_ARN',
  PriorNonDisputedTransactionDateTime = 'PRIOR_NON_DISPUTED_TRANSACTION_DATE_TIME',
  PriorNonDisputedTransactionEmailAddress = 'PRIOR_NON_DISPUTED_TRANSACTION_EMAIL_ADDRESS',
  PriorNonDisputedTransactionId = 'PRIOR_NON_DISPUTED_TRANSACTION_ID',
  PriorNonDisputedTransactionIpAddress = 'PRIOR_NON_DISPUTED_TRANSACTION_IP_ADDRESS',
  PriorNonDisputedTransactionPhoneNumber = 'PRIOR_NON_DISPUTED_TRANSACTION_PHONE_NUMBER',
  PriorNonDisputedTransactionPhysicalAddress = 'PRIOR_NON_DISPUTED_TRANSACTION_PHYSICAL_ADDRESS',
  ProfileSetupOrAppAccess = 'PROFILE_SETUP_OR_APP_ACCESS',
  ProofOf_3DSecure = 'PROOF_OF_3D_SECURE',
  ProofOfAuthorizedSigner = 'PROOF_OF_AUTHORIZED_SIGNER',
  ProofOfDelivery = 'PROOF_OF_DELIVERY',
  ProofOfDeliveryEmpAddress = 'PROOF_OF_DELIVERY_EMP_ADDRESS',
  ProofOfPossessionOrUsage = 'PROOF_OF_POSSESSION_OR_USAGE',
  PurchaserEmailAddress = 'PURCHASER_EMAIL_ADDRESS',
  PurchaserIpAddress = 'PURCHASER_IP_ADDRESS',
  PurchaserName = 'PURCHASER_NAME',
  RecurringTransactionArn = 'RECURRING_TRANSACTION_ARN',
  RecurringTransactionDateTime = 'RECURRING_TRANSACTION_DATE_TIME',
  RecurringTransactionId = 'RECURRING_TRANSACTION_ID',
  RefundId = 'REFUND_ID',
  SignedDeliveryForm = 'SIGNED_DELIVERY_FORM',
  SignedOrderForm = 'SIGNED_ORDER_FORM',
  TicketProof = 'TICKET_PROOF',
  TrackingNumber = 'TRACKING_NUMBER',
  TrackingUrl = 'TRACKING_URL'
}

/** Images, files, or other evidence supporting a dispute case. */
export type DisputeFileEvidence = DisputeEvidence & {
  __typename?: 'DisputeFileEvidence';
  /** The evidence category. */
  category?: Maybe<DisputeEvidenceCategory>;
  /** Date and time at which the evidence was created with Braintree. */
  createdAt?: Maybe<Scalars['Timestamp']>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Legacy unique identifier. */
  legacyId: Scalars['ID'];
  /** Date and time at which the evidence was sent to the processor. */
  sentToProcessorAt?: Maybe<Scalars['Timestamp']>;
  /** A URL where you can retrieve the dispute evidence. */
  url?: Maybe<Scalars['String']>;
};

/** For file evidence: the evidence category that specifies which requirement it satisfies. */
export enum DisputeFileEvidenceCategory {
  General = 'GENERAL',
  LegitPaymentsForSameMerchandise = 'LEGIT_PAYMENTS_FOR_SAME_MERCHANDISE',
  MerchantWebsiteOrAppAccess = 'MERCHANT_WEBSITE_OR_APP_ACCESS',
  ProfileSetupOrAppAccess = 'PROFILE_SETUP_OR_APP_ACCESS',
  ProofOf_3DSecure = 'PROOF_OF_3D_SECURE',
  ProofOfAuthorizedSigner = 'PROOF_OF_AUTHORIZED_SIGNER',
  ProofOfDelivery = 'PROOF_OF_DELIVERY',
  ProofOfDeliveryEmpAddress = 'PROOF_OF_DELIVERY_EMP_ADDRESS',
  ProofOfPossessionOrUsage = 'PROOF_OF_POSSESSION_OR_USAGE',
  SignedDeliveryForm = 'SIGNED_DELIVERY_FORM',
  SignedOrderForm = 'SIGNED_ORDER_FORM',
  TicketProof = 'TICKET_PROOF'
}

/** Information about the dispute provided by the processor. */
export type DisputeProcessorResponse = {
  __typename?: 'DisputeProcessorResponse';
  /** Additional comments forwarded by the processor. */
  processorComments?: Maybe<Scalars['String']>;
  /** The reason the dispute was created. */
  reason?: Maybe<DisputeReason>;
  /** The reason code provided by the processor. */
  reasonCode?: Maybe<Scalars['String']>;
  /** The reason code description based on the `reasonCode`. */
  reasonDescription?: Maybe<Scalars['String']>;
  /** Date the dispute was received by the merchant. */
  receivedDate?: Maybe<Scalars['Date']>;
  /** The string value representing the reference number provided by the processor (if any). */
  referenceNumber?: Maybe<Scalars['String']>;
};

/** The Protection level indicates if dispute is eligible for protection through any feature enabled on your account. */
export enum DisputeProtectionLevel {
  /** The dispute is protected by the standard chargeback protection product. */
  ChargebackProtectionTool = 'CHARGEBACK_PROTECTION_TOOL',
  /** The dispute is protected by the effortless chargeback protection product. */
  EffortlessChargebackProtectionTool = 'EFFORTLESS_CHARGEBACK_PROTECTION_TOOL',
  /** The merchant has not enrolled in any chargeback protection products, or the merchant is enrolled, but the dispute is not protected. */
  NoProtection = 'NO_PROTECTION'
}

/** The reason a customer opened a chargeback, pre-arbitration, or retrieval. */
export enum DisputeReason {
  CancelledRecurringTransaction = 'CANCELLED_RECURRING_TRANSACTION',
  CreditNotProcessed = 'CREDIT_NOT_PROCESSED',
  Duplicate = 'DUPLICATE',
  Fraud = 'FRAUD',
  General = 'GENERAL',
  InvalidAccount = 'INVALID_ACCOUNT',
  NotRecognized = 'NOT_RECOGNIZED',
  ProductNotReceived = 'PRODUCT_NOT_RECEIVED',
  ProductUnsatisfactory = 'PRODUCT_UNSATISFACTORY',
  Retrieval = 'RETRIEVAL',
  TransactionAmountDiffers = 'TRANSACTION_AMOUNT_DIFFERS'
}

/** Input fields for searching for Disputes. */
export type DisputeSearchInput = {
  /** Find disputes for a given amount or currency. */
  amountDisputed?: InputMaybe<MonetaryAmountSearchInput>;
  /** Find disputes by the amount won. */
  amountWon?: InputMaybe<MonetaryAmountSearchInput>;
  /** Find disputes with a given processor's caseNumber. */
  caseNumber?: InputMaybe<SearchTextInput>;
  /**
   * Deprecated: Please use `protectionLevel` instead.
   *
   * Find disputes with a given computed chargeback protection level.
   */
  chargebackProtectionLevel?: InputMaybe<SearchChargebackProtectionLevelInput>;
  /** Find disputes by the date a status change history event took effect. */
  effectiveDate?: InputMaybe<SearchDateInput>;
  /** Find disputes with an id or ids. */
  id?: InputMaybe<SearchValueInput>;
  /** Find disputes with a given pre-dispute program. */
  preDisputeProgram?: InputMaybe<SearchPreDisputeProgramInput>;
  /** Find disputes with a given protection level. */
  protectionLevel?: InputMaybe<SearchDisputeProtectionLevelInput>;
  /** Find disputes with a given reason description. */
  reason?: InputMaybe<SearchDisputeReasonInput>;
  /** Find disputes by the date received. */
  receivedDate?: InputMaybe<SearchDateInput>;
  /** Find disputes with a given transaction referenceNumber. */
  referenceNumber?: InputMaybe<SearchTextInput>;
  /** Find disputes by the reply by date. */
  replyByDate?: InputMaybe<SearchDateInput>;
  /** Find disputes with a given status. */
  status?: InputMaybe<SearchDisputeStatusInput>;
  /** Find disputes based on a set of transaction criteria. */
  transaction?: InputMaybe<DisputeTransactionSearchInput>;
  /** Find disputes with a given type. */
  type?: InputMaybe<SearchDisputeTypeInput>;
};

/** The status of the dispute. */
export enum DisputeStatus {
  Accepted = 'ACCEPTED',
  AutoAccepted = 'AUTO_ACCEPTED',
  Disputed = 'DISPUTED',
  Expired = 'EXPIRED',
  Lost = 'LOST',
  Open = 'OPEN',
  Won = 'WON'
}

/** A record of a status the dispute has passed through. */
export type DisputeStatusEvent = {
  __typename?: 'DisputeStatusEvent';
  /** The date any funds associated with this event were disbursed. */
  disbursementDate?: Maybe<Scalars['Date']>;
  /** The date the status event took effect. */
  effectiveDate?: Maybe<Scalars['Date']>;
  /** The status of the dispute. */
  status?: Maybe<DisputeStatus>;
  /** Date and time when the status event occurred. */
  timestamp?: Maybe<Scalars['Timestamp']>;
};

/** Text evidence supporting a dispute case. */
export type DisputeTextEvidence = DisputeEvidence & {
  __typename?: 'DisputeTextEvidence';
  /** The evidence category. */
  category?: Maybe<DisputeEvidenceCategory>;
  /**
   * The body for text evidence.
   * @deprecated Use `content` for name instead.
   */
  comment?: Maybe<Scalars['String']>;
  /** The body for text evidence. */
  content?: Maybe<Scalars['String']>;
  /** Date and time at which the evidence was created with Braintree. */
  createdAt?: Maybe<Scalars['Timestamp']>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Legacy unique identifier. */
  legacyId: Scalars['ID'];
  /** Date and time at which the evidence was sent to the processor. */
  sentToProcessorAt?: Maybe<Scalars['Timestamp']>;
};

/** For text evidence: the evidence category that specifies which requirement it satisfies. */
export enum DisputeTextEvidenceCategory {
  AvsResponse = 'AVS_RESPONSE',
  CreditIssuedAmount = 'CREDIT_ISSUED_AMOUNT',
  CreditIssuedDateTime = 'CREDIT_ISSUED_DATE_TIME',
  DeviceId = 'DEVICE_ID',
  DeviceName = 'DEVICE_NAME',
  DownloadDateTime = 'DOWNLOAD_DATE_TIME',
  GeographicalLocation = 'GEOGRAPHICAL_LOCATION',
  PriorDigitalGoodsTransactionArn = 'PRIOR_DIGITAL_GOODS_TRANSACTION_ARN',
  PriorDigitalGoodsTransactionDateTime = 'PRIOR_DIGITAL_GOODS_TRANSACTION_DATE_TIME',
  PriorDigitalGoodsTransactionId = 'PRIOR_DIGITAL_GOODS_TRANSACTION_ID',
  PriorNonDisputedTransactionArn = 'PRIOR_NON_DISPUTED_TRANSACTION_ARN',
  PriorNonDisputedTransactionDateTime = 'PRIOR_NON_DISPUTED_TRANSACTION_DATE_TIME',
  PriorNonDisputedTransactionEmailAddress = 'PRIOR_NON_DISPUTED_TRANSACTION_EMAIL_ADDRESS',
  PriorNonDisputedTransactionId = 'PRIOR_NON_DISPUTED_TRANSACTION_ID',
  PriorNonDisputedTransactionIpAddress = 'PRIOR_NON_DISPUTED_TRANSACTION_IP_ADDRESS',
  PriorNonDisputedTransactionPhoneNumber = 'PRIOR_NON_DISPUTED_TRANSACTION_PHONE_NUMBER',
  PriorNonDisputedTransactionPhysicalAddress = 'PRIOR_NON_DISPUTED_TRANSACTION_PHYSICAL_ADDRESS',
  PurchaserEmailAddress = 'PURCHASER_EMAIL_ADDRESS',
  PurchaserIpAddress = 'PURCHASER_IP_ADDRESS',
  PurchaserName = 'PURCHASER_NAME',
  RecurringTransactionArn = 'RECURRING_TRANSACTION_ARN',
  RecurringTransactionDateTime = 'RECURRING_TRANSACTION_DATE_TIME',
  RecurringTransactionId = 'RECURRING_TRANSACTION_ID'
}

/** Transaction input fields for searching for disputes. */
export type DisputeTransactionSearchInput = {
  /** Find disputes for a customer id or ids. */
  customerId?: InputMaybe<SearchValueInput>;
  /** Find disputes by the transaction's disbursement date. */
  disbursementDate?: InputMaybe<SearchDateInput>;
  /** Find disputes on transactions created by a third party via the Grant API using a given OAuth application client ID. */
  facilitatorOAuthApplicationClientId?: InputMaybe<SearchValueInput>;
  /** Find disputes on transactions associated with a merchant account ID or IDs. */
  merchantAccountId?: InputMaybe<SearchValueInput>;
  /** Find disputes on transactions charging payment methods of the given type. */
  paymentMethodSnapshotType?: InputMaybe<SearchPaymentMethodSnapshotTypeInput>;
  /** Find disputes for a transaction id or ids. */
  transactionId?: InputMaybe<SearchValueInput>;
  /** Find disputes with a given transaction source. */
  transactionSource?: InputMaybe<SearchTransactionSourceInput>;
};

/** Type of dispute. */
export enum DisputeType {
  Chargeback = 'CHARGEBACK',
  /** A [second challenge to a charge](https://articles.braintreepayments.com/risk-and-security/chargebacks-retrievals/overview#pre-arbitrations), in the case that you have won an initial chargeback. */
  PreArbitration = 'PRE_ARBITRATION',
  Retrieval = 'RETRIEVAL'
}

/** Additional information about an integrated circuit card (ICC) payment method supplied by an in-store payment reader. */
export type EmvCardOriginDetails = InStoreReaderOriginDetails & {
  __typename?: 'EmvCardOriginDetails';
  /** The cryptogram provided by an integrated circuit card (ICC) used for processing the transaction. */
  applicationCryptogram?: Maybe<Scalars['String']>;
  /** The identifier specifying which EMV application was used to process the transaction. */
  applicationIdentifier?: Maybe<Scalars['String']>;
  /** An indicator of the credit card's capabilities within the processing application. */
  applicationInterchangeProfile?: Maybe<Scalars['String']>;
  /** The preferred name associated with the application used to process an EMV transaction. */
  applicationPreferredName?: Maybe<Scalars['String']>;
  /** A counter managed by an integrated circuit card (ICC) that provides a reference to each transaction using that card. */
  applicationTransactionCounter?: Maybe<Scalars['String']>;
  /** An indicator used to specify an issuer's restrictions for processing in a geographic region. */
  applicationUsageControl?: Maybe<Scalars['String']>;
  /** The authorization mode used to perform the transaction on the payment reader. */
  authorizationMode?: Maybe<InStoreReaderAuthorizationMode>;
  /** A unique identifier for credit cards that share the same PAN. */
  cardSequenceNumber?: Maybe<Scalars['String']>;
  /** An indicator of the cardholder verification method and if it was successful or unsuccessful. */
  cardholderVerificationMethodResults?: Maybe<Scalars['String']>;
  /** An additional amount associated with the transaction that represents the cashback amount requested by the cardholder. */
  cashbackAmount?: Maybe<Scalars['String']>;
  /** An indicator for the type of application cryptogram provided by an integrated circuit card (ICC) to process the transaction. */
  cryptogramInformationData?: Maybe<Scalars['String']>;
  /** The input mode used on the payment reader to facilitate an in-store transaction. */
  inputMode?: Maybe<PaymentReaderInputMode>;
  /** An indicator of the conditions that caused a transaction to be offline declined by the issuer, in a scenario where the transaction may have authorized if the payment reader made a processor request but was unable to. */
  issuerActionCodeDefault?: Maybe<Scalars['String']>;
  /** An indicator of the conditions that caused a transaction to be offline declined by the issuer, in a scenario where the payment reader did not attempt to make a processor request. */
  issuerActionCodeDenial?: Maybe<Scalars['String']>;
  /** An indicator of the conditions that caused the payment reader to attempt to make a processor request. */
  issuerActionCodeOnline?: Maybe<Scalars['String']>;
  /** An indicator for whether the transaction was verified via pin. */
  pinVerified?: Maybe<Scalars['Boolean']>;
  /** The country code indicated by the payment reader to process the transaction with. */
  terminalCountryCode?: Maybe<Scalars['String']>;
  /** The ID of the terminal that was processed this transaction. */
  terminalId?: Maybe<Scalars['String']>;
  /** The local date that the transaction requested authorization from the payment reader, formatted YYMMDD. */
  terminalTransactionDate?: Maybe<Scalars['String']>;
  /** An indicator of the type of transaction specified during authorization processing. */
  terminalTransactionType?: Maybe<Scalars['String']>;
  /** A status code representing the result of a series of validations performed against an EMV enabled credit card. */
  terminalVerificationResult?: Maybe<Scalars['String']>;
  /** A value used to uniquely differentiate an application cryptogram used during authorization processing. */
  unpredictableNumber?: Maybe<Scalars['String']>;
};

/** Details of the generated exchange rate quote. */
export type ExchangeRateQuote = {
  __typename?: 'ExchangeRateQuote';
  /** The amount in the `baseCurrency` to be converted to the `quoteCurrency`. If no amount was provided, then this amount is 1 unit of `baseCurrency`. */
  baseAmount?: Maybe<MonetaryAmount>;
  /**
   * This much of `quoteCurrency` is required to buy 1 unit of `baseCurrency`. This includes merchant `markupPercentage` if any.
   * If a `markupPercentage` is specified, this field will be the sum of that percentage and the `tradeRate`.
   */
  exchangeRate?: Maybe<Scalars['ExchangeRate']>;
  /** When the exchange rate quote represents expires. */
  expiresAt?: Maybe<Scalars['Timestamp']>;
  /** Unique identifier, which must be passed in the payment request in order to honor the exchange rate during settlement. */
  id: Scalars['ID'];
  /**
   * The amount in the `quoteCurrency` converted from the `baseCurrency`.
   * If no amount was provided, then this amount is converted from 1 unit of `baseCurrency`, which will be the same as `exchangeRate` after rounding-off.
   */
  quoteAmount?: Maybe<MonetaryAmount>;
  /** When the exchange rate quote represents will be refreshed. */
  refreshesAt?: Maybe<Scalars['Timestamp']>;
  /** This is the rate at which PayPal will settle with the merchant. */
  tradeRate?: Maybe<Scalars['ExchangeRate']>;
};

/** Input to generate the exchange rate quote. */
export type ExchangeRateQuoteInput = {
  /** The amount in the `baseCurrency` to be converted to the `quoteCurrency`. If this is provided, the result will include the converted amount properly rounded. */
  baseAmount?: InputMaybe<Scalars['Amount']>;
  /** The currency code from which the exchange rate will be used to convert to the `quoteCurrency`. */
  baseCurrency: Scalars['CurrencyCodeAlpha'];
  /** A percentage added into the exchange rate. This allows the merchant to settle for more than the quoted `tradeRate`. */
  markup?: InputMaybe<Scalars['Percentage']>;
  /** The currency code to which the exchange rate will be used to convert from `baseCurrency`. */
  quoteCurrency: Scalars['CurrencyCodeAlpha'];
};

/** Exchange rate quotes for a specific customer. */
export type ExchangeRateQuotePayload = {
  __typename?: 'ExchangeRateQuotePayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Exchange rate quote details for each base and quote currency combination. */
  quotes?: Maybe<Array<ExchangeRateQuote>>;
};

/** A credit card's assocation with an external vault. */
export enum ExternalVaultStatus {
  /** The payment method for this transaction has been vaulted in an external vault. */
  Vaulted = 'VAULTED',
  /** The payment method has not been vaulted in an exernal vault, but it will be if this transaction is successfully processed. */
  WillVault = 'WILL_VAULT'
}

/** Fields capturing information about a third party that provided payment information for this transaction via the Grant API, Shared Vault, or Google Pay. */
export type FacilitatorDetails = {
  __typename?: 'FacilitatorDetails';
  /** The OAuth application that owns the payment information used to create the transaction. */
  oauthApplication?: Maybe<OAuthApplication>;
};

/** Accompanying information for a transaction that failed because it could not be successfully sent to the processor. */
export type FailedEvent = PaymentStatusEvent & {
  __typename?: 'FailedEvent';
  /** The amount of the transaction for this status event. */
  amount?: Maybe<MonetaryAmount>;
  /** Fields describing the network response to the authorization request. */
  networkResponse?: Maybe<PaymentNetworkResponse>;
  /** Fields describing the payment processor response, or an explanation for the lack thereof. */
  processorResponse?: Maybe<TransactionAuthorizationProcessorResponse>;
  /** Risk decision for this transaction. */
  riskDecision?: Maybe<RiskDecision>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the transaction failed. */
  timestamp?: Maybe<Scalars['Timestamp']>;
  /** User name of the person who performed an action that triggered the status change of the transaction. */
  userName?: Maybe<Scalars['String']>;
};

/** Top-level input fields for finalizing a dispute. */
export type FinalizeDisputeInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the dispute to be finalized. */
  disputeId: Scalars['ID'];
};

/** Top-level field returned when finalizing a dispute. */
export type FinalizeDisputePayload = {
  __typename?: 'FinalizeDisputePayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Information about the dispute that was finalized. */
  dispute?: Maybe<Dispute>;
};

/** Configuration for fraud protection provider. */
export type FraudProviderConfiguration = {
  __typename?: 'FraudProviderConfiguration';
  /** The merchant ID used by the fraud protection provider to identify the fraud data collection request. */
  merchantId?: Maybe<Scalars['String']>;
  /** The name of the fraud provider. */
  name?: Maybe<Scalars['String']>;
};

/** The fraud service provider used to generate the risk decision. */
export enum FraudServiceProvider {
  ChargebackProtection = 'CHARGEBACK_PROTECTION',
  EffortlessChargebackProtection = 'EFFORTLESS_CHARGEBACK_PROTECTION',
  FraudProtection = 'FRAUD_PROTECTION',
  FraudProtectionAdvanced = 'FRAUD_PROTECTION_ADVANCED',
  FraudProtectionEnterprise = 'FRAUD_PROTECTION_ENTERPRISE',
  Kount = 'KOUNT'
}

/** Accompanying information for a gateway rejected transaction. */
export type GatewayRejectedEvent = PaymentStatusEvent & {
  __typename?: 'GatewayRejectedEvent';
  /** The amount of the transaction for this status event. */
  amount?: Maybe<MonetaryAmount>;
  /** The original transaction if the gateway rejection reason was `DUPLICATE`. */
  duplicateOf?: Maybe<Transaction>;
  /** The reason the transaction was rejected, based on your gateway settings. */
  gatewayRejectionReason?: Maybe<GatewayRejectionReason>;
  /** Fields describing the network response to the authorization request. */
  networkResponse?: Maybe<PaymentNetworkResponse>;
  /** Fields describing the payment processor response. Depending on your gateway settings, the AVS and CVV responses may be the reason for the rejection. */
  processorResponse?: Maybe<TransactionAuthorizationProcessorResponse>;
  /** Risk decision for this transaction. If the gatewayRejectionReason is fraud, this may be the reason for the rejection. */
  riskDecision?: Maybe<RiskDecision>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the transaction was rejected by the gateway. */
  timestamp?: Maybe<Scalars['Timestamp']>;
  /** User name of the person who performed an action that triggered the status change of the transaction. */
  userName?: Maybe<Scalars['String']>;
};

/** Possible reasons why a transaction was rejected by the gateway. */
export enum GatewayRejectionReason {
  ApplicationIncomplete = 'APPLICATION_INCOMPLETE',
  Avs = 'AVS',
  AvsAndCvv = 'AVS_AND_CVV',
  Cvv = 'CVV',
  Duplicate = 'DUPLICATE',
  ExcessiveRetry = 'EXCESSIVE_RETRY',
  Fraud = 'FRAUD',
  ManualTransactionsDisabled = 'MANUAL_TRANSACTIONS_DISABLED',
  PaymentMethodBlocked = 'PAYMENT_METHOD_BLOCKED',
  RiskThreshold = 'RISK_THRESHOLD',
  ThreeDSecure = 'THREE_D_SECURE',
  TokenIssuance = 'TOKEN_ISSUANCE',
  TooManyConfirmationAttempts = 'TOO_MANY_CONFIRMATION_ATTEMPTS',
  UnionPayEnrollmentRequired = 'UNION_PAY_ENROLLMENT_REQUIRED'
}

/** Input to generate a list of exchange rate quotes. */
export type GenerateExchangeRateQuoteInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Base and quote currency combinations for which the quote will be generated. */
  quotes: Array<ExchangeRateQuoteInput>;
};

/** Coordinates describing a geographic position. */
export type GeoCoordinates = {
  __typename?: 'GeoCoordinates';
  /**
   * The angular distance of a place north or south of the earth's equator.
   * A positive value is north of the equator, a negative value is south of the equator.
   */
  latitude?: Maybe<Scalars['Float']>;
  /**
   * The angular distance of a place east or west of the meridian at Greenwich, England.
   * A positive value is east of the prime meridian, a negative value is west of the prime meridian.
   */
  longitude?: Maybe<Scalars['Float']>;
};

/** Coordinates describing a geographic position. */
export type GeoCoordinatesInput = {
  /**
   * The angular distance of a place north or south of the earth's equator.
   * A positive value is north of the equator, a negative value is south of the equator.
   */
  latitude: Scalars['Float'];
  /**
   * The angular distance of a place east or west of the meridian at Greenwich, England.
   * A positive value is east of the prime meridian, a negative value is west of the prime meridian.
   */
  longitude: Scalars['Float'];
};

/** Configuration for Google Pay on Android and the web. */
export type GooglePayConfiguration = {
  __typename?: 'GooglePayConfiguration';
  /** The country code of the acquiring bank where the transaction is likely to be processed. */
  countryCode?: Maybe<Scalars['CountryCodeAlpha2']>;
  /** A string used to identify the merchant to the customer. */
  displayName?: Maybe<Scalars['String']>;
  /** The environment being used for Google Pay. */
  environment?: Maybe<GooglePayEnvironment>;
  /**
   * Authorization to use when tokenizing a Google Pay payment method.
   * @deprecated This field is included for supporting legacy clients.
   */
  googleAuthorization?: Maybe<Scalars['String']>;
  /** A string used to identify the merchant's PayPal account when generating a PayPal Closed Loop Token. */
  paypalClientId?: Maybe<Scalars['String']>;
  /** A list of card brands supported by the merchant for Google Pay. */
  supportedCardBrands?: Maybe<Array<CreditCardBrandCode>>;
};

/** The environment being used for Google Pay. */
export enum GooglePayEnvironment {
  Production = 'PRODUCTION',
  Sandbox = 'SANDBOX'
}

/** Additional information about the payment method specific to Google Pay. */
export type GooglePayOriginDetails = {
  __typename?: 'GooglePayOriginDetails';
  /** The first 6 digits of the credit card, known as the Bank Identification Number. This BIN may differ from the BIN of the customer's actual card. */
  bin?: Maybe<Scalars['String']>;
  /** A reference ID for the Google transaction. */
  googleTransactionId?: Maybe<Scalars['String']>;
};

/** Details about a Hyperwallet account. */
export type HyperwalletAccountDetails = {
  __typename?: 'HyperwalletAccountDetails';
  /** The ID of the Hyperwallet account. */
  userId?: Maybe<Scalars['String']>;
};

/** Configuration for iDEAL. */
export type IDealConfiguration = {
  __typename?: 'IDealConfiguration';
  /** A URL used to redirect the customer to the bank's web page. */
  assetsUrl?: Maybe<Scalars['String']>;
  /** The route ID used to process an iDEAL payment. */
  routeId?: Maybe<Scalars['String']>;
};

/** Reference object for an in-store request. */
export type InStoreContext = InStoreContextResult & Node & {
  __typename?: 'InStoreContext';
  /**
   * A unique ID for this in-store request.
   * @deprecated Use the id field from the InStoreContextPayload
   */
  id: Scalars['ID'];
  /**
   * The reader associated with the in-store request.
   * @deprecated Use the reader field from the InStoreContextPayload
   */
  reader?: Maybe<InStoreReader>;
  /**
   * The refund representing the refund on the payment method.
   * @deprecated Use a Node query for a RequestRefundInStoreContext
   */
  refund?: Maybe<Refund>;
  /**
   * The status of the context created.
   * @deprecated Use the status field from the InStoreContextPayload
   */
  status: InStoreContextStatus;
  /**
   * The transaction representing the charge on the payment method.
   * @deprecated Use a Node query for a RequestTransactionInStoreContext
   */
  transaction?: Maybe<Transaction>;
};

/** Top-level fields returned when requesting a state change on an in-store reader. */
export type InStoreContextPayload = {
  __typename?: 'InStoreContextPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A unique ID for this in-store context request. */
  id: Scalars['ID'];
  /**
   * The in-store context created when an in-store flow is initiated.
   * @deprecated Use top-level fields
   */
  inStoreContext?: Maybe<InStoreContext>;
  /** The reader associated with the in-store request. */
  reader?: Maybe<InStoreReader>;
  /** The status of the context created. */
  status: InStoreContextStatus;
};

/** Reference object for an in-store request. */
export type InStoreContextResult = {
  /** A unique ID for this in-store request. */
  id: Scalars['ID'];
  /** The reader associated with the in-store request. */
  reader?: Maybe<InStoreReader>;
};

/** Potential statuses of a context created as part of an in-store request. */
export enum InStoreContextStatus {
  /** The context was successfully canceled. */
  Cancelled = 'CANCELLED',
  /** Successful. The context was ended. */
  Complete = 'COMPLETE',
  /** Not successful. The context was ended. */
  Failed = 'FAILED',
  /** Flow in-progress. Waiting for reader or point of sale interaction. */
  Pending = 'PENDING',
  /** Payment flow in-progress. Customer payment method submitted for transaction processing. */
  Processing = 'PROCESSING'
}

/** Input fields for an individual display item on an in-store reader. */
export type InStoreDisplayItemInput = {
  /** The total amount of a CHARGE or DISCOUNT item. */
  amount?: InputMaybe<Scalars['Amount']>;
  /** The display item text to be displayed on the in-store reader. 35 character maximum. */
  description?: InputMaybe<Scalars['String']>;
  /** The display item type to be displayed on the in-store reader. */
  kind: DisplayItemType;
  /** The number of units for a CHARGE or DISCOUNT item. Must be greater than 0. */
  quantity?: InputMaybe<Scalars['Float']>;
};

/** An in-store location. */
export type InStoreLocation = {
  __typename?: 'InStoreLocation';
  /** The address of the in-store location. */
  address?: Maybe<InStoreLocationAddress>;
  /** The coordinates of this location. */
  geoCoordinates?: Maybe<GeoCoordinates>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** A merchant-assigned internal name of this location, unique to this merchant. */
  internalName?: Maybe<Scalars['String']>;
  /** Name of the in-store location. */
  name?: Maybe<Scalars['String']>;
  /** The PayPal account ID to which this location was added. */
  payerId?: Maybe<Scalars['ID']>;
  /** Whether QR code payments will be enabled for this location. */
  qrCodePaymentsEnabled?: Maybe<Scalars['Boolean']>;
};

/** Input fields for an in-store location address. */
export type InStoreLocationAddress = {
  __typename?: 'InStoreLocationAddress';
  /** Country code for the address. */
  countryCode?: Maybe<Scalars['CountryCode']>;
  /** Extended address information, such as an apartment or suite number. */
  extendedAddress?: Maybe<Scalars['String']>;
  /** Locality/city. */
  locality?: Maybe<Scalars['String']>;
  /** Postal code in any country's format, otherwise known as CAP, CEP, Eircode, NPA, PIN, PLZ, or ZIP code. */
  postalCode?: Maybe<Scalars['String']>;
  /** State or province. */
  region?: Maybe<Scalars['String']>;
  /** The street address. */
  streetAddress?: Maybe<Scalars['String']>;
};

/** Input fields for an in-store Location Address. */
export type InStoreLocationAddressInput = {
  /** Country code for the address. */
  countryCode: Scalars['CountryCode'];
  /** Extended address information, such as an apartment or suite number. */
  extendedAddress?: InputMaybe<Scalars['String']>;
  /** Locality/city. */
  locality: Scalars['String'];
  /** Postal code in any country's format, otherwise known as CAP, CEP, Eircode, NPA, PIN, PLZ, or ZIP code. */
  postalCode: Scalars['String'];
  /** State or province. */
  region: Scalars['String'];
  /** The street address. */
  streetAddress: Scalars['String'];
};

/** Input fields for an in-store Location Address update. */
export type InStoreLocationAddressUpdateInput = {
  /** Country code for the address. */
  countryCode?: InputMaybe<Scalars['CountryCode']>;
  /** Extended address information, such as an apartment or suite number. */
  extendedAddress?: InputMaybe<Scalars['String']>;
  /** Locality/city. */
  locality?: InputMaybe<Scalars['String']>;
  /** Postal code in any country's format, otherwise known as CAP, CEP, Eircode, NPA, PIN, PLZ, or ZIP code. */
  postalCode?: InputMaybe<Scalars['String']>;
  /** State or province. */
  region?: InputMaybe<Scalars['String']>;
  /** The street address. */
  streetAddress?: InputMaybe<Scalars['String']>;
};

/** A paginated list of in-store locations. */
export type InStoreLocationConnection = {
  __typename?: 'InStoreLocationConnection';
  /** A list of in-store locations. */
  edges?: Maybe<Array<Maybe<InStoreLocationConnectionEdge>>>;
  /** Information about the page of in-store locations contained in `edges`. */
  pageInfo: PageInfo;
};

/** An in-store location within an InStoreLocationConnection. */
export type InStoreLocationConnectionEdge = {
  __typename?: 'InStoreLocationConnectionEdge';
  /** The in-store locations's location within the InStoreLocationConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The in-store location. */
  node?: Maybe<InStoreLocation>;
};

/** Fields required for an instore location. */
export type InStoreLocationInput = {
  /** The address of the in-store Location. */
  address: InStoreLocationAddressInput;
  /** Whether QR code payments will be enabled for this location. */
  enableQRCodePayments: Scalars['Boolean'];
  /** The coordinates of this location. */
  geoCoordinates: GeoCoordinatesInput;
  /** Name assigned by the merchant to uniquely identify this Location. */
  internalName: Scalars['String'];
  /** The publicly visible label of this Location. */
  name: Scalars['String'];
  /** The PayPal account ID to which this Location will be added. */
  payerId?: InputMaybe<Scalars['ID']>;
};

/** Fields required to update an in-store location. */
export type InStoreLocationUpdateInput = {
  /** The address of the location. */
  address?: InputMaybe<InStoreLocationAddressUpdateInput>;
  /** Whether QR code payments will be enabled for this location. */
  enableQRCodePayments?: InputMaybe<Scalars['Boolean']>;
  /** The coordinates of this location. */
  geoCoordinates?: InputMaybe<GeoCoordinatesInput>;
  /** Name assigned by the merchant to uniquely identify this location. */
  internalName?: InputMaybe<Scalars['String']>;
  /** The publicly visible label of this location. */
  name?: InputMaybe<Scalars['String']>;
  /** The PayPal account ID to which this location will be added. */
  payerId?: InputMaybe<Scalars['ID']>;
};

/** An in-store payment card reader. */
export type InStoreReader = {
  __typename?: 'InStoreReader';
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Date and time when the reader last established a connection. */
  lastSeenAt?: Maybe<Scalars['Timestamp']>;
  /** The in-store location the reader is attached to. */
  location?: Maybe<InStoreLocation>;
  /** Name given to the reader. */
  name?: Maybe<Scalars['String']>;
  /** Date and time when the reader last disconnected. */
  offlineSince?: Maybe<Scalars['Timestamp']>;
  /** Date and time when the reader was paired. */
  pairedAt?: Maybe<Scalars['Timestamp']>;
  /** The version of the payment application running on the Reader. */
  softwareVersion?: Maybe<Scalars['String']>;
  /** Current status of the reader. */
  status?: Maybe<ReaderStatus>;
  /** Vendor-specific information about the reader. */
  vendor?: Maybe<InStoreReaderVendor>;
};

/** The authorization mode used to perform the transaction. */
export enum InStoreReaderAuthorizationMode {
  Card = 'CARD',
  Issuer = 'ISSUER'
}

/** A paginated list of in-store readers. */
export type InStoreReaderConnection = {
  __typename?: 'InStoreReaderConnection';
  /** A list of in-store readers. */
  edges?: Maybe<Array<Maybe<InStoreReaderConnectionEdge>>>;
  /** Information about the page of in-store readers contained in `edges`. */
  pageInfo: PageInfo;
};

/** An in-store reader within an InStoreReaderConnection. */
export type InStoreReaderConnectionEdge = {
  __typename?: 'InStoreReaderConnectionEdge';
  /** The in-store reader's location within the InStoreReaderConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The in-store reader. */
  node?: Maybe<InStoreReader>;
};

/** Additional information about the payment method supplied by an in-store payment reader. */
export type InStoreReaderOriginDetails = {
  /** The authorization mode used to perform the transaction on the payment reader. */
  authorizationMode?: Maybe<InStoreReaderAuthorizationMode>;
  /** The input mode used on the payment reader to facilitate an in-store transaction. */
  inputMode?: Maybe<PaymentReaderInputMode>;
  /** An indicator for whether the transaction was verified via pin. */
  pinVerified?: Maybe<Scalars['Boolean']>;
  /** The ID of the terminal that was processed this transaction. */
  terminalId?: Maybe<Scalars['String']>;
};

/** Top-level fields returned for an in-store reader. */
export type InStoreReaderPayload = {
  __typename?: 'InStoreReaderPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The reader. */
  reader?: Maybe<InStoreReader>;
};

/** Input fields for searching for in-store readers. */
export type InStoreReaderSearchInput = {
  /** Find in-store readers with location ID or IDs. */
  locationId?: InputMaybe<SearchValueInput>;
  /** Find in-store readers with reader status. */
  readerStatus?: InputMaybe<ReaderStatus>;
  /** Find in-store readers with software version. */
  softwareVersion?: InputMaybe<SearchSoftwareVersionInput>;
};

/** Fields that are reader specific for pairing a reader. */
export type InStoreReaderSetupInput = {
  /** In-Store Location to attach Reader to. */
  locationId: Scalars['ID'];
  /** Name given to the Reader. */
  name?: InputMaybe<Scalars['String']>;
};

/** A union of all possible in-store reader vendors. */
export type InStoreReaderVendor = VerifoneVendor;

/** Input fields for creating an in-store transaction. */
export type InStoreRefundInput = {
  /** Refund amount of the request. This value must be greater than 0, and must match the currency format of the merchant account. This can only contain numbers and one decimal point (e.g. x.xx). Can't be greater than the maximum allowed by the processor. */
  amount: Scalars['Amount'];
  /** Collection of custom field/value pairs. You must [set up each custom field in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#creating-a-custom-field) prior to passing it with a request. */
  customFields?: InputMaybe<Array<CustomFieldInput>>;
  /** Fields used to define what will appear on a customer's bank statement for a specific purchase. */
  descriptor?: InputMaybe<TransactionDescriptorInput>;
  /** Merchant account ID used to process the refund. Currency is also determined by merchant account ID. If no merchant account ID is specified, we will use your default merchant account. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Additional information about the refund. On PayPal refunds, this field maps to the PayPal invoice number. PayPal invoice numbers must be unique in your PayPal business account. Maximum 255 characters or 127 for PayPal refunds. */
  orderId?: InputMaybe<Scalars['String']>;
};

/** Input fields for creating an in-store transaction. */
export type InStoreTransactionInput = {
  /** Billing amount of the request. This value must be greater than 0, and must match the currency format of the merchant account. This can only contain numbers and one decimal point (e.g. x.xx). Can't be greater than the maximum allowed by the processor. */
  amount: Scalars['Amount'];
  /** For partners and shopping carts only. If you are a shopping cart provider or other Braintree partner, pass a string identifier for your service. For PayPal transactions, this maps to paypal.bn_code. */
  channel?: InputMaybe<Scalars['String']>;
  /** Collection of custom field/value pairs. You must [set up each custom field in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#creating-a-custom-field) prior to passing it with a request. */
  customFields?: InputMaybe<Array<CustomFieldInput>>;
  /** If charging a single-use payment method, optional ID of a customer to associate the transaction with. If vaulting the single-use payment method, this customer will be associated with the resulting multi-use payment method. */
  customerId?: InputMaybe<Scalars['ID']>;
  /** Fields used to define what will appear on a customer's bank statement for a specific purchase. */
  descriptor?: InputMaybe<TransactionDescriptorInput>;
  /** The amount to be displayed on the Reader. This value must be greater than 0, and must match the currency format of the merchant account. This can only contain numbers and one decimal point (e.g. x.xx). If no display amount is specified, we will display the billing amount. */
  displayAmount?: InputMaybe<Scalars['Amount']>;
  /** Merchant account ID used to process the transaction. Currency is also determined by merchant account ID. If no merchant account ID is specified, we will use your default merchant account. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Additional information about the transaction. On PayPal transactions, this field maps to the PayPal invoice number. PayPal invoice numbers must be unique in your PayPal business account. Maximum 255 characters or 127 for PayPal transactions. */
  orderId?: InputMaybe<Scalars['String']>;
  /** When a single-use payment method is used to create this transaction, it can be automatically stored in the vault after transacting. If this field is left blank, the single-use payment method will not be vaulted. */
  vaultPaymentMethodAfterTransacting?: InputMaybe<VaultInStorePaymentMethodAfterTransactingInput>;
};

/** Configuration for Kount fraud tools. */
export type KountConfiguration = {
  __typename?: 'KountConfiguration';
  /** The Kount merchant ID used to identify the fraud data collection request. */
  merchantId?: Maybe<Scalars['String']>;
};

/** The type of object the legacy ID represents when converting it to a global ID. */
export enum LegacyIdType {
  Customer = 'CUSTOMER',
  Dispute = 'DISPUTE',
  MerchantAccountApplication = 'MERCHANT_ACCOUNT_APPLICATION',
  PaymentContext = 'PAYMENT_CONTEXT',
  PaymentMethod = 'PAYMENT_METHOD',
  Refund = 'REFUND',
  Transaction = 'TRANSACTION',
  UsBankAccountVerification = 'US_BANK_ACCOUNT_VERIFICATION',
  Verification = 'VERIFICATION'
}

/** A scenario detailing which party assumes liability for certain conditions in the event of a transaction being disputed. */
export type LiabilityShift = {
  __typename?: 'LiabilityShift';
  /** The specific conditions under which the responsible party assumes liability, in the event of a chargeback. */
  conditions?: Maybe<Array<LiabilityShiftCondition>>;
  /** The party taking responsibility for liability. */
  responsibleParty?: Maybe<LiabilityShiftResponsibleParty>;
};

/** If enrolled in Effortless Chargeback Protection, and in the event the transaction is disputed, these are the specific conditions under which the responsible party assumes liability for that chargeback. */
export enum LiabilityShiftCondition {
  ItemNotReceived = 'ITEM_NOT_RECEIVED',
  Unauthorized = 'UNAUTHORIZED'
}

/** If enrolled in Effortless Chargeback Protection, and in the event the transaction is disputed, these are the possible parties which can assume liability. */
export enum LiabilityShiftResponsibleParty {
  Issuer = 'ISSUER',
  Paypal = 'PAYPAL'
}

/** Input fields for local payment addresses. */
export type LocalPaymentAddressInput = {
  /** Country code for the address. */
  countryCode?: InputMaybe<Scalars['CountryCode']>;
  /** Extended address information, such as an apartment or suite number. */
  extendedAddress?: InputMaybe<Scalars['String']>;
  /** Locality/city. */
  locality?: InputMaybe<Scalars['String']>;
  /** Postal code in any country's format, otherwise known as CAP, CEP, Eircode, NPA, PIN, PLZ, or ZIP code. */
  postalCode?: InputMaybe<Scalars['String']>;
  /** State or province. */
  region?: InputMaybe<Scalars['String']>;
  /** The street address. */
  streetAddress?: InputMaybe<Scalars['String']>;
};

/** The LocalPayment object. */
export type LocalPaymentContext = Node & PaymentContext & {
  __typename?: 'LocalPaymentContext';
  /** The amount charged in this local payment. */
  amount?: Maybe<MonetaryAmount>;
  /** The URL to which a customer should be redirected to approve the local payment. */
  approvalUrl?: Maybe<Scalars['String']>;
  /** Date and time when the local payment context was approved by the customer. */
  approvedAt?: Maybe<Scalars['Timestamp']>;
  /** Date and time when the local payment context was created. */
  createdAt: Scalars['Timestamp'];
  /** Date and time when the local payment context was expired. */
  expiredAt?: Maybe<Scalars['Timestamp']>;
  /** Unique identifier for the payment context. */
  id: Scalars['ID'];
  /** Legacy unique identifier. */
  legacyId: Scalars['ID'];
  /** The merchant account used to create the payment context. */
  merchantAccountId?: Maybe<Scalars['String']>;
  /** The PayPal Invoice ID. */
  orderId?: Maybe<Scalars['String']>;
  /** Unique identifier for the local payment. */
  paymentId: Scalars['String'];
  /** Date and time when the local payment context was used to create a transaction. */
  transactedAt?: Maybe<Scalars['Timestamp']>;
  /** The type of the local payment. */
  type?: Maybe<LocalPaymentMethodType>;
  /** Date and time when the local payment context was updated. */
  updatedAt: Scalars['Timestamp'];
};

/** Local payment specific details on a transaction. */
export type LocalPaymentDetails = {
  __typename?: 'LocalPaymentDetails';
  /** Description of the payment method that can be displayed to customers. */
  displayName?: Maybe<Scalars['String']>;
  /** Additional information about the local payment method provided from a third-party origin, such as PayPal or another regional payment method provider. */
  origin?: Maybe<PaymentMethodOrigin>;
  /** Regional payment method selected by the customer. */
  type?: Maybe<LocalPaymentMethodType>;
};

/** A value identifying the type of regional payment method. */
export enum LocalPaymentMethodType {
  Alipay = 'ALIPAY',
  Bancontact = 'BANCONTACT',
  Blik = 'BLIK',
  Boletobancario = 'BOLETOBANCARIO',
  Eps = 'EPS',
  Giropay = 'GIROPAY',
  Grabpay = 'GRABPAY',
  Ideal = 'IDEAL',
  Multibanco = 'MULTIBANCO',
  Mybank = 'MYBANK',
  Oxxo = 'OXXO',
  P24 = 'P24',
  Payu = 'PAYU',
  PayUponInvoice = 'PAY_UPON_INVOICE',
  Satispay = 'SATISPAY',
  Sepa = 'SEPA',
  Sofort = 'SOFORT',
  Swish = 'SWISH',
  Trustly = 'TRUSTLY',
  Verkkopankki = 'VERKKOPANKKI',
  Vipps = 'VIPPS',
  WechatPay = 'WECHAT_PAY'
}

/** Input fields for the payer of a local payment. */
export type LocalPaymentPayerInfoInput = {
  /** The payer's billing address. */
  billingAddress?: InputMaybe<LocalPaymentAddressInput>;
  /** The payer's email. */
  email?: InputMaybe<Scalars['EmailAddress']>;
  /** The payer's given (first) name. */
  givenName: Scalars['String'];
  /** The payer's phone number. */
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** The payer's shipping address. */
  shippingAddress?: InputMaybe<LocalPaymentAddressInput>;
  /** The payer's surname (last name). */
  surname: Scalars['String'];
  /** The payer's tax information. This is only required for Boleto Bancrio payments. */
  taxInfo?: InputMaybe<TaxInfoInput>;
};

/** Means by which customers by their bills. */
export enum MvvAcceptanceChannel {
  FaceToFace = 'FACE_TO_FACE',
  Mail = 'MAIL',
  Phone = 'PHONE',
  Web = 'WEB'
}

/** Supported MVV (Merchant Verification Value) programs. */
export enum MvvRegistrationType {
  LoanVpp = 'LOAN_VPP',
  TaxDebit = 'TAX_DEBIT',
  UtilRate = 'UTIL_RATE',
  UtilVpp = 'UTIL_VPP'
}

/** Supported MVV (Merchant Verification Value) utility types. */
export enum MvvUtilityType {
  Electric = 'ELECTRIC',
  Gas = 'GAS',
  Trash = 'TRASH',
  Water = 'WATER'
}

/** Mandate type for SEPA Direct Debit Account. */
export enum MandateType {
  OneOff = 'ONE_OFF',
  Recurrent = 'RECURRENT'
}

/** Configuration for Masterpass. */
export type MasterpassConfiguration = {
  __typename?: 'MasterpassConfiguration';
  /** The Masterpass merchant checkout ID used to identify the merchant in Masterpass requests. */
  merchantCheckoutId?: Maybe<Scalars['String']>;
  /** A list of card brands supported by the merchant for Masterpass. */
  supportedCardBrands?: Maybe<Array<CreditCardBrandCode>>;
};

/** Additional information about the payment method specific to Masterpass. */
export type MasterpassOriginDetails = {
  __typename?: 'MasterpassOriginDetails';
  /** The first 6 digits of the credit card, known as the Bank Identification Number. This BIN may differ from the BIN of the customer's actual card. */
  bin?: Maybe<Scalars['String']>;
};

/** Details about a merchant and its current settings. */
export type Merchant = {
  __typename?: 'Merchant';
  /** Company name. */
  companyName?: Maybe<Scalars['String']>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** A paginated list of merchant accounts that belong to this merchant. Filtered by search criteria, if provided. */
  merchantAccounts?: Maybe<MerchantAccountConnection>;
  /** Current status. */
  status?: Maybe<Scalars['String']>;
  /** The timezone that the merchant operates in. */
  timezone?: Maybe<Scalars['String']>;
  /** The merchant's main website. */
  website?: Maybe<Scalars['String']>;
};


/** Details about a merchant and its current settings. */
export type MerchantMerchantAccountsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  input?: InputMaybe<MerchantAccountSearchInput>;
};

/** Information about a merchant account associated with a merchant. */
export type MerchantAccount = {
  __typename?: 'MerchantAccount';
  /** The disbursement bank account linked with the merchant account. */
  bankAccount?: Maybe<DisbursementBankAccount>;
  /** The ISO code for the currency the merchant account uses. */
  currencyCode?: Maybe<Scalars['CurrencyCodeAlpha']>;
  /** Business name of the account. */
  dbaName?: Maybe<Scalars['String']>;
  /** A unique identifier for this account in external systems. */
  externalId?: Maybe<Scalars['String']>;
  /** The Hyperwallet account linked with the merchant account. */
  hyperwalletAccount?: Maybe<HyperwalletAccountDetails>;
  /** Unique identifier for the merchant account. Used to determine what merchant account processed or will process a given Payment. */
  id: Scalars['ID'];
  /** Whether this merchant account is the default for this merchant. The default merchant account is used to process all Payments where a merchant account ID is not specified. */
  isDefault?: Maybe<Scalars['Boolean']>;
  /** The PayPal account linked with the merchant account. */
  paypalAccount?: Maybe<PayPalAccountDetails>;
  /** The status of a merchant account. This determines whether the merchant account can be used to create a Payment. */
  status?: Maybe<MerchantAccountStatus>;
  /** The 3D Secure configuration for the merchant account. */
  threeDSecure?: Maybe<MerchantAccountThreeDSecureConfiguration>;
  /** The Venmo account linked with the merchant account. */
  venmoAccount?: Maybe<VenmoAccountDetails>;
};

/** A record of a merchant account application. */
export type MerchantAccountApplication = {
  __typename?: 'MerchantAccountApplication';
  /** A unique ID for the account application. Can be used to query the status of the onboarding request in the future. */
  id: Scalars['ID'];
  /** Legacy unique ID. */
  legacyId: Scalars['ID'];
  /** The status of the application. */
  status?: Maybe<ApplicationStatus>;
};

/** A paginated list of merchant accounts. */
export type MerchantAccountConnection = {
  __typename?: 'MerchantAccountConnection';
  /** A list of merchant accounts. */
  edges?: Maybe<Array<Maybe<MerchantAccountConnectionEdge>>>;
  /** Information about the page of merchant accounts contained in `edges`. */
  pageInfo: PageInfo;
};

/** A merchant account within a MerchantAccountConnection. */
export type MerchantAccountConnectionEdge = {
  __typename?: 'MerchantAccountConnectionEdge';
  /** This merchant account's location within the MerchantAccountConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The merchant account. */
  node?: Maybe<MerchantAccount>;
};

/** Input fields for searching for merchant accounts. */
export type MerchantAccountSearchInput = {
  /** Find merchant accounts with an id or ids. */
  id?: InputMaybe<SearchValueInput>;
  /** Find merchant accounts associated with a given PayPal account ID. */
  paypalAccountId?: InputMaybe<SearchValueInput>;
};

/** The status of a merchant account. This determines whether the merchant account can be used to create a Payment, and whether funds can continue to flow to the associated bank account. */
export enum MerchantAccountStatus {
  /** The merchant account can be used to create transactions and refunds. */
  Active = 'ACTIVE',
  /** The merchant account is still being set up, and cannot be used to create transactions or refunds yet. */
  Pending = 'PENDING',
  /** The merchant account cannot be used to process transactions or refunds. */
  Suspended = 'SUSPENDED'
}

/** Details about the 3D Secure configuration of the merchant account. */
export type MerchantAccountThreeDSecureConfiguration = {
  __typename?: 'MerchantAccountThreeDSecureConfiguration';
  /** Configuration for 3D Secure v1. */
  v1?: Maybe<MerchantAccountThreeDSecureVersionConfiguration>;
  /** Configuration for 3D Secure v2. */
  v2?: Maybe<MerchantAccountThreeDSecureVersionConfiguration>;
};

/** Details about the configuration of a version of 3D Secure for the merchant account. */
export type MerchantAccountThreeDSecureVersionConfiguration = {
  __typename?: 'MerchantAccountThreeDSecureVersionConfiguration';
  /** Card types enabled for this 3D Secure version. */
  supportedCardBrands?: Maybe<Array<CreditCardBrandCode>>;
};

/** A monetary amount with currency. */
export type MonetaryAmount = {
  __typename?: 'MonetaryAmount';
  /** The currency code for the monetary amount. */
  currencyCode?: Maybe<Scalars['CurrencyCodeAlpha']>;
  /**
   * The ISO code for the money's currency.
   * @deprecated Use `currencyCode` instead.
   */
  currencyIsoCode?: Maybe<Scalars['CurrencyCodeAlpha']>;
  /** The amount of money, either a whole number or a number with up to 3 decimal places. */
  value?: Maybe<Scalars['Amount']>;
};

/** Input fields representing an amount with currency. */
export type MonetaryAmountInput = {
  /** The currency code for the monetary amount. */
  currencyCode: Scalars['CurrencyCodeAlpha'];
  /** The amount of money, either a whole number or a number with up to 3 decimal places. */
  value: Scalars['Amount'];
};

/** Input fields for searching for a transaction or refund amount. */
export type MonetaryAmountSearchInput = {
  /** Find transactions with a given currency. */
  currencyCode?: InputMaybe<SearchTextInput>;
  /**
   * Deprecated: Please use `currencyCode` instead.
   *
   * Find transactions with a given currency.
   */
  currencyIsoCode?: InputMaybe<SearchTextInput>;
  /** Find transactions for a given amount. */
  value?: InputMaybe<SearchRangeInput>;
};

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Accepts a dispute and returns a payload that includes the dispute that was accepted. Only disputes with a status of OPEN can be accepted. */
  acceptDispute?: Maybe<AcceptDisputePayload>;
  /** Authorize a credit card of any origin and return a payload that includes details of the resulting transaction. */
  authorizeCreditCard?: Maybe<TransactionPayload>;
  /** Authorize an eligible PayPal account and return a payload that includes details of the resulting transaction. */
  authorizePayPalAccount?: Maybe<PayPalTransactionPayload>;
  /** Authorize an eligible payment method and return a payload that includes details of the resulting transaction. */
  authorizePaymentMethod?: Maybe<TransactionPayload>;
  /** Authorize an eligible Venmo account and return a payload that includes details of the resulting transaction. */
  authorizeVenmoAccount?: Maybe<TransactionPayload>;
  /** Capture an authorized transaction and return a payload that includes details of the transaction. */
  captureTransaction?: Maybe<TransactionPayload>;
  /** Charge a credit card of any origin and return a payload that includes details of the resulting transaction. */
  chargeCreditCard?: Maybe<TransactionPayload>;
  /** Charge a PayPal account and return a payload that includes details of the resulting transaction. */
  chargePayPalAccount?: Maybe<PayPalTransactionPayload>;
  /** Charge any payment method and return a payload that includes details of the resulting transaction. */
  chargePaymentMethod?: Maybe<TransactionPayload>;
  /** Charge a US bank account and return a payload that includes details of the resulting transaction. See https://developers.braintreepayments.com/guides/ach/configuration for information on eligibility and setup. */
  chargeUsBankAccount?: Maybe<TransactionPayload>;
  /** Charge a Venmo account and return a payload that includes details of the resulting transaction. See https://articles.braintreepayments.com/guides/payment-methods/venmo for information on eligibility and setup. */
  chargeVenmoAccount?: Maybe<TransactionPayload>;
  /** Confirm micro-transfer amounts initiated by vaultUsBankAccount or verifyUsBankAccount, completing the verification process for a US Bank Account via micro-transfer. */
  confirmMicroTransferAmounts?: Maybe<ConfirmMicroTransferAmountsPayload>;
  /** Create a client token that can be used to initialize a client in order to tokenize payment information. */
  createClientToken?: Maybe<CreateClientTokenPayload>;
  /** Create a customer for storing individual customer information and/or grouping transactions and multi-use payment methods. */
  createCustomer?: Maybe<CreateCustomerPayload>;
  /** Uploads an evidence file and associates it with a dispute. **Note:**: file upload requires a special request format. See the ['Uploading Files' integration guide](https://graphql.braintreepayments.com/integration_guides/uploading_files) for instructions on how to perform this mutation. */
  createDisputeFileEvidence?: Maybe<CreateDisputeFileEvidencePayload>;
  /** Creates text evidence to a dispute and returns a payload that includes the evidence that was created. Only disputes with a status of OPEN can have text evidence created for them. */
  createDisputeTextEvidence?: Maybe<CreateDisputeTextEvidencePayload>;
  /** Creates a new In-Store Location to associate Readers. */
  createInStoreLocation?: Maybe<CreateInStoreLocationPayload>;
  /** Creates a non-instant local payment context. Your account must be enabled to use this feature. */
  createNonInstantLocalPaymentContext?: Maybe<CreateNonInstantLocalPaymentContextPayload>;
  /** Set up a PayPal Billing Agreement Token for approval by a PayPal user. */
  createPayPalBillingAgreement?: Maybe<CreatePayPalBillingAgreementPayload>;
  /** Set up a PayPal One-Time Payment for approval by a PayPal user. See [documentation](https://developer.paypal.com/braintree/docs/guides/paypal/checkout-with-paypal) for more information. Your account must be enabled for this feature. */
  createPayPalOneTimePayment?: Maybe<CreatePayPalOneTimePaymentPayload>;
  /** Create a PayPal access token that can be used to make additional API calls or initialize a client. */
  createUniversalAccessToken?: Maybe<CreateUniversalAccessTokenPayload>;
  /** Delete a customer, breaking association between any of the customer's transactions. Will not delete if the customer has existing payment methods. */
  deleteCustomer?: Maybe<DeleteCustomerPayload>;
  /** Deletes evidence from a dispute. */
  deleteDisputeEvidence?: Maybe<DeleteDisputeEvidencePayload>;
  /**
   * Delete a payment method referenced by a single-use token.
   * @deprecated Use `deletePaymentMethodFromVault` instead.
   */
  deletePaymentMethodFromSingleUseToken?: Maybe<DeletePaymentMethodFromSingleUseTokenPayload>;
  /** Delete a multi-use payment method from the vault. */
  deletePaymentMethodFromVault?: Maybe<DeletePaymentMethodFromVaultPayload>;
  /** Finalizes a dispute and returns a payload that includes the dispute that was finalized. Only disputes with a status of OPEN can be finalized. */
  finalizeDispute?: Maybe<FinalizeDisputePayload>;
  /** Generate a customized currency exchange rate quote for items on a merchant's page. This allows merchants to advertise products in their customer's currency. Your account must be enabled to use this feature. */
  generateExchangeRateQuote?: Maybe<ExchangeRateQuotePayload>;
  /** Pairs a Reader to an account and In-Store Location. */
  pairInStoreReader?: Maybe<InStoreReaderPayload>;
  /** Partially capture funds from a transaction that was successfully authorized and return a payload that includes a new transaction with information about the capture. This is available for [Venmo](https://developers.braintreepayments.com/guides/venmo/submit-for-partial-settlement) and [PayPal](https://articles.braintreepayments.com/guides/payment-methods/paypal/processing#multiple-partial-settlements) transactions. */
  partialCaptureTransaction?: Maybe<PartialCaptureTransactionPayload>;
  /** Attempt to perform 3D Secure Authentication on credit card payment method. This may consume the payment method and return a new single-use payment method. */
  performThreeDSecureLookup?: Maybe<PerformThreeDSecureLookupPayload>;
  /**
   * Create a detached refund (unassociated with any previous Braintree payment) to a credit card and return a payload that includes details of the refund.
   *
   * We have previously referred to this as issuing a "detached credit," and it is disallowed by default. See the [documentation](https://articles.braintreepayments.com/control-panel/transactions/refunds-voids-credits#detached-credits) for more information regarding eligibility and configuration.
   */
  refundCreditCard?: Maybe<RefundCreditCardPayload>;
  /** Refund a settled transaction and return a payload that includes details of the refund. */
  refundTransaction?: Maybe<RefundTransactionPayload>;
  /**
   * Create a detached refund (unassociated with any previous Braintree payment) to a  US Bank Account and return a payload that includes details of the refund.
   *
   * We have previously referred to this as issuing a "detached credit," and it is disallowed by default. See the [documentation](https://articles.braintreepayments.com/control-panel/transactions/refunds-voids-credits#detached-credits) for more information regarding eligibility and configuration.
   */
  refundUsBankAccount?: Maybe<RefundUsBankAccountPayload>;
  /** Request an in-store reader to cancel the charge flow. */
  requestCancelFromInStoreReader?: Maybe<InStoreContextPayload>;
  /** Request an in-store reader to begin the charge flow. */
  requestChargeFromInStoreReader?: Maybe<InStoreContextPayload>;
  /** Request an in-store reader to display a confirmation prompt. */
  requestConfirmationPromptFromInStoreReader?: Maybe<InStoreContextPayload>;
  /** Request an in-store reader to update to the latest version of software. */
  requestFirmwareUpdateFromInStoreReader?: Maybe<InStoreContextPayload>;
  /** Request an in-store reader to display line items. */
  requestItemDisplayFromInStoreReader?: Maybe<InStoreContextPayload>;
  /** Request an in-store reader to start an unreferenced refund flow. */
  requestRefundFromInStoreReader?: Maybe<InStoreContextPayload>;
  /** Request an in-store reader to display a signature prompt. */
  requestSignaturePromptFromInStoreReader?: Maybe<InStoreContextPayload>;
  /** Request an in-store reader to display text. */
  requestTextDisplayFromInStoreReader?: Maybe<InStoreContextPayload>;
  /** Request an in-store reader to vault a payment method. */
  requestVaultFromInStoreReader?: Maybe<InStoreContextPayload>;
  /** Reverse a refund and return a payload that includes voided refund. */
  reverseRefund?: Maybe<RefundTransactionPayload>;
  /** Reverse a transaction and return a payload that includes either the voided transaction or a refund. */
  reverseTransaction?: Maybe<ReverseTransactionPayload>;
  /** Force a transaction to settle in the sandbox environment. Generates an error elsewhere. */
  sandboxSettleTransaction?: Maybe<TransactionPayload>;
  /** Tokenize credit card fields and return a payload that includes a single-use payment method. */
  tokenizeCreditCard?: Maybe<TokenizeCreditCardPayload>;
  /** Tokenize Custom Actions fields and return a payload that includes a single-use payment method. */
  tokenizeCustomActionsPaymentMethod?: Maybe<TokenizeCustomActionsPaymentMethodPayload>;
  /** Tokenize a credit card's CVV and return a payload that includes a single-use payment method. */
  tokenizeCvv?: Maybe<TokenizeCvvPayload>;
  /** Tokenize a network tokenized payment instrument and return a payload that includes a single-use payment method. */
  tokenizeNetworkToken?: Maybe<TokenizeNetworkTokenPayload>;
  /** Tokenize PayPal account and return a payload that includes a single-use payment method. */
  tokenizePayPalBillingAgreement?: Maybe<TokenizePayPalBillingAgreementPayload>;
  /** Tokenize PayPal One-Time Payment and return a payload that includes a single-use payment method. */
  tokenizePayPalOneTimePayment?: Maybe<TokenizePayPalOneTimePaymentPayload>;
  /** Tokenize Samsung Pay card fields and return a payload that includes a single-use payment method. */
  tokenizeSamsungPayCard?: Maybe<TokenizeSamsungPayCardPayload>;
  /** Tokenize US bank account fields and return a payload that includes a single-use payment method. */
  tokenizeUsBankAccount?: Maybe<TokenizeUsBankAccountPayload>;
  /** Tokenize US bank login fields and return a payload that includes a single-use payment method. */
  tokenizeUsBankLogin?: Maybe<TokenizeUsBankAccountPayload>;
  /** Set a new billing address for a multi-use credit card payment method. By default, this mutation will also verify the card with the new billing address before updating. */
  updateCreditCardBillingAddress?: Maybe<UpdateCreditCardBillingAddressPayload>;
  /** Update a customer's information. */
  updateCustomer?: Maybe<UpdateCustomerPayload>;
  /** Updates an In-Store Location. */
  updateInStoreLocation?: Maybe<UpdateInStoreLocationPayload>;
  /** Updates an In-Store Reader. */
  updateInStoreReader?: Maybe<InStoreReaderPayload>;
  /** Updates the authorization amount of the transaction. */
  updateTransactionAmount?: Maybe<TransactionPayload>;
  /** Update custom fields on a transaction. Custom fields are [defined in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#store-and-pass-back-fields). */
  updateTransactionCustomFields?: Maybe<UpdateTransactionCustomFieldsPayload>;
  /** Vault payment information from a single-use credit card and return a payload that includes a new multi-use payment method. By default, this mutation will also verify the card before vaulting. */
  vaultCreditCard?: Maybe<VaultPaymentMethodPayload>;
  /** Vault an existing PayPal Billing Agreement that was not created through Braintree. Only use this mutation if you need to import PayPal Billing Agreements from an existing PayPal integration into your Braintree account. */
  vaultPayPalBillingAgreement?: Maybe<VaultPayPalBillingAgreementPayload>;
  /** Vault payment information from a single-use payment method and return a payload that includes a new multi-use payment method. When vaulting a credit card, by default, this mutation will also verify that card before vaulting. */
  vaultPaymentMethod?: Maybe<VaultPaymentMethodPayload>;
  /** Vault payment information from a single-use US bank account payment method and return a payload that includes a new multi-use payment method. */
  vaultUsBankAccount?: Maybe<VaultPaymentMethodPayload>;
  /** Run a verification on a multi-use credit card payment method. */
  verifyCreditCard?: Maybe<VerifyPaymentMethodPayload>;
  /** Run a verification on a multi-use payment method. */
  verifyPaymentMethod?: Maybe<VerifyPaymentMethodPayload>;
  /** Run a verification on a multi-use US bank account payment method. */
  verifyUsBankAccount?: Maybe<VerifyPaymentMethodPayload>;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationAcceptDisputeArgs = {
  input: AcceptDisputeInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationAuthorizeCreditCardArgs = {
  input: AuthorizeCreditCardInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationAuthorizePayPalAccountArgs = {
  input: AuthorizePayPalAccountInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationAuthorizePaymentMethodArgs = {
  input: AuthorizePaymentMethodInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationAuthorizeVenmoAccountArgs = {
  input: AuthorizeVenmoAccountInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationCaptureTransactionArgs = {
  input: CaptureTransactionInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationChargeCreditCardArgs = {
  input: ChargeCreditCardInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationChargePayPalAccountArgs = {
  input: ChargePayPalAccountInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationChargePaymentMethodArgs = {
  input: ChargePaymentMethodInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationChargeUsBankAccountArgs = {
  input: ChargeUsBankAccountInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationChargeVenmoAccountArgs = {
  input: ChargeVenmoAccountInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationConfirmMicroTransferAmountsArgs = {
  input: ConfirmMicroTransferAmountsInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationCreateClientTokenArgs = {
  input?: InputMaybe<CreateClientTokenInput>;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationCreateCustomerArgs = {
  input?: InputMaybe<CreateCustomerInput>;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationCreateDisputeFileEvidenceArgs = {
  input: CreateDisputeFileEvidenceInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationCreateDisputeTextEvidenceArgs = {
  input: CreateDisputeTextEvidenceInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationCreateInStoreLocationArgs = {
  input: CreateInStoreLocationInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationCreateNonInstantLocalPaymentContextArgs = {
  input: CreateNonInstantLocalPaymentContextInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationCreatePayPalBillingAgreementArgs = {
  input: CreatePayPalBillingAgreementInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationCreatePayPalOneTimePaymentArgs = {
  input: CreatePayPalOneTimePaymentInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationCreateUniversalAccessTokenArgs = {
  input: CreateUniversalAccessTokenInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationDeleteCustomerArgs = {
  input: DeleteCustomerInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationDeleteDisputeEvidenceArgs = {
  input: DeleteDisputeEvidenceInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationDeletePaymentMethodFromSingleUseTokenArgs = {
  input: DeletePaymentMethodFromSingleUseTokenInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationDeletePaymentMethodFromVaultArgs = {
  input: DeletePaymentMethodFromVaultInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationFinalizeDisputeArgs = {
  input: FinalizeDisputeInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationGenerateExchangeRateQuoteArgs = {
  input: GenerateExchangeRateQuoteInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPairInStoreReaderArgs = {
  input: PairInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPartialCaptureTransactionArgs = {
  input: PartialCaptureTransactionInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPerformThreeDSecureLookupArgs = {
  input: PerformThreeDSecureLookupInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRefundCreditCardArgs = {
  input: RefundCreditCardInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRefundTransactionArgs = {
  input: RefundTransactionInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRefundUsBankAccountArgs = {
  input: RefundUsBankAccountInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRequestCancelFromInStoreReaderArgs = {
  input: RequestCancelFromInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRequestChargeFromInStoreReaderArgs = {
  input: RequestChargeFromInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRequestConfirmationPromptFromInStoreReaderArgs = {
  input: RequestConfirmationPromptFromInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRequestFirmwareUpdateFromInStoreReaderArgs = {
  input: RequestFirmwareUpdateFromInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRequestItemDisplayFromInStoreReaderArgs = {
  input: RequestItemDisplayFromInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRequestRefundFromInStoreReaderArgs = {
  input: RequestRefundFromInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRequestSignaturePromptFromInStoreReaderArgs = {
  input: RequestSignaturePromptFromInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRequestTextDisplayFromInStoreReaderArgs = {
  input: RequestTextDisplayFromInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRequestVaultFromInStoreReaderArgs = {
  input: RequestVaultFromInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationReverseRefundArgs = {
  input: ReverseRefundInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationReverseTransactionArgs = {
  input: ReverseTransactionInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationSandboxSettleTransactionArgs = {
  input: SandboxSettleTransactionInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTokenizeCreditCardArgs = {
  input: TokenizeCreditCardInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTokenizeCustomActionsPaymentMethodArgs = {
  input: TokenizeCustomActionsPaymentMethodInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTokenizeCvvArgs = {
  input: TokenizeCvvInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTokenizeNetworkTokenArgs = {
  input: TokenizeNetworkTokenInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTokenizePayPalBillingAgreementArgs = {
  input: TokenizePayPalBillingAgreementInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTokenizePayPalOneTimePaymentArgs = {
  input: TokenizePayPalOneTimePaymentInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTokenizeSamsungPayCardArgs = {
  input: TokenizeSamsungPayCardInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTokenizeUsBankAccountArgs = {
  input: TokenizeUsBankAccountInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTokenizeUsBankLoginArgs = {
  input: TokenizeUsBankLoginInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationUpdateCreditCardBillingAddressArgs = {
  input: UpdateCreditCardBillingAddressInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationUpdateCustomerArgs = {
  input: UpdateCustomerInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationUpdateInStoreLocationArgs = {
  input: UpdateInStoreLocationInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationUpdateInStoreReaderArgs = {
  input: UpdateInStoreReaderInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationUpdateTransactionAmountArgs = {
  input: UpdateTransactionAmountInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationUpdateTransactionCustomFieldsArgs = {
  input: UpdateTransactionCustomFieldsInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationVaultCreditCardArgs = {
  input: VaultCreditCardInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationVaultPayPalBillingAgreementArgs = {
  input: VaultPayPalBillingAgreementInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationVaultPaymentMethodArgs = {
  input: VaultPaymentMethodInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationVaultUsBankAccountArgs = {
  input: VaultUsBankAccountInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationVerifyCreditCardArgs = {
  input: VerifyCreditCardInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationVerifyPaymentMethodArgs = {
  input: VerifyPaymentMethodInput;
};


/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationVerifyUsBankAccountArgs = {
  input: VerifyUsBankAccountInput;
};

/** The name of the party. */
export type NameInput = {
  /**
   * The party's alternate name. Can be a business name, nickname, or any other
   * name that cannot be split into first, last name. Required for a business party name.
   */
  alternateFullName?: InputMaybe<Scalars['String']>;
  /** The party's given, or first, name. Required if the party is a person. */
  givenName: Scalars['String'];
  /** The party's middle name. Use also to store multiple middle names including the patronymic, or father's, middle name. */
  middleName?: InputMaybe<Scalars['String']>;
  /** The prefix, or title, to the party name. */
  prefix?: InputMaybe<Scalars['String']>;
  /** The suffix for the party's name. */
  suffix?: InputMaybe<Scalars['String']>;
  /**
   * The party's surname or family name. Also known as the last name. Required if
   * the party is a person. Use also to store multiple surnames including the
   * matronymic, or mother's, surname.
   */
  surname: Scalars['String'];
};

/** Input fields for a network tokenized card. */
export type NetworkTokenInput = {
  /** A one-time-use string generated by the token requester to validate the transaction. */
  cryptogram: Scalars['String'];
  /** A two-digit string that should be passed along in the authorization message. */
  eCommerceIndicator?: InputMaybe<Scalars['ECommerceIndicator']>;
  /** A two-digit string representing the expiration month of the DPAN. */
  expirationMonth: Scalars['Month'];
  /** A four-digit string representing the expiration year of the DPAN. */
  expirationYear: Scalars['Year'];
  /** The card number used in processing. This is a device PAN (DPAN), not the backing card number (FPAN). */
  number: Scalars['CreditCardNumber'];
  /** Additional information about a network token. */
  originDetails: NetworkTokenOriginDetailsInput;
};

/** The source of the network token. */
export enum NetworkTokenOrigin {
  ApplePay = 'APPLE_PAY',
  GooglePay = 'GOOGLE_PAY',
  NetworkToken = 'NETWORK_TOKEN'
}

/** Additional information about the payment method specific to Network Token. */
export type NetworkTokenOriginDetails = {
  __typename?: 'NetworkTokenOriginDetails';
  /** The first 6 digits of the credit card, known as the Bank Identification Number. This BIN may differ from the BIN of the customer's actual card. */
  bin?: Maybe<Scalars['String']>;
};

/** Information about the network token, such as the origin of the network token, source card details, and other token requestor data. */
export type NetworkTokenOriginDetailsInput = {
  /** The origin of the network token. */
  origin: NetworkTokenOrigin;
  /** A string, suitable for display, that describes the backing card. */
  sourceCardDescription?: InputMaybe<Scalars['String']>;
  /** The last 4 digits of the backing card number (FPAN). */
  sourceCardLast4?: InputMaybe<Scalars['CreditCardLast4']>;
  /** The card type of the backing card. */
  sourceCardType?: InputMaybe<CreditCardBrandCode>;
  /** The token requestor ID of the entity that generated this network token. */
  tokenRequestorId?: InputMaybe<Scalars['String']>;
  /** The transaction ID for this network token. */
  transactionId?: InputMaybe<Scalars['String']>;
};

/** Relay compatible Node interface. */
export type Node = {
  /** Global ID for a given object. */
  id: Scalars['ID'];
};

/** Input fields for non-instant local payment context. */
export type NonInstantLocalPaymentContextInput = {
  /** The amount of the local payment. */
  amount: MonetaryAmountInput;
  /** The URL where the customer is redirected after the customer cancels the payment. */
  cancelUrl: Scalars['String'];
  /** The country code of the local payment. For local payments supported in multiple countries, this value may determine which banks are presented to the customer. */
  countryCode?: InputMaybe<Scalars['CountryCode']>;
  /** Overrides the default date at which the local payment context will expire. MULTIBANCO is not overridable. */
  expiryDate?: InputMaybe<Scalars['Date']>;
  /** The language tag for the language in which to localize the error-related strings. */
  locale?: InputMaybe<Scalars['Language']>;
  /** ID of the PayPal merchant account that will be used when charging this payment method. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** The order id of the eventual Braintree transaction and the invoice number of the local payment context. Maximum 127 characters. */
  orderId?: InputMaybe<Scalars['String']>;
  /** The payer's information. */
  payerInfo: LocalPaymentPayerInfoInput;
  /** The URL where the customer is redirected after the customer approves the payment. */
  returnUrl: Scalars['String'];
  /** The type of the non-instant local payment. */
  type: NonInstantLocalPaymentMethodType;
};

/** A value identifying the type of non-instant regional payment method. */
export enum NonInstantLocalPaymentMethodType {
  Boletobancario = 'BOLETOBANCARIO',
  Multibanco = 'MULTIBANCO',
  Oxxo = 'OXXO'
}

/** Information about an OAuth Application. */
export type OAuthApplication = {
  __typename?: 'OAuthApplication';
  /** The unique identifier of the OAuth application. */
  clientId?: Maybe<Scalars['String']>;
  /** The name of the OAuth application. */
  name?: Maybe<Scalars['String']>;
};

/** OAuth access token type. */
export enum OAuthTokenType {
  Bearer = 'BEARER'
}

/** The owner's address type. */
export enum OwnerAddressType {
  Home = 'HOME',
  Mailing = 'MAILING'
}

/** The type of identity number provided for the owner. */
export enum OwnerIdType {
  SocialSecurityNumber = 'SOCIAL_SECURITY_NUMBER'
}

/** The owner's phone type. */
export enum OwnerPhoneType {
  Home = 'HOME',
  Mobile = 'MOBILE'
}

/** The position that the owner holds in the business. */
export enum OwnerPosition {
  BeneficialOwner = 'BENEFICIAL_OWNER',
  Chairman = 'CHAIRMAN',
  Director = 'DIRECTOR',
  Partner = 'PARTNER',
  Secretary = 'SECRETARY',
  Treasurer = 'TREASURER'
}

/** The role that the owner holds in the business. */
export enum OwnerRole {
  BeneficialOwner = 'BENEFICIAL_OWNER',
  SignificantResponsibility = 'SIGNIFICANT_RESPONSIBILITY'
}

/** The page information for a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** The cursor for the last item in the connection page. */
  endCursor?: Maybe<Scalars['String']>;
  /** Whether or not there is a next page available. */
  hasNextPage: Scalars['Boolean'];
  /** Always false; backwards pagination is not supported. Present to comply with Relay specifications. */
  hasPreviousPage: Scalars['Boolean'];
  /** The cursor for the first item in the connection page. */
  startCursor?: Maybe<Scalars['String']>;
};

/** Input fields for pairing an in store reader. */
export type PairInStoreReaderInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Inputs for Reader. */
  reader: InStoreReaderSetupInput;
  /** Code displayed on Reader during pairing. */
  userCode: Scalars['String'];
};

/** An original authorization's relationship to all its partial capture transactions. */
export type ParentAuthorization = {
  __typename?: 'ParentAuthorization';
  /** The captures on a partially captured authorization. */
  childCaptures?: Maybe<Array<Transaction>>;
  /** The total amount authorized by this transaction. This amount will not change as this transaction is partially captured. */
  totalAmountAuthorized?: Maybe<MonetaryAmount>;
};

/** A union of all possible relationships of transactions involved in partial captures. If the transaction has been partially captured, this links to all its partial capture children; if the transaction represents a partial capture attempt, this links to the original parent authorization. */
export type PartialCaptureDetails = ChildCapture | ParentAuthorization;

/** Top-level input fields for capturing outstanding funds authorized by a transaction. */
export type PartialCaptureTransactionInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for the capture, with details that will define the resulting capture transaction. */
  transaction?: InputMaybe<PartialCaptureTransactionOptionsInput>;
  /** ID of the original authorized transaction to be partially captured. */
  transactionId: Scalars['ID'];
};

/** Input fields for the capture, with details that will define the resulting capture transaction. */
export type PartialCaptureTransactionOptionsInput = {
  /** The amount to capture on the transaction against the parent authorization transaction. Must be greater than 0. You can perform multiple partial capture transactions as long as the cumulative amount of those transactions is less than or equal to the amount authorized by the parent transaction. You can't capture more than the authorized amount unless your industry and processor support settlement adjustment (capturing a certain percentage over the authorized amount); [contact us for assistance](https://help.braintreepayments.com?issue=TransactionProcessingQuestion). */
  amount: Scalars['Amount'];
  /** Fields used to define what will appear on a customer's bank statement for a specific purchase. If specified, this will update the existing descriptor on the transaction. */
  descriptor?: InputMaybe<TransactionDescriptorInput>;
  /**
   * Discount amount that was included in the total transaction amount. Does not add to the total amount the payment method will be charged. This value can't be negative. Please note that this field is not on PayPal transactions.
   *
   * *Required for Level 3 processing*.
   */
  discountAmount?: InputMaybe<Scalars['String']>;
  /**
   * Line items for this transaction. Up to 249 line items may be specified.
   *
   * *Required for Level 3 processing*.
   */
  lineItems?: InputMaybe<Array<TransactionLineItemInput>>;
  /** Additional information about the transaction. On PayPal transactions, this field maps to the PayPal invoice number. PayPal invoice numbers must be unique in your PayPal business account. Maximum 255 characters or 127 for PayPal transactions. If specified, this will update the existing order ID on the transaction. */
  orderId?: InputMaybe<Scalars['String']>;
  /**
   * A purchase order identification value you associate with this transaction.
   *
   * *Required for Level 2 processing*.
   */
  purchaseOrderNumber?: InputMaybe<Scalars['String']>;
  /**
   * Shipping information.
   *
   * *Required for Level 3 processing*.
   */
  shipping?: InputMaybe<TransactionShippingInput>;
  /**
   * Tax information about the transaction.
   *
   * *Required for Level 2 processing*.
   */
  tax?: InputMaybe<TransactionTaxInput>;
};

/** Top-level output field from partially capturing a transaction. */
export type PartialCaptureTransactionPayload = {
  __typename?: 'PartialCaptureTransactionPayload';
  /** The transaction representing the partial capture. */
  capture?: Maybe<Transaction>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Details about a PayPal account. */
export type PayPalAccountDetails = {
  __typename?: 'PayPalAccountDetails';
  /** The billing address associated with the PayPal account. */
  billingAddress?: Maybe<Address>;
  /** The ID of the billing agreement for this PayPal account. */
  billingAgreementId?: Maybe<Scalars['String']>;
  /** The label of the co-branded card used as a funding source. */
  cobrandedCardLabel?: Maybe<Scalars['String']>;
  /** The email address associated with the PayPal account. */
  email?: Maybe<Scalars['String']>;
  /** The first name on the PayPal account. */
  firstName?: Maybe<Scalars['String']>;
  /** The last name on the PayPal account. */
  lastName?: Maybe<Scalars['String']>;
  /** Limited use PayPal provided Order ID (starts with O-). */
  limitedUseOrderId?: Maybe<Scalars['String']>;
  /** Additional information if the PayPal account was provided from a third-party origin, such as Apple Pay, Google Pay, or another digital wallet. */
  origin?: Maybe<PaymentMethodOrigin>;
  /** The PayPal ID of the PayPal account. */
  payerId?: Maybe<Scalars['String']>;
  /** The primary phone number associated with the PayPal account. */
  phone?: Maybe<Scalars['String']>;
  /** The shipping address associated with the PayPal account. */
  shippingAddress?: Maybe<Address>;
};

/** Input for identifying a PayPal account. */
export type PayPalAccountInput = {
  /** The unique PayPal ID of the PayPal account. */
  payerId?: InputMaybe<Scalars['ID']>;
};

/** Expected business/pricing model for a billing agreement (Charge Patterns). */
export enum PayPalBillingAgreementChargePattern {
  /** Pay after use, non-recurring post-paid, variable amount, irregular. */
  Deferred = 'DEFERRED',
  /** On-demand instant payments - non-recurring, pre-paid, variable amount. */
  Immediate = 'IMMEDIATE',
  /** Pay on a fixed date based on usage or consumption after the goods/service is delivered. */
  RecurringPostpaid = 'RECURRING_POSTPAID',
  /** Pay upfront fixed or variable amount on a fixed date before the goods/service is delivered. */
  RecurringPrepaid = 'RECURRING_PREPAID',
  /** Charge payer when the set amount is reached or monthly billing cycle, whichever comes first, after the goods/service is delivered. */
  ThresholdPostpaid = 'THRESHOLD_POSTPAID',
  /** Charge payer when the set amount is reached or monthly billing cycle, whichever comes first, before the goods/service is delivered. */
  ThresholdPrepaid = 'THRESHOLD_PREPAID'
}

/** Controls the experience in a PayPal billing agreement approval flow. */
export type PayPalBillingAgreementExperienceProfileInput = {
  /** Merchant brand name to be displayed on the PayPal approval pages. */
  brandName?: InputMaybe<Scalars['String']>;
  /** Indicates whether a shipping address will be collected from the customer during the agreement approval flow. */
  collectShippingAddress?: InputMaybe<Scalars['Boolean']>;
  /** Specifies the PayPal page to display when a user lands on the PayPal site to complete the payment. */
  landingPageType?: InputMaybe<PayPalLandingPageType>;
  /** Locale of the PayPal payment approval experience. */
  locale?: InputMaybe<Scalars['Language']>;
  /** Indicates whether to enable user editing of the shipping address. Only applies when shipping address is provided by merchant. */
  shippingAddressEditable?: InputMaybe<Scalars['Boolean']>;
};

/** Input fields for a PayPal account to be vaulted. */
export type PayPalBillingAgreementInput = {
  /** The Billing Agreement token. */
  billingAgreementToken: Scalars['ID'];
};

/** Configuration for PayPal. */
export type PayPalConfiguration = {
  __typename?: 'PayPalConfiguration';
  /** A URL pointing to the base path of Braintree's web pages used for various browser switches and popups. */
  assetsUrl?: Maybe<Scalars['String']>;
  /** Whether billing agreements are enabled and should be used instead of future payments. */
  billingAgreementsEnabled?: Maybe<Scalars['Boolean']>;
  /** Braintree's PayPal client ID. */
  braintreeClientId?: Maybe<Scalars['String']>;
  /** The merchant's PayPal client ID. */
  clientId?: Maybe<Scalars['String']>;
  /** The currency code to use. */
  currencyCode?: Maybe<Scalars['CurrencyCodeAlpha']>;
  /**
   * For internal use only.
   * @deprecated This field is only included for internal testing purposes.
   */
  directBaseUrl?: Maybe<Scalars['String']>;
  /** The merchant's company name for displaying to customers in the PayPal UI. */
  displayName?: Maybe<Scalars['String']>;
  /** The PayPal environment. */
  environment?: Maybe<PayPalEnvironment>;
  /**
   * For internal use only.
   * @deprecated This field is only included for internal testing purposes.
   */
  environmentNoNetwork?: Maybe<Scalars['Boolean']>;
  /** The merchant account being used. This affects the currency code and other options. */
  merchantAccountId?: Maybe<Scalars['String']>;
  /** The email address of the PayPal account that will receive the funds when a transaction is created. */
  payeeEmail?: Maybe<Scalars['String']>;
  /** The merchant's privacy policy URL. */
  privacyUrl?: Maybe<Scalars['String']>;
  /** Whether or not the merchant has been vetted. */
  unvettedMerchant?: Maybe<Scalars['Boolean']>;
  /** The merchant's user agreement URL. */
  userAgreementUrl?: Maybe<Scalars['String']>;
};

/** The environment being used for PayPal. */
export enum PayPalEnvironment {
  Custom = 'CUSTOM',
  Live = 'LIVE',
  Offline = 'OFFLINE'
}

/** Controls the experience in a PayPal approval flow. */
export type PayPalExperienceProfileInput = {
  /** Merchant brand name to be displayed on the PayPal approval pages. */
  brandName?: InputMaybe<Scalars['String']>;
  /** Indicates whether a shipping address will be collected from the customer during the agreement approval flow. */
  collectShippingAddress?: InputMaybe<Scalars['Boolean']>;
  /** Specifies the PayPal page to display when a user lands on the PayPal site to complete the payment. */
  landingPageType?: InputMaybe<PayPalLandingPageType>;
  /** Locale of the PayPal payment approval experience. */
  locale?: InputMaybe<Scalars['Language']>;
  /** Indicates whether to enable user editing of the shipping address. Only applies when shipping address is provided by merchant. */
  shippingAddressEditable?: InputMaybe<Scalars['Boolean']>;
  /** Presents the customer with either the Continue or Pay Now (COMMIT) checkout flow. Default is Continue flow if the field is not provided. */
  userAction?: InputMaybe<PayPalUserAction>;
};

/** Possible identifiers for credit products provided via PayPal. */
export enum PayPalFinancingCreditProductIdentifier {
  /** Brazil Credit Card Installments. */
  CreditCardInstallmentsBr = 'CREDIT_CARD_INSTALLMENTS_BR',
  /** Mexico Credit Card Installments. */
  CreditCardInstallmentsMx = 'CREDIT_CARD_INSTALLMENTS_MX',
  /** United States Credit Card. */
  CreditCardUs = 'CREDIT_CARD_US',
  /** Germany PayPal Credit. */
  PaypalCreditDe = 'PAYPAL_CREDIT_DE',
  /** United Kingdom PayPal Credit. */
  PaypalCreditUk = 'PAYPAL_CREDIT_UK',
  /** United States PayPal Credit. */
  PaypalCreditUs = 'PAYPAL_CREDIT_US',
  /** France Pay Later. */
  PayLaterFr = 'PAY_LATER_FR',
  /** Great Britain Pay Later. */
  PayLaterGb = 'PAY_LATER_GB',
  /** United States Pay Later. */
  PayLaterUs = 'PAY_LATER_US',
  /** Germany Pay Upon Invoice. */
  PayUponInvoiceDe = 'PAY_UPON_INVOICE_DE'
}

/** PayPal financing options available for a transaction. */
export type PayPalFinancingOption = {
  __typename?: 'PayPalFinancingOption';
  /** The credit product identifier. */
  creditProductIdentifier?: Maybe<PayPalFinancingCreditProductIdentifier>;
  /** Financing options the transaction qualifies for. */
  qualifyingFinancingOptions?: Maybe<Array<PayPalQualifyingFinancingOption>>;
};

/** PayPal Financing option credit type. */
export enum PayPalFinancingOptionCreditType {
  Installment = 'INSTALLMENT',
  NoInterest = 'NO_INTEREST',
  PayUponInvoice = 'PAY_UPON_INVOICE',
  SameAsCash = 'SAME_AS_CASH'
}

/** Input fields for requesting information about PayPal financing options. */
export type PayPalFinancingOptionsInput = {
  /** The transaction currency and total amount to finance. */
  amount: MonetaryAmountInput;
  /** The financing country code. */
  countryCode: Scalars['CountryCodeAlpha2'];
  /** ID of an existing multi-use PayPal payment method to request financing options for. */
  paymentMethodId: Scalars['ID'];
};

/** PayPal financing options response payload. */
export type PayPalFinancingOptionsPayload = {
  __typename?: 'PayPalFinancingOptionsPayload';
  /** PayPal financing options. */
  financingOptions?: Maybe<Array<PayPalFinancingOption>>;
};

/** The intent for PayPal payments. */
export enum PayPalIntent {
  /** Merchant will authorize the payment, but the funds will be captured separately. */
  Authorize = 'AUTHORIZE',
  /** Merchant will create a PayPal Order. This validates the transaction without an authorization (i.e. without holding funds). Useful for authorizing and capturing funds up to 90 days after the order has been placed. */
  Order = 'ORDER',
  /** Merchant will authorize and captures funds simultaneously. */
  Sale = 'SALE'
}

/** The type of landing page to display on the PayPal site for user checkout. */
export enum PayPalLandingPageType {
  Billing = 'BILLING',
  Default = 'DEFAULT',
  Login = 'LOGIN'
}

/** Line items for a PayPal payment. */
export type PayPalLineItemInput = {
  /** Item description. Maximum 127 characters. */
  description?: InputMaybe<Scalars['String']>;
  /** Item name. Maximum 127 characters. */
  name: Scalars['String'];
  /** Product or UPC code for the item. Maximum 127 characters. */
  productCode?: InputMaybe<Scalars['String']>;
  /** Number of units of the item purchased. This value can't be negative or zero. */
  quantity: Scalars['Int'];
  /** Indicates whether the line item is a debit (sale) or credit (refund or discount) to the customer. */
  type: TransactionLineItemType;
  /** Per-unit price of the item. Can include up to 2 decimal places. This value can't be negative or zero. */
  unitAmount: Scalars['Amount'];
  /** Per-unit tax price of the item. Can include up to 2 decimal places. This value can't be negative or zero. */
  unitTaxAmount: Scalars['Amount'];
  /** The URL to product information. */
  url?: InputMaybe<Scalars['URL']>;
};

/** Additional information about the local payment method specific to PayPal. */
export type PayPalLocalPaymentOriginDetails = {
  __typename?: 'PayPalLocalPaymentOriginDetails';
  /** If funds for the transaction have settled, the PayPal ID for the capture of funds. */
  captureId?: Maybe<Scalars['String']>;
  /** A string of field/value pairs passed directly to PayPal. */
  customField?: Maybe<Scalars['String']>;
  /** The identification value of the payment within PayPal's API. */
  paymentId?: Maybe<Scalars['String']>;
  /** The fee charged by PayPal for the transaction. */
  transactionFee?: Maybe<MonetaryAmount>;
};

/** PayPal local payment specific refund details. */
export type PayPalLocalPaymentRefundDetails = {
  __typename?: 'PayPalLocalPaymentRefundDetails';
  /** The PayPal refund ID. */
  refundId?: Maybe<Scalars['String']>;
  /** Refunded transaction fee charged by PayPal. */
  refundedFee?: Maybe<MonetaryAmount>;
};

/** Input fields for a PayPal account for a One-Time payment. */
export type PayPalOneTimePaymentInput = {
  /** The PayPal payer ID. */
  payerId: Scalars['ID'];
  /** The PayPal payment ID. This ID is prefixed with "PAYID-". */
  paymentId: Scalars['ID'];
  /** The PayPal payment token, also known as an Express Checkout token. This token is prefixed with "EC-". */
  paymentToken: Scalars['ID'];
};

/** Input fields for a PayPal account receiving transaction funds. */
export type PayPalPayeeOptionsInput = {
  /** The email address associated with the payee PayPal account. */
  email?: InputMaybe<Scalars['String']>;
};

/** Product attributes input for PayPal billing agreement. */
export type PayPalProductAttributesInput = {
  /** Expected business/pricing model for a billing agreement (Charge Patterns). */
  paypalBillingAgreementChargePattern?: InputMaybe<PayPalBillingAgreementChargePattern>;
};

/** PayPal qualifying financing options for a product. */
export type PayPalQualifyingFinancingOption = {
  __typename?: 'PayPalQualifyingFinancingOption';
  /** APR percentage. */
  apr?: Maybe<Scalars['Percentage']>;
  /** The country or region for the financing option. */
  countryCode?: Maybe<Scalars['CountryCodeAlpha2']>;
  /** Credit type. */
  creditType?: Maybe<PayPalFinancingOptionCreditType>;
  /** The discount amount on the transaction for this financing option. */
  discountAmount?: Maybe<MonetaryAmount>;
  /** The discount percentage for this financing option. */
  discountPercentage?: Maybe<Scalars['Percentage']>;
  /** The duration between each interval or payment. */
  intervalDuration?: Maybe<Scalars['Duration']>;
  /** The minimum qualifying amount for a transaction. */
  minimumAmount?: Maybe<MonetaryAmount>;
  /** The monthly interest rate for this financing option. */
  monthlyInterestRate?: Maybe<Scalars['Percentage']>;
  /** The amount for transaction monthly payments. */
  monthlyPayment?: Maybe<MonetaryAmount>;
  /** Nominal rate percentage. */
  nominalRate?: Maybe<Scalars['Percentage']>;
  /** Indicates whether the financing option's credit fee is funded by PayPal. */
  paypalSubsidized?: Maybe<Scalars['Boolean']>;
  /** The amount for transaction periodic payments. */
  periodicPayment?: Maybe<MonetaryAmount>;
  /** Total number of payments over which to finance the transaction. */
  term?: Maybe<Scalars['Int']>;
  /** The total amount for the transaction, including interest. */
  totalCost?: Maybe<MonetaryAmount>;
  /** The total interest cost for this financing option. */
  totalInterest?: Maybe<MonetaryAmount>;
};

/** PayPal-specific refund details. */
export type PayPalRefundDetails = {
  __typename?: 'PayPalRefundDetails';
  /** The description of this refund. */
  description?: Maybe<Scalars['String']>;
  /** The reason this refund was created. */
  reason?: Maybe<Scalars['String']>;
  /** The PayPal refund ID. */
  refundId?: Maybe<Scalars['String']>;
  /** Refunded transaction fee charged by PayPal. */
  refundedFee?: Maybe<MonetaryAmount>;
};

/** The app used to scan an in-store QR code. */
export enum PayPalRetailAppUsedForScanning {
  Paypal = 'PAYPAL',
  Venmo = 'VENMO'
}

/** A shipping option for a PayPal One-Time payment. */
export type PayPalShippingOptionInput = {
  /** The cost for this shipping option. */
  amount: MonetaryAmountInput;
  /** The shipping option description. Localize this description to the payer's locale. For example, `Free Shipping`, `USPS Priority Shipping`, `Expdition prioritaire USPS`, or `USPS yuxin f hu`. */
  description: Scalars['String'];
  /** A unique ID that identifies a shipping option. */
  id: Scalars['ID'];
  /** Indicates which shipping option is selected by default when the payer views the shipping options within the PayPal checkout experience. Only one shipping option can be selected at a time. */
  selected: Scalars['Boolean'];
  /** The method by which the payer wants to receive their items. */
  type: PayPalShippingOptionType;
};

/** The method by which the payer wants to receive their items. */
export enum PayPalShippingOptionType {
  Pickup = 'PICKUP',
  Shipping = 'SHIPPING'
}

/** PayPal-specific details on a transaction. */
export type PayPalTransactionDetails = {
  __typename?: 'PayPalTransactionDetails';
  /** The application used by the payer to scan the QR code. */
  appUsedForScanning?: Maybe<PayPalRetailAppUsedForScanning>;
  /** If the transaction was successfully authorized, the PayPal ID for the authorization. */
  authorizationId?: Maybe<Scalars['String']>;
  /** If funds for the transaction have settled, the PayPal ID for the capture of funds. */
  captureId?: Maybe<Scalars['String']>;
  /** A string of field/value pairs passed directly to PayPal. */
  customField?: Maybe<Scalars['String']>;
  /** Description of the transaction that is displayed to customers in PayPal email receipts. */
  description?: Maybe<Scalars['String']>;
  /** Additional information if the credit card was provided from a third-party origin, such as Google Pay. */
  origin?: Maybe<PaymentMethodOrigin>;
  /** Details about the PayPal account that received the funds. */
  payee?: Maybe<PayPalAccountDetails>;
  /** Details about the payer or owner of the PayPal account. */
  payer?: Maybe<PayPalAccountDetails>;
  /** Whether or not the PayPal account has been verified by PayPal. */
  payerStatus?: Maybe<Scalars['String']>;
  /** The identification value of the payment within PayPal's API. */
  paymentId?: Maybe<Scalars['String']>;
  /**
   * If the transaction is a refund, the PayPal refund ID.
   * @deprecated This field will never be populated as it only appears on refunds. Use `details.paypalId` on a refund instead.
   */
  refundId?: Maybe<Scalars['String']>;
  /** Buyer selected financing option at the time of creating a transaction. */
  selectedFinancingOption?: Maybe<SelectedPayPalFinancingOptionDetails>;
  /** Whether or not the transaction qualifies for PayPal Seller Protection. */
  sellerProtectionStatus?: Maybe<Scalars['String']>;
  /** Payer's tax ID. Only returned for payments from Brazilian accounts. */
  taxId?: Maybe<Scalars['String']>;
  /** Payer's tax ID type. Only returned for payments from Brazilian accounts. Allowed values BR_CPF or BR_CNPJ. */
  taxIdType?: Maybe<Scalars['String']>;
  /** The fee charged by PayPal for the transaction. */
  transactionFee?: Maybe<MonetaryAmount>;
  /**
   * The fee charged by PayPal for the transaction.
   * @deprecated Use `transactionFee.value` instead.
   */
  transactionFeeAmount?: Maybe<Scalars['String']>;
  /**
   * The currency code for the currency of the PayPal transaction fee.
   * @deprecated Use `transactionFee.currencyCode` instead.
   */
  transactionFeeCurrencyIsoCode?: Maybe<Scalars['String']>;
};

/** Top-level output field from creating a PayPal transaction. */
export type PayPalTransactionPayload = {
  __typename?: 'PayPalTransactionPayload';
  /** If the paymentMethodId passed to this mutation was a single-use PayPal payment method created with the [Billing Agreement with Purchase flow](https://developers.braintreepayments.com/guides/paypal/checkout-with-paypal/javascript/v3#checkout-using-paypal-billing-agreement-with-purchase-flow), then this field will be populated with a multi-use PayPal payment method created alongside the transaction. Otherwise, this will be null. */
  billingAgreementWithPurchasePaymentMethod?: Maybe<PaymentMethod>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The transaction representing the charge on the payment method. */
  transaction?: Maybe<Transaction>;
};

/** PayPal User action type. */
export enum PayPalUserAction {
  Commit = 'COMMIT',
  Continue = 'CONTINUE'
}

/** A merchant-initiated movement of money between the merchant and a customer, by way of a payment method. Payments can represent money moving either from a customer to the merchant by charging a payment method (a Transaction), or from the merchant back to a customer by refunding a previous transaction (a Refund). */
export type Payment = {
  /** The amount charged or credited to the payment method. Note that in the case of a Transaction, this amount will represent the amount moving from the customer to the merchant, and in the case of a Refund, will represent the amount moving from the merchant back to the customer. */
  amount?: Maybe<MonetaryAmount>;
  /** Date and time when the payment was created. */
  createdAt?: Maybe<Scalars['Timestamp']>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Legacy unique identifier. */
  legacyId: Scalars['ID'];
  /** The ID of the merchant account that processed this payment. */
  merchantAccountId?: Maybe<Scalars['ID']>;
  /** The order ID. */
  orderId?: Maybe<Scalars['String']>;
  /** Snapshot of payment method details used to create the payment, preserved at the time the transaction was created. This will always be present. */
  paymentMethodSnapshot?: Maybe<PaymentMethodSnapshot>;
  /** How the payment was created. */
  source?: Maybe<PaymentSource>;
  /** The current status of this payment. */
  status?: Maybe<PaymentStatus>;
  /** The records of all statuses this payment has passed through, with additional information on why each status occurred. Returned in reverse chronological order, with the most recent event first in the list. */
  statusHistory?: Maybe<Array<PaymentStatusEvent>>;
};

/** A paginated list of transactions and refunds. */
export type PaymentConnection = {
  __typename?: 'PaymentConnection';
  /** A list of transactions and refunds. */
  edges?: Maybe<Array<Maybe<PaymentConnectionEdge>>>;
  /** Information about the page of transactions and refunds contained in `edges`. */
  pageInfo: PageInfo;
};

/** A transaction or refund within a PaymentConnection. */
export type PaymentConnectionEdge = {
  __typename?: 'PaymentConnectionEdge';
  /** This transaction or refund's location within the PaymentConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The transaction or refund. */
  node?: Maybe<Payment>;
};

/** Context associated with a transaction. */
export type PaymentContext = {
  /** Date and time when the payment context was created. */
  createdAt: Scalars['Timestamp'];
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Date and time when the payment context was updated. */
  updatedAt: Scalars['Timestamp'];
};

/** The initiator of the payment. Payment can either be merchant-initiated or customer-initiated. */
export enum PaymentInitiator {
  /** Transactions that are initiated by the customer via the merchant by mail or telephone. */
  Moto = 'MOTO',
  /** Transactions that are initiated by the merchant for subsequent recurring payments (e.g. subscriptions with a fixed amount on a predefined schedule). */
  Recurring = 'RECURRING',
  /** Transactions initiated by the customer that represent the first in a series of recurring payments or subscription. */
  RecurringFirst = 'RECURRING_FIRST',
  /** Transactions that are initiated by the merchant for unscheduled payments that are not recurring on a predefined schedule or amount (e.g. balance top-up). */
  Unscheduled = 'UNSCHEDULED'
}

/** The [payment-level fee report (formerly known as the transaction-level fee report)](https://articles.braintreepayments.com/control-panel/reporting/transaction-level-fee-report) provides a breakdown of fees per individual payments (encompassing transactions and refunds). */
export type PaymentLevelFeeReport = {
  __typename?: 'PaymentLevelFeeReport';
  /** The URL where the generated report is stored. Download the report from this URL. */
  url?: Maybe<Scalars['String']>;
};

/** Top-level field representing a payment method. */
export type PaymentMethod = Node & {
  __typename?: 'PaymentMethod';
  /** Date and time when the payment method was vaulted. */
  createdAt?: Maybe<Scalars['Timestamp']>;
  /** The customer that the payment method belongs to. */
  customer?: Maybe<Customer>;
  /** Details about the payment method specific to the type (e.g. credit card, PayPal account). */
  details?: Maybe<PaymentMethodDetails>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Legacy unique identifier. May be the same as ID for single-use payment methods. */
  legacyId: Scalars['ID'];
  /** Whether a payment method may be used only once or multiple times. */
  usage?: Maybe<PaymentMethodUsage>;
  /** A paginated list of verifications that have been run against the payment method. */
  verifications?: Maybe<VerificationConnection>;
};


/** Top-level field representing a payment method. */
export type PaymentMethodVerificationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
};

/** A paginated list of payment methods. */
export type PaymentMethodConnection = {
  __typename?: 'PaymentMethodConnection';
  /** A list of payment methods. */
  edges?: Maybe<Array<Maybe<PaymentMethodConnectionEdge>>>;
  /** Information about the page of payment methods contained in `edges`. */
  pageInfo: PageInfo;
};

/** A payment method within a PaymentMethodConnection. */
export type PaymentMethodConnectionEdge = {
  __typename?: 'PaymentMethodConnectionEdge';
  /** This payment method's location within the PaymentMethodConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The payment method. */
  node?: Maybe<PaymentMethod>;
};

/** Initiator of a payment method delete request. */
export enum PaymentMethodDeletionInitiator {
  Customer = 'CUSTOMER',
  Merchant = 'MERCHANT'
}

/** A union of all possible payment method details. PaymentMethodDetails contain information for display purposes, payment method management, and processing. */
export type PaymentMethodDetails = CreditCardDetails | CustomActionsPaymentMethodDetails | PayPalAccountDetails | SepaDirectDebitAccountDetails | SamsungPayCardDetails | UsBankAccountDetails | VenmoAccountDetails;

/** Information about how the customer provided a payment method, such as via a digital wallet. */
export type PaymentMethodOrigin = {
  __typename?: 'PaymentMethodOrigin';
  /** When available, additional details specific to the origin. */
  details?: Maybe<PaymentMethodOriginDetails>;
  /** An enum identifying the origin of the payment method. */
  type?: Maybe<PaymentMethodOriginType>;
};

/** A union of all possible payment method origin details. PaymentMethodOriginDetails contain additional information specific to the third party the payment method was provided by. */
export type PaymentMethodOriginDetails = ApplePayOriginDetails | CardPresentOriginDetails | EmvCardOriginDetails | GooglePayOriginDetails | MasterpassOriginDetails | NetworkTokenOriginDetails | PayPalLocalPaymentOriginDetails | SamsungPayOriginDetails | VisaCheckoutOriginDetails;

/** A value identifying the third-party origin from which a customer provided their payment method. */
export enum PaymentMethodOriginType {
  ApplePay = 'APPLE_PAY',
  GooglePay = 'GOOGLE_PAY',
  InStoreReader = 'IN_STORE_READER',
  Masterpass = 'MASTERPASS',
  NetworkToken = 'NETWORK_TOKEN',
  Paypal = 'PAYPAL',
  SamsungPay = 'SAMSUNG_PAY',
  VisaCheckout = 'VISA_CHECKOUT'
}

/** A union of all possible payment method details as they were used in a transaction or verification. PaymentMethodSnapshot preserves values used to create a given transaction or verify a payment method at that moment in time. */
export type PaymentMethodSnapshot = CreditCardDetails | CreditCardTransactionDetails | CustomActionsPaymentMethodDetails | LocalPaymentDetails | PayPalTransactionDetails | SepaDirectDebitTransactionDetails | UsBankAccountDetails | VenmoAccountDetails;

/** A value identifying the type of payment method used for a transaction. For certain payment methods such as credit cards, this value also encodes the origin from which a customer provided that payment method. */
export enum PaymentMethodSnapshotSearchType {
  AlipayViaPaypal = 'ALIPAY_VIA_PAYPAL',
  BancontactViaPaypal = 'BANCONTACT_VIA_PAYPAL',
  BlikViaPaypal = 'BLIK_VIA_PAYPAL',
  BoletobancarioViaPaypal = 'BOLETOBANCARIO_VIA_PAYPAL',
  CreditCard = 'CREDIT_CARD',
  CreditCardViaApplePay = 'CREDIT_CARD_VIA_APPLE_PAY',
  CreditCardViaGooglePay = 'CREDIT_CARD_VIA_GOOGLE_PAY',
  CreditCardViaMasterpass = 'CREDIT_CARD_VIA_MASTERPASS',
  CreditCardViaNetworkToken = 'CREDIT_CARD_VIA_NETWORK_TOKEN',
  CreditCardViaSamsungPay = 'CREDIT_CARD_VIA_SAMSUNG_PAY',
  CreditCardViaVisaCheckout = 'CREDIT_CARD_VIA_VISA_CHECKOUT',
  EpsViaPaypal = 'EPS_VIA_PAYPAL',
  GiropayViaPaypal = 'GIROPAY_VIA_PAYPAL',
  GrabpayViaPaypal = 'GRABPAY_VIA_PAYPAL',
  IdealViaPaypal = 'IDEAL_VIA_PAYPAL',
  LocalPayment = 'LOCAL_PAYMENT',
  MultibancoViaPaypal = 'MULTIBANCO_VIA_PAYPAL',
  MybankViaPaypal = 'MYBANK_VIA_PAYPAL',
  OxxoViaPaypal = 'OXXO_VIA_PAYPAL',
  P24ViaPaypal = 'P24_VIA_PAYPAL',
  Paypal = 'PAYPAL',
  PayuViaPaypal = 'PAYU_VIA_PAYPAL',
  PayUponInvoiceViaPaypal = 'PAY_UPON_INVOICE_VIA_PAYPAL',
  SatispayViaPaypal = 'SATISPAY_VIA_PAYPAL',
  SepaDirectDebit = 'SEPA_DIRECT_DEBIT',
  SepaViaPaypal = 'SEPA_VIA_PAYPAL',
  SofortViaPaypal = 'SOFORT_VIA_PAYPAL',
  SwishViaPaypal = 'SWISH_VIA_PAYPAL',
  TrustlyViaPaypal = 'TRUSTLY_VIA_PAYPAL',
  UsBankAccount = 'US_BANK_ACCOUNT',
  VenmoAccount = 'VENMO_ACCOUNT',
  VerkkopankkiViaPaypal = 'VERKKOPANKKI_VIA_PAYPAL',
  VippsViaPaypal = 'VIPPS_VIA_PAYPAL',
  WechatPayViaPaypal = 'WECHAT_PAY_VIA_PAYPAL'
}

/** Possible usages for payment methods. */
export enum PaymentMethodUsage {
  MultiUse = 'MULTI_USE',
  SingleUse = 'SINGLE_USE'
}

/** Input fields that specify options for verifying the vaulted payment method. Only applicable for payment method types that suport verification. */
export type PaymentMethodVerificationOptionsInput = {
  /** ID of the merchant account to use when verifying the payment method. The verification will use the default merchant account if this field is left blank. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Whether to opt out of verifying the payment method. Defaults to `false` for payment methods that support verification. Clients should only pass `true` in the uncommon scenario that the payment method has been verified externally to Braintree. */
  skip?: InputMaybe<Scalars['Boolean']>;
};

/** The network response.  When present, this field can provide additional detail about why an authorization or verification was declined, but the processorResponse should be considered the source of truth. */
export type PaymentNetworkResponse = {
  __typename?: 'PaymentNetworkResponse';
  /** The network response code for [authorizations](https://developers.braintreepayments.com/reference/response/transaction/#network-response-codes) or [verifications](https://developers.braintreepayments.com/reference/response/credit-card-verification#network-response-codes). */
  code?: Maybe<Scalars['String']>;
  /** The network response text. */
  message?: Maybe<Scalars['String']>;
};

/** The input mode used on the payment reader to facilitate an in-store transaction. */
export enum PaymentReaderInputMode {
  Contact = 'CONTACT',
  Contactless = 'CONTACTLESS',
  Magstripe = 'MAGSTRIPE',
  MagstripeFallback = 'MAGSTRIPE_FALLBACK',
  ManualKeyEntry = 'MANUAL_KEY_ENTRY',
  Vault = 'VAULT'
}

/** Input fields for searching for any type of Payment. */
export type PaymentSearchInput = {
  /** Find payments for a given amount or currency. */
  amount?: InputMaybe<MonetaryAmountSearchInput>;
  /** Find payments by the billing address. */
  billingAddress?: InputMaybe<SearchAddressInput>;
  /** Find payments based on the time they were created. */
  createdAt?: InputMaybe<SearchTimestampInput>;
  /** Find payments with a given customer. */
  customer?: InputMaybe<SearchPaymentCustomerInput>;
  /** Find payments by their disbursement date. Only use this search criteria if you have an eligible merchant account. Note that payments can only be disbursed after they reach the SETTLED status. */
  disbursementDate?: InputMaybe<SearchDateInput>;
  /** Find payments created by a third party via the Grant API using a given OAuth application client ID. */
  facilitatorOAuthApplicationClientId?: InputMaybe<SearchValueInput>;
  /** Find payments with an ID or IDs. */
  id?: InputMaybe<SearchValueInput>;
  /** Find payments processed through a merchant account ID or IDs. */
  merchantAccountId?: InputMaybe<SearchValueInput>;
  /** Find payments with a given orderId. */
  orderId?: InputMaybe<SearchTextInput>;
  /** Find payments based on information about the payment method used for the payment. */
  paymentMethod?: InputMaybe<SearchPaymentPaymentMethodInput>;
  /** Find payments by the batch ID under which the payment was submitted for settlement. */
  settlementBatchId?: InputMaybe<SearchTextInput>;
  /** Find payments by the shipping address. */
  shippingAddress?: InputMaybe<SearchAddressInput>;
  /** Find payments created with a given source. */
  source?: InputMaybe<SearchPaymentSourceInput>;
  /** Find payments with a given status. */
  status?: InputMaybe<SearchPaymentStatusInput>;
  /** Find payments based on the time at which they transitioned to a given status. */
  statusTransition?: InputMaybe<SearchPaymentStatusTransitionInput>;
  /** Find payments by the ID of the store that the transaction was processed in. */
  storeId?: InputMaybe<SearchValueInput>;
  /** Find payments by their type. Use this field to search for payments by the direction of money movement. */
  type?: InputMaybe<SearchPaymentTypeInput>;
  /** Find payments with a user ID or IDs. */
  userId?: InputMaybe<SearchValueInput>;
};

/** The type of a Payment, based primarily on implementing type. */
export enum PaymentSearchType {
  /** Only use this field if you have processed [detached credits](https://articles.braintreepayments.com/control-panel/transactions/refunds-voids-credits#detached-credits). The payment is a Refund, and represents a refund of a transaction not processed through your Braintree account. */
  DetachedRefund = 'DETACHED_REFUND',
  /** The payment is a Refund, and represents a refund of a transaction present in this Braintree account. Unless you have processed any [detached credits](https://articles.braintreepayments.com/control-panel/transactions/refunds-voids-credits#detached-credits), this type encompasses all refunds. */
  Refund = 'REFUND',
  /** The payment is a Transaction. */
  Transaction = 'TRANSACTION'
}

/** The origin of a request that created or changed a transaction or refund. */
export enum PaymentSource {
  Api = 'API',
  ControlPanel = 'CONTROL_PANEL',
  PaymentReader = 'PAYMENT_READER',
  Recurring = 'RECURRING',
  Unknown = 'UNKNOWN'
}

/** The status of the payment, indicating its success or failure, and where it is in its [lifecycle](https://articles.braintreepayments.com/get-started/transaction-lifecycle). For further details on why any given status occurred, consult the corresponding `PaymentStatusEvent` in the payment's `statusHistory`. */
export enum PaymentStatus {
  /** The transaction spent too much time in the `AUTHORIZED` status and was marked as expired. Expiration [time frames](https://developers.braintreepayments.com/reference/general/statuses#authorization-expired) differ by card type, transaction type, and, in some cases, merchant category. */
  AuthorizationExpired = 'AUTHORIZATION_EXPIRED',
  /** The processor authorized the transaction, putting your customer's funds on hold. Your customer may see a pending charge on his or her account. However, before the customer is actually charged and before you receive the funds, you must use the `captureTransaction` mutation. If you do not want to capture the transaction, you should use the `reverseTransaction` mutation to avoid a misuse of authorization fee. */
  Authorized = 'AUTHORIZED',
  /** If a payment remains in a status of `AUTHORIZING`, [contact us for assistance](https://help.braintreepayments.com?issue=TransactionProcessingQuestion). */
  Authorizing = 'AUTHORIZING',
  /** An error occurred when sending the payment to the downstream processor. See the payment's `statusHistory` for the exact error. */
  Failed = 'FAILED',
  /** The transaction was [rejected](https://articles.braintreepayments.com/control-panel/transactions/gateway-rejections) based on one or more settings or rules in your Braintree gateway. See the transaction's `statusHistory` to determine which resulted in the decline. */
  GatewayRejected = 'GATEWAY_REJECTED',
  /** The processor declined the transaction while attempting to authorize it. See the transaction's `statusHistory` to determine what reason the processor gave for the decline. */
  ProcessorDeclined = 'PROCESSOR_DECLINED',
  /** The payment has been settled. For transactions, this means your customer has been charged and the process of disbursing the funds to your bank account has begun. For refunds, it means that the process of disbursing funds back to the customer has begun. */
  Settled = 'SETTLED',
  /** The transaction was captured partially and will not be submitted to processor for settling. Its child transaction(s) has been successfully captured and will be included in the next settlement batch. */
  SettlementConfirmed = 'SETTLEMENT_CONFIRMED',
  /** The processor declined the payment while attempting to capture it. See the payment's `statusHistory` to determine why it wasn't settled. This status is rare, and only certain types of transactions can be affected. */
  SettlementDeclined = 'SETTLEMENT_DECLINED',
  /** The transaction has not yet fully settled. This status is rare, and will generally resolve to a status of `SETTLED`. Only certain types of transactions can be affected. */
  SettlementPending = 'SETTLEMENT_PENDING',
  /** The payment is in the process of being settled. This is a transitory state, and will resolve to a status of `SETTLED`. */
  Settling = 'SETTLING',
  /** The payment has been successfully captured, and will be included in the next settlement batch, at which time it will become settled. */
  SubmittedForSettlement = 'SUBMITTED_FOR_SETTLEMENT',
  /** The payment has been voided or canceled. For transactions, this means it's no longer authorized, your customer's funds are no longer on hold, and you can't use the `captureTransaction` mutation on this transaction. For refunds, it means the customer will not receive the funds from the refund. */
  Voided = 'VOIDED'
}

/** Status event in the [lifecycle of a payment](https://articles.braintreepayments.com/get-started/transaction-lifecycle). */
export type PaymentStatusEvent = {
  /** The payment amount applicable to the status. For instance, the amount when a transaction is `SUBMITTED_FOR_SETTLEMENT` might be less than the amount for which it was `AUTHORIZED`. */
  amount?: Maybe<MonetaryAmount>;
  /** Source that caused the status event to occur. */
  source?: Maybe<PaymentSource>;
  /** New status of the payment. */
  status?: Maybe<PaymentStatus>;
  /** Whether this is the final state for the payment. If false, this transaction will pass into another subsequent state. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the status event occurred. */
  timestamp?: Maybe<Scalars['Timestamp']>;
};

/** Top-level fields for performing a 3D Secure Lookup. */
export type PerformThreeDSecureLookupInput = {
  /** The amount you plan to charge the payment method after the 3D Secure authentication. */
  amount: Scalars['Amount'];
  /** If set to true, a card-add challenge will be requested from the issuer to confirm adding new card to the merchant's vault. This flag should only be used when adding a card to a merchants vault and not for creating transactions. */
  cardAdd?: InputMaybe<Scalars['Boolean']>;
  /** Additional information about the cardholder when authenticating through 3D Secure. */
  cardholderInformation?: InputMaybe<ThreeDSecureLookupCardholderInformationInput>;
  /** Information about the client-side lookup process. */
  clientInformation?: InputMaybe<ThreeDSecureLookupClientInformationInput>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** When set to true, the data-only 3D Secure call will be created. The status of [DATA_ONLY_SUCCESSFUL](https://developers.braintreepayments.com/guides/3d-secure/advanced-options#using-data-only-3d-secure) will be returned as `ThreeDSecureAuthenticationStatus` for a successful response. */
  dataOnlyRequested?: InputMaybe<Scalars['Boolean']>;
  /** Reference ID used by our MPI provider CardinalCommerce to connect the lookup request to the device data that was previously collected. */
  dfReferenceId?: InputMaybe<Scalars['String']>;
  /** ID of the merchant account that will be used when charging the payment method. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** ID of a payment method to perform the lookup on. */
  paymentMethodId: Scalars['ID'];
  /** When set to true, requests a 3D Secure authentication challenge from the issuer. A challenge will result in the acsUrl field being populated on the response, requiring you to open the challenge on the client side. */
  requestAuthenticationChallenge?: InputMaybe<Scalars['Boolean']>;
  /** Additional information about the transaction when authenticating through 3D Secure. */
  transactionInformation?: InputMaybe<ThreeDSecureLookupTransactionInformationInput>;
};

/** Top-level fields returned when performing a 3D Secure Lookup. */
export type PerformThreeDSecureLookupPayload = {
  __typename?: 'PerformThreeDSecureLookupPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A single-use payment method. */
  paymentMethod?: Maybe<PaymentMethod>;
  /** Data fields containing information from the MPI provider about the 3D Secure Lookup result. */
  threeDSecureLookupData?: Maybe<ThreeDSecureLookupData>;
};

/** The phone number in its international [E.164 numbering plan format](https://www.itu.int/rec/T-REC-E.164/en). */
export type PhoneInput = {
  /**
   * The country calling code (CC), in its canonical international [E.164 numbering
   * plan format](https://www.itu.int/rec/T-REC-E.164/en). The combined length of
   * the CC and the national number must not be greater than 15 digits. The
   * national number consists of a national destination code (NDC) and subscriber number (SN).
   */
  countryPhoneCode: Scalars['String'];
  /** The extension number. */
  extensionNumber?: InputMaybe<Scalars['String']>;
  /**
   * The phone number, in its canonical international [E.164 numbering plan
   * format](https://www.itu.int/rec/T-REC-E.164/en). The combined length of the
   * country calling code (CC) and the national number must not be greater than 15
   * digits. The national number consists of a national destination code (NDC) and
   * subscriber number (SN).
   */
  phoneNumber: Scalars['String'];
};

/** The pre-dispute program of the dispute. */
export enum PreDisputeProgram {
  /** The dispute does not have a pre-dispute program. */
  None = 'NONE',
  /** The dispute is part of the Visa Rapid Dispute Resolution (RDR) program. */
  VisaRdr = 'VISA_RDR'
}

/** Whether the decline is likely to be temporary or persistent. Can be taken into consideration when determining whether to retry a declined charge. */
export enum ProcessorDeclineType {
  /** Hard declines are the result of an error or issue which can't be resolved immediately; the decline is not temporary and subsequent charges on the same payment method will likely not be successful. */
  Hard = 'HARD',
  /** Soft declines result from a temporary issue and can be retried; subsequent charges on the same payment method may be successful. */
  Soft = 'SOFT'
}

/** Accompanying information for a processor declined transaction. */
export type ProcessorDeclinedEvent = PaymentStatusEvent & {
  __typename?: 'ProcessorDeclinedEvent';
  /** The amount of the transaction for this status event. */
  amount?: Maybe<MonetaryAmount>;
  /** Whether or not the decline is the result of a temporary issue. */
  declineType?: Maybe<ProcessorDeclineType>;
  /** Fields describing the network response to the authorization request. */
  networkResponse?: Maybe<PaymentNetworkResponse>;
  /** Fields describing the payment processor response and why they declined the transaction. */
  processorResponse?: Maybe<TransactionAuthorizationProcessorResponse>;
  /** Risk decision for this transaction. */
  riskDecision?: Maybe<RiskDecision>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the transaction was declined by the processor. */
  timestamp?: Maybe<Scalars['Timestamp']>;
  /** User name of the person who performed an action that triggered the status change of the transaction. */
  userName?: Maybe<Scalars['String']>;
};

/** The top-level Query type. Queries are used to fetch data. */
export type Query = {
  __typename?: 'Query';
  /** The client-side environment and payment method configuration. */
  clientConfiguration?: Maybe<ClientConfiguration>;
  /** Get a GraphQL ID from a legacy ID that was returned from an SDK or a legacyId field. Does not verify existence except for payment methods. */
  idFromLegacyId: Scalars['ID'];
  /** Retrieve a paginated list of all in-store locations. */
  inStoreLocations?: Maybe<InStoreLocationConnection>;
  /** Fetch any object that extends the Node interface using its ID. */
  node?: Maybe<Node>;
  /** Retrieve PayPal financing options that include payment installment plans. */
  paypalFinancingOptions?: Maybe<PayPalFinancingOptionsPayload>;
  /** Returns the literal string 'pong'. */
  ping: Scalars['String'];
  /** Triggers a beep on a connected Reader and returns the Reader information or an error if unable to ping the device. */
  pingInStoreReader?: Maybe<InStoreReader>;
  /** A collection of the available reports. Each field on the `Report` type is a different report that can be queried with its own input parameters. */
  report?: Maybe<Report>;
  /** A collection of the available searches. Each field on the `Search` type is a different search that can be queried with its own input parameters. */
  search?: Maybe<Search>;
  /** The currently authenticated viewer. */
  viewer?: Maybe<Viewer>;
};


/** The top-level Query type. Queries are used to fetch data. */
export type QueryIdFromLegacyIdArgs = {
  legacyId: Scalars['ID'];
  type: LegacyIdType;
};


/** The top-level Query type. Queries are used to fetch data. */
export type QueryInStoreLocationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** The top-level Query type. Queries are used to fetch data. */
export type QueryNodeArgs = {
  id: Scalars['ID'];
};


/** The top-level Query type. Queries are used to fetch data. */
export type QueryPaypalFinancingOptionsArgs = {
  input: PayPalFinancingOptionsInput;
};


/** The top-level Query type. Queries are used to fetch data. */
export type QueryPingInStoreReaderArgs = {
  readerId: Scalars['ID'];
};

/** Indicates the status of a Reader. */
export enum ReaderStatus {
  Offline = 'OFFLINE',
  Online = 'ONLINE'
}

/** The type of recurring payment a transaction represents. */
export enum RecurringType {
  First = 'FIRST',
  Subsequent = 'SUBSEQUENT',
  Unscheduled = 'UNSCHEDULED'
}

/** A refund of a charge on a payment method, representing an attempt to send money from a previous transaction back to the customer. */
export type Refund = Node & Payment & {
  __typename?: 'Refund';
  /** The amount that will be refunded, which can be less than or equal to the original charge amount. */
  amount?: Maybe<MonetaryAmount>;
  /** Date and time when the refund was created. */
  createdAt?: Maybe<Scalars['Timestamp']>;
  /** Collection of custom field/value pairs passed when creating the refund. Custom fields are [defined in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#store-and-pass-back-fields). For all refunds except "detached refunds", these will always be null. */
  customFields?: Maybe<Array<CustomField>>;
  /** The customer that the vaulted payment method (if it exists) belongs to. Equivalent to `refundedTransaction.customer` (if present). */
  customer?: Maybe<Customer>;
  /** Fields used to define what will appear on a customer's statement (for instance, credit card or bank statement) for this refund. This will always match the descriptor from the refunded transaction (if present). */
  descriptor?: Maybe<TransactionDescriptor>;
  /** Payment method specific details about the refund. */
  details?: Maybe<RefundPaymentMethodDetails>;
  /** The disbursement details associated with this refund. This field is only available after the refund is SETTLED and if you have an eligible merchant account. */
  disbursementDetails?: Maybe<DisbursementDetails>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Legacy unique identifier. */
  legacyId: Scalars['ID'];
  /** Line items for this refund. */
  lineItems?: Maybe<Array<TransactionLineItem>>;
  /** The ID of the merchant account that processed this refund. */
  merchantAccountId?: Maybe<Scalars['ID']>;
  /** The order ID for this refund. For PayPal transactions, the PayPal Invoice ID. */
  orderId?: Maybe<Scalars['String']>;
  /** The refund date and time as reported by the in-store payment terminal. */
  paymentInitiatedAt?: Maybe<Scalars['Timestamp']>;
  /** The multi-use payment method that will receive the refund. Only present if a multi-use payment method was used to create the original transaction and it has not been since deleted. The details of this PaymentMethod may have changed since the transaction was created; details used for the transaction can be found in the `paymentMethodSnapshot` field. Equivalent to `refundedTransaction.paymentMethod` (if present). */
  paymentMethod?: Maybe<PaymentMethod>;
  /** Snapshot of payment method details that will receive the refund, typically based on the original transaction. This will always be present. Equivalent to `refundedTransaction.paymentMethodSnapshot`. */
  paymentMethodSnapshot?: Maybe<PaymentMethodSnapshot>;
  /** The original transaction that this refunds. If this is not present, then this refund represents a refund of a transaction that does not belong to this Braintree gateway account. */
  refundedTransaction?: Maybe<Transaction>;
  /** How the refund was created. */
  source?: Maybe<PaymentSource>;
  /** The current status of this refund. */
  status?: Maybe<PaymentStatus>;
  /** The records of all statuses this refund has passed through, with additional information on why each status occurred. Returned in reverse chronological order, with the most recent event first in the list. */
  statusHistory?: Maybe<Array<PaymentStatusEvent>>;
};

/** A paginated list of refunds. */
export type RefundConnection = {
  __typename?: 'RefundConnection';
  /** A list of refunds. */
  edges?: Maybe<Array<Maybe<RefundConnectionEdge>>>;
  /** Information about the page of refunds contained in `edges`. */
  pageInfo: PageInfo;
};

/** A transaction within a RefundConnection. */
export type RefundConnectionEdge = {
  __typename?: 'RefundConnectionEdge';
  /** This refund's location within the RefundConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The refund. */
  node?: Maybe<Refund>;
};

/** Top-level input fields for creating a detached refund on a credit card. */
export type RefundCreditCardInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the credit card to be refunded. */
  paymentMethodId: Scalars['ID'];
  /** Input fields containing details about the refund. */
  refund: DetachedRefundInput;
};

/** Top-level output field from creating a detached refund for a credit card. */
export type RefundCreditCardPayload = {
  __typename?: 'RefundCreditCardPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The information about the created refund. */
  refund?: Maybe<Refund>;
};

/** Specific input fields for describing a refund. */
export type RefundInput = {
  /** The amount to refund. Must be less than or equal to the amount of the original transaction. Defaults to the total amount of the original transaction. */
  amount?: InputMaybe<Scalars['Amount']>;
  /** Description of the refund that is displayed to customers in PayPal email receipts. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * Line items for this refund. Up to 249 line items may be specified.
   *
   * Only allowed for Custom Actions transactions.
   */
  lineItems?: InputMaybe<Array<TransactionLineItemInput>>;
  /** ID of the merchant account that will be used when performing the refund. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** The refund's order ID. Defaults to the order ID of the original transaction. */
  orderId?: InputMaybe<Scalars['String']>;
  /** Reason of the refund transaction. This field maps to the PayPal refund reason. */
  reason?: InputMaybe<Scalars['String']>;
};

/** A union of all possible payment method refund details. */
export type RefundPaymentMethodDetails = PayPalLocalPaymentRefundDetails | PayPalRefundDetails | SepaDirectDebitRefundDetails;

/** Supported refund policies. */
export enum RefundPolicy {
  ExchangeOnly = 'EXCHANGE_ONLY',
  NoRefundOrExchange = 'NO_REFUND_OR_EXCHANGE',
  RefundCardholder = 'REFUND_CARDHOLDER'
}

/** Input fields for searching for refunds. */
export type RefundSearchInput = {
  /** Find refunds with a given amount or currency. */
  amount?: InputMaybe<MonetaryAmountSearchInput>;
  /** Find refunds by the billing address. */
  billingAddress?: InputMaybe<SearchAddressInput>;
  /** Find refunds based on the time they were created. */
  createdAt?: InputMaybe<SearchTimestampInput>;
  /** Find refunds with a given customer. */
  customer?: InputMaybe<SearchPaymentCustomerInput>;
  /** Find refunds by their disbursement date. Only use this search criteria if you have an eligible merchant account. Note that refunds can only be disbursed after they reach the SETTLED status. */
  disbursementDate?: InputMaybe<SearchDateInput>;
  /** Find refunds created by a third party via the Grant API using a given OAuth application client ID. */
  facilitatorOAuthApplicationClientId?: InputMaybe<SearchValueInput>;
  /** Find refunds with an ID or IDs. */
  id?: InputMaybe<SearchValueInput>;
  /** Find refunds processed through a merchant account ID or IDs. In most cases, this will be the merchant account of the original refunded transaction. */
  merchantAccountId?: InputMaybe<SearchValueInput>;
  /** Find refunds with a given orderId. */
  orderId?: InputMaybe<SearchTextInput>;
  /** Find refunds based on information about the payment method used for the refund. */
  paymentMethod?: InputMaybe<SearchPaymentPaymentMethodInput>;
  /** Find refunds by the batch ID under which the refund was submitted for settlement. */
  settlementBatchId?: InputMaybe<SearchTextInput>;
  /** Find refunds by the shipping address. */
  shippingAddress?: InputMaybe<SearchAddressInput>;
  /** Find refunds created with a given source. */
  source?: InputMaybe<SearchPaymentSourceInput>;
  /** Find refunds with the given status. */
  status?: InputMaybe<SearchTransactionStatusInput>;
  /** Find payments based on the time at which they transitioned to a given status. */
  statusTransition?: InputMaybe<SearchPaymentStatusTransitionInput>;
  /** Find refunds by the ID of the store that the transaction was processed in. */
  storeId?: InputMaybe<SearchValueInput>;
  /** Find refunds with a user ID or IDs. */
  userId?: InputMaybe<SearchValueInput>;
};

/** Top-level input fields for refunding a transaction. */
export type RefundTransactionInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for the details of the refund. */
  refund?: InputMaybe<RefundInput>;
  /** The ID of a transaction to be refunded. */
  transactionId: Scalars['ID'];
};

/** Top-level output field from refunding a transaction. */
export type RefundTransactionPayload = {
  __typename?: 'RefundTransactionPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The information about the created refund. */
  refund?: Maybe<Refund>;
};

/** Top-level input fields for creating a detached refund on a US Bank Account. */
export type RefundUsBankAccountInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields related to the US bank account being charged. */
  options?: InputMaybe<ChargeUsBankAccountOptionsInput>;
  /** ID of the US Bank Account to be refunded. */
  paymentMethodId: Scalars['ID'];
  /** Input fields containing details about the refund. */
  refund: DetachedRefundInput;
};

/** Top-level output field from creating a detached refund for a US Bank Account. */
export type RefundUsBankAccountPayload = {
  __typename?: 'RefundUsBankAccountPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The information about the created refund. */
  refund?: Maybe<Refund>;
};

/** Top-level fields returned for a report query. */
export type Report = {
  __typename?: 'Report';
  /** Top-level fields returned in the payment-level fee report query. */
  paymentLevelFees?: Maybe<PaymentLevelFeeReport>;
  /**
   * Top-level fields returned in the transaction-level fee report query.
   * @deprecated This report has been renamed `paymentLevelFees`, since it applies to all types in the Payment interface, including transactions and refunds. Use the `paymentLevelFees` field instead, which returns the same report.
   */
  transactionLevelFees?: Maybe<TransactionLevelFeeReport>;
};


/** Top-level fields returned for a report query. */
export type ReportPaymentLevelFeesArgs = {
  date: Scalars['Date'];
  merchantAccountId?: InputMaybe<Scalars['ID']>;
};


/** Top-level fields returned for a report query. */
export type ReportTransactionLevelFeesArgs = {
  date: Scalars['Date'];
  merchantAccountId?: InputMaybe<Scalars['ID']>;
};

/** Input fields for requesting a cancel during an in-store charge flow. */
export type RequestCancelFromInStoreReaderInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Unique ID for the charge flow. */
  inStoreContextId: Scalars['ID'];
};

/** Input fields for beginning the in-store charge flow. */
export type RequestChargeFromInStoreReaderInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the Reader to request a charge from. */
  readerId: Scalars['ID'];
  /** Information about the requested in-store transaction. */
  transaction: InStoreTransactionInput;
};

/** Reference object for an in-store charge request. */
export type RequestChargeInStoreContext = InStoreContextResult & Node & {
  __typename?: 'RequestChargeInStoreContext';
  /** A unique ID for this charge request. */
  id: Scalars['ID'];
  /** The reader from which the charge was requested. */
  reader?: Maybe<InStoreReader>;
  /** The status of the context created when the charge was requested. A status of COMPLETE does not indicate a successful payment. */
  status: InStoreContextStatus;
  /** The transaction representing the charge on the payment method. */
  transaction?: Maybe<Transaction>;
};

/** Input fields for requesting a confirmation prompt on an in-store reader. */
export type RequestConfirmationPromptFromInStoreReaderInput = {
  /** The way the text is aligned when displayed on an in-store reader. Defaults to CENTER. */
  alignment?: InputMaybe<ConfirmationPromptAlignment>;
  /** Text for the cancellation option to be displayed on the in-store reader. 20 character maximum. */
  cancellationText?: InputMaybe<Scalars['String']>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Text for the confirmation option to be displayed on the in-store reader. 20 character maximum. */
  confirmationText?: InputMaybe<Scalars['String']>;
  /** ID of the Reader to request a confirmation prompt from. */
  readerId: Scalars['ID'];
  /** Text to be displayed on the in-store reader. 65536 character maximum. '\n' line breaks will be respected. */
  text: Scalars['String'];
  /** Title to be displayed on the in-store reader. 50 character maximum. */
  title: Scalars['String'];
};

/** Reference object for an in-store reader confirmation prompt. */
export type RequestConfirmationPromptInStoreContext = InStoreContextResult & Node & {
  __typename?: 'RequestConfirmationPromptInStoreContext';
  /** The confirmation response collected by the in-store reader. */
  confirmed?: Maybe<Scalars['Boolean']>;
  /** A unique ID for this confirmation prompt request. */
  id: Scalars['ID'];
  /** The reader from which the confirmation prompt was requested. */
  reader?: Maybe<InStoreReader>;
  /** The status of the context created when the confirmation prompt was requested. */
  status: InStoreContextStatus;
};

/** Reference object for an in-store display request. */
export type RequestDisplayInStoreContext = InStoreContextResult & Node & {
  __typename?: 'RequestDisplayInStoreContext';
  /** A unique ID for this display request. */
  id: Scalars['ID'];
  /** The reader from which the display was requested. */
  reader?: Maybe<InStoreReader>;
  /** The status of the context created when the display was requested. */
  status: InStoreContextStatus;
};

/** Input fields for requesting a firmware update for an in-store reader. */
export type RequestFirmwareUpdateFromInStoreReaderInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The in-store reader to receive the firmware update. */
  readerId: Scalars['ID'];
};

/** Reference object for an in-store reader firmware update. */
export type RequestFirmwareUpdateInStoreContext = InStoreContextResult & Node & {
  __typename?: 'RequestFirmwareUpdateInStoreContext';
  /** A unique ID for this firmware update request. */
  id: Scalars['ID'];
  /** The reader for which the firmware update was requested. */
  reader?: Maybe<InStoreReader>;
  /** The status of the context created when the firmware update was requested. */
  status: InStoreContextStatus;
};

/** Input fields for beginning the in-store display line items flow. */
export type RequestItemDisplayFromInStoreReaderInput = {
  /** The total amount for the entire transaction, including tax. */
  amount: Scalars['Amount'];
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The total discount amount for the entire transaction. */
  discountAmount?: InputMaybe<Scalars['Amount']>;
  /** Items to be displayed on the in-store reader. Up to 249 items may be specified. */
  displayItems?: InputMaybe<Array<InStoreDisplayItemInput>>;
  /** ID of the Reader to display items on. */
  readerId: Scalars['ID'];
  /** The total tax amount for the entire transaction, including all display line items. */
  tax: Scalars['Amount'];
};

/** Input fields for beginning the in-store refund flow. */
export type RequestRefundFromInStoreReaderInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the Reader to request a refund from. */
  readerId: Scalars['ID'];
  /** Information about the requested in-store refund. */
  refund: InStoreRefundInput;
};

/** Reference object for an in-store refund request. */
export type RequestRefundInStoreContext = InStoreContextResult & Node & {
  __typename?: 'RequestRefundInStoreContext';
  /** A unique ID for this refund request. */
  id: Scalars['ID'];
  /** The reader from which the refund was requested. */
  reader?: Maybe<InStoreReader>;
  /** The refund representing the refund on the payment method. */
  refund?: Maybe<Refund>;
  /** The status of the context created when the refund was requested. A status of COMPLETE does not indicate a successful payment. */
  status: InStoreContextStatus;
};

/** Input fields for requesting a signature prompt on an in-store reader. */
export type RequestSignaturePromptFromInStoreReaderInput = {
  /** Text for the cancellation option to be displayed on the in-store reader. 20 character maximum. */
  cancellationText?: InputMaybe<Scalars['String']>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Text for the confirmation option to be displayed on the in-store reader. 20 character maximum. */
  confirmationText?: InputMaybe<Scalars['String']>;
  /** ID of the Reader to request a signature prompt from. */
  readerId: Scalars['ID'];
  /** Title to be displayed on the in-store reader. 50 character maximum. */
  title?: InputMaybe<Scalars['String']>;
};

/** Reference object for an in-store reader signature prompt. */
export type RequestSignaturePromptInStoreContext = InStoreContextResult & Node & {
  __typename?: 'RequestSignaturePromptInStoreContext';
  /** A unique ID for this signature prompt request. */
  id: Scalars['ID'];
  /** The reader from which the signature prompt was requested. */
  reader?: Maybe<InStoreReader>;
  /** The signature data collected by the in-store reader. Base64 encoded PNG image. */
  signatureData?: Maybe<Scalars['String']>;
  /** The status of the context created when the signature prompt was requested. */
  status: InStoreContextStatus;
};

/** Input fields for beginning the in-store display text flow. */
export type RequestTextDisplayFromInStoreReaderInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the Reader to request a text display from. */
  readerId: Scalars['ID'];
  /** Text to be displayed on the in-store reader. 255 character maximum. '\n' line breaks will be respected. */
  text: Scalars['String'];
};

/** Input fields for beginning the in-store charge flow. */
export type RequestVaultFromInStoreReaderInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the customer to associate the resulting multi-use payment method with. */
  customerId?: InputMaybe<Scalars['ID']>;
  /** ID of the Reader to request a vault from. */
  readerId: Scalars['ID'];
  /** Input fields that specify options for verifying the payment method before vaulting. Only applicable if the payment method is of a type that supports verification. For supported types, verification is performed by default. If the verification fails, the payment method will not be vaulted. */
  verification?: InputMaybe<PaymentMethodVerificationOptionsInput>;
};

/** Reference object for an in-store vault request. */
export type RequestVaultInStoreContext = InStoreContextResult & Node & {
  __typename?: 'RequestVaultInStoreContext';
  /** A unique ID for this vault request. */
  id: Scalars['ID'];
  /** A payment method that has been stored in a merchant's vault and can be reused. */
  paymentMethod?: Maybe<PaymentMethod>;
  /** The reader from which the vault was requested. */
  reader?: Maybe<InStoreReader>;
  /** The status of the context created when the vault was requested. */
  status: InStoreContextStatus;
  /** The verification that was run on the payment method prior to vaulting. */
  verification?: Maybe<Verification>;
};

/** Input fields for reversing a refund. */
export type ReverseRefundInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the refund to reverse. */
  refundId: Scalars['ID'];
};

/** Input fields for reversing a transaction. */
export type ReverseTransactionInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the transaction to reverse. */
  transactionId: Scalars['ID'];
};

/** Top-level output field for reversing a transaction. */
export type ReverseTransactionPayload = {
  __typename?: 'ReverseTransactionPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A transaction (if the original transaction was voided) or refund (if the original transaction was refunded). A reversal will attempt to void the original transaction if it has not yet settled. If the original transaction has settled, a reversal will create a refund for the full amount. */
  reversal?: Maybe<TransactionReversal>;
};

/** A right assigned to a user. */
export type Right = {
  __typename?: 'Right';
  /** A human-readable name. */
  name?: Maybe<Scalars['String']>;
};

/** Data from advanced risk evaluations. */
export type RiskData = {
  __typename?: 'RiskData';
  /** The risk decision on whether the transaction should be permitted. */
  decision?: Maybe<RiskDecision>;
  /** The reasons for the decision from the fraud service provider. */
  decisionReasons?: Maybe<Array<Scalars['String']>>;
  /** Whether data associated with the customer's device was captured and used in the decision process. */
  deviceDataCaptured?: Maybe<Scalars['Boolean']>;
  /** The fraud service provider used to generate the risk decision. */
  fraudServiceProvider?: Maybe<FraudServiceProvider>;
  /** Unique identifier. */
  id?: Maybe<Scalars['ID']>;
  /** Liability Shift information in the event of a chargeback. */
  liabilityShift?: Maybe<LiabilityShift>;
  /** The numeric risk score assigned by the fraud service provider. */
  score?: Maybe<Scalars['Int']>;
};

/** Input fields for data used by processors for risk analysis. */
export type RiskDataInput = {
  /** The User-Agent header provided by the customer's browser, which gives information about the browser. Maximum 255 characters. */
  customerBrowser?: InputMaybe<Scalars['String']>;
  /** The customer's IP address. */
  customerIp?: InputMaybe<Scalars['String']>;
  /** Customer device information. Required when creating transactions using cards (only if using Advanced Fraud Tools), PayPal (only for one-time Vaulted PayPal transactions), and Venmo payment method types. This value will contain a Fraud Merchant ID as the unique, numeric identifier for a Kount account and a Device Session ID as the unique identifier for a customer device. For PayPal and Venmo transactions, this value will also include a PayPal Correlation ID. */
  deviceData?: InputMaybe<Scalars['String']>;
};

/** The risk decision provides further context on how a transaction was scored for risk by Braintree. */
export enum RiskDecision {
  Approve = 'APPROVE',
  Decline = 'DECLINE',
  NotEvaluated = 'NOT_EVALUATED',
  Review = 'REVIEW'
}

/** Groups of rights assigned to the user. */
export type Role = {
  __typename?: 'Role';
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Whether the role grants account admin status. */
  isAccountAdmin?: Maybe<Scalars['Boolean']>;
  /** A human-readable name. */
  name?: Maybe<Scalars['String']>;
  /** The rights associated with the role. */
  rights?: Maybe<Array<Right>>;
};

/** Details about a SEPA Direct Debit account. */
export type SepaDirectDebitAccountDetails = {
  __typename?: 'SEPADirectDebitAccountDetails';
  /** Bank reference token. */
  bankReferenceToken?: Maybe<Scalars['String']>;
  /** Last 4 characters of IBAN number. */
  last4?: Maybe<Scalars['String']>;
  /** Mandate type. */
  mandateType?: Maybe<MandateType>;
  /** Merchant or Partner Customer ID. */
  merchantOrPartnerCustomerId?: Maybe<Scalars['String']>;
};

/** Refund-related details for SEPA Direct Debit transactions. */
export type SepaDirectDebitRefundDetails = {
  __typename?: 'SEPADirectDebitRefundDetails';
  /** PayPal V2 OrderId. */
  paymentId?: Maybe<Scalars['String']>;
  /** The SEPA Direct Debit refund ID. */
  refundId?: Maybe<Scalars['ID']>;
  /** Refunded transaction fee charged by SEPA Direct Debit. */
  refundedFee?: Maybe<MonetaryAmount>;
};

/** Details about a SEPA Direct Debit account. */
export type SepaDirectDebitTransactionDetails = {
  __typename?: 'SEPADirectDebitTransactionDetails';
  /** If funds for the transaction have settled, the PayPal ID for the capture of funds. */
  captureId?: Maybe<Scalars['String']>;
  /** PayPal V2 OrderId. */
  paymentId?: Maybe<Scalars['String']>;
  /** The fee charged by PayPal for the transaction. */
  transactionFee?: Maybe<MonetaryAmount>;
};

/** Details about a Samsung Pay card. */
export type SamsungPayCardDetails = {
  __typename?: 'SamsungPayCardDetails';
  /** The first 6 digits of the credit card, known as the Bank Identification Number. This BIN will differ from the BIN of the source (customer's actual) card. */
  bin?: Maybe<Scalars['String']>;
  /** Information about the card based on its BIN. This BIN will differ from the BIN of the source (customer's actual) card. */
  binData?: Maybe<BinRecord>;
  /** The display name of the card brand, e.g. "Visa" or "American Express". */
  brand?: Maybe<Scalars['String']>;
  /** A static code identifying the card brand of the FPAN (the customer's actual backing card). */
  brandCode?: Maybe<CreditCardBrandCode>;
  /** The last four digits of the FPAN (the customer's actual backing card). */
  sourceCardLast4?: Maybe<Scalars['CreditCardLast4']>;
};

/** Input fields for a Samsung Pay card. */
export type SamsungPayCardInput = {
  /** A one-time-use string generated by the token requester to validate the transaction. */
  cryptogram: Scalars['String'];
  /** A two-digit string that should be passed along in the authorization message. */
  eCommerceIndicator: Scalars['ECommerceIndicator'];
  /** A two-digit string representing the expiration month of the DPAN. */
  expirationMonth: Scalars['Month'];
  /** A four-digit string representing the expiration year of the DPAN. */
  expirationYear: Scalars['Year'];
  /** The card number provided by Samsung and used in processing. This is a digitized PAN (DPAN), not the backing card number (FPAN). */
  number: Scalars['CreditCardNumber'];
  /** The last four digits of the FPAN (the cardholder's backing card). */
  sourceCardLast4: Scalars['CreditCardLast4'];
};

/** Configuration for Samsung Pay on Android. */
export type SamsungPayConfiguration = {
  __typename?: 'SamsungPayConfiguration';
  /** A string used to identify the merchant to the customer. */
  displayName?: Maybe<Scalars['String']>;
  /** The Samsung Pay environment. */
  environment?: Maybe<SamsungPayEnvironment>;
  /** Authorization to use when tokenizing Samsung Pay. */
  samsungAuthorization?: Maybe<Scalars['String']>;
  /** The Samsung Pay service ID. */
  serviceId?: Maybe<Scalars['String']>;
  /** A list of card brands supported by the merchant for Samsung Pay. */
  supportedCardBrands?: Maybe<Array<CreditCardBrandCode>>;
};

/** The environment being used for Samsung Pay. */
export enum SamsungPayEnvironment {
  Production = 'PRODUCTION',
  Sandbox = 'SANDBOX'
}

/** Additional information about the payment method specific to Samsung Pay. */
export type SamsungPayOriginDetails = {
  __typename?: 'SamsungPayOriginDetails';
  /** The first 6 digits of the credit card, known as the Bank Identification Number. This BIN may differ from the BIN of the customer's actual card. */
  bin?: Maybe<Scalars['String']>;
};

/** Top-level input fields for settling a transaction in the sandbox environment. */
export type SandboxSettleTransactionInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The target settlement state for the transaction in the sandbox environment. */
  settlementState?: InputMaybe<SandboxSettlementState>;
  /** Id of the transaction to force settlement in the sandbox environment. */
  transactionId: Scalars['ID'];
};

/** The settlement state when forcing transaction settlement in the sandbox environment. */
export enum SandboxSettlementState {
  Settled = 'SETTLED',
  SettlementDeclined = 'SETTLEMENT_DECLINED'
}

/** The type of Strong Customer Authentication Exemption. */
export enum ScaExemptionType {
  LowValue = 'LOW_VALUE',
  SecureCorporate = 'SECURE_CORPORATE',
  TransactionRiskAnalysis = 'TRANSACTION_RISK_ANALYSIS',
  TrustedBeneficiary = 'TRUSTED_BENEFICIARY'
}

/** Top-level fields returned for a search query. */
export type Search = {
  __typename?: 'Search';
  /** A paginated list of business account creation requests that match the BusinessAccountCreationRequestSearchInput. */
  businessAccountCreationRequests?: Maybe<BusinessAccountCreationRequestConnection>;
  /** A paginated list of customers that match the CustomerSearchInput. */
  customers?: Maybe<CustomerConnection>;
  /** A paginated list of disputes that match the DisputeSearchInput. */
  disputes?: Maybe<DisputeConnection>;
  /** A paginated list of in-store readers that match the InStoreReaderSearchInput. */
  inStoreReaders?: Maybe<InStoreReaderConnection>;
  /** A paginated list of all types of Payment that match the PaymentSearchInput. */
  payments?: Maybe<PaymentConnection>;
  /** A paginated list of refunds that match the RefundSearchInput. */
  refunds?: Maybe<RefundConnection>;
  /** A paginated list of transactions that match the TransactionSearchInput. */
  transactions?: Maybe<TransactionConnection>;
  /** A paginated list of verifications that match the VerificationSearchInput. */
  verifications?: Maybe<VerificationConnection>;
};


/** Top-level fields returned for a search query. */
export type SearchBusinessAccountCreationRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  input: BusinessAccountCreationRequestSearchInput;
};


/** Top-level fields returned for a search query. */
export type SearchCustomersArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  input: CustomerSearchInput;
};


/** Top-level fields returned for a search query. */
export type SearchDisputesArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  input: DisputeSearchInput;
};


/** Top-level fields returned for a search query. */
export type SearchInStoreReadersArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  input: InStoreReaderSearchInput;
};


/** Top-level fields returned for a search query. */
export type SearchPaymentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  input: PaymentSearchInput;
};


/** Top-level fields returned for a search query. */
export type SearchRefundsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  input: RefundSearchInput;
};


/** Top-level fields returned for a search query. */
export type SearchTransactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  input: TransactionSearchInput;
};


/** Top-level fields returned for a search query. */
export type SearchVerificationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  input: VerificationSearchInput;
};

/** Input fields for searching by address. */
export type SearchAddressInput = {
  /** The first line of the street address, such as street number, street name. */
  addressLine1?: InputMaybe<SearchTextInput>;
  /** Extended address information, such as apartment number or suite number. */
  addressLine2?: InputMaybe<SearchTextInput>;
  /** Highest level subdivision, such as state, province or ISO-3166-2 subdivision. */
  adminArea1?: InputMaybe<SearchTextInput>;
  /** A city, town or village. */
  adminArea2?: InputMaybe<SearchTextInput>;
  /** Company name. */
  company?: InputMaybe<SearchTextInput>;
  /** Country code for the address. */
  countryName?: InputMaybe<SearchTextInput>;
  /** First name. */
  firstName?: InputMaybe<SearchTextInput>;
  /** Last name. */
  lastName?: InputMaybe<SearchTextInput>;
  /** Postal code in any country's format, otherwise known as CAP, CEP, Eircode, NPA, PIN, PLZ, or ZIP code. */
  postalCode?: InputMaybe<SearchTextInput>;
};

/**
 * Deprecated: Please use `SearchDisputeProtectionLevelInput` instead.
 *
 * Input fields for searching for a dispute with a given chargeback protection level.
 */
export type SearchChargebackProtectionLevelInput = {
  /** Dispute's chargeback protection level is one of these values. */
  in?: InputMaybe<Array<ChargebackProtectionLevel>>;
  /** The dispute's chargeback protection level is exactly this value. */
  is?: InputMaybe<ChargebackProtectionLevel>;
};

/** Input fields for searching for payments by credit card brand. */
export type SearchCreditCardBrandCodeInput = {
  /** Credit card brand code is one of these values. */
  in?: InputMaybe<Array<CreditCardBrandCode>>;
  /** Credit card brand code is exactly this value. */
  is?: InputMaybe<CreditCardBrandCode>;
};

/** Input fields for searching for payments by payment method snapshot credit card expiration date criteria. */
export type SearchCreditCardExpirationDateInput = {
  /** Field is exactly this value. */
  is?: InputMaybe<SearchCreditCardExpirationMonthYearInput>;
  /** Field is not this value. */
  isNot?: InputMaybe<SearchCreditCardExpirationMonthYearInput>;
};

/** Input fields for searching for payments by payment method snapshot credit card expiration date criteria. */
export type SearchCreditCardExpirationMonthYearInput = {
  /** The month of the credit card expiration as MM. */
  expirationMonth: Scalars['String'];
  /** The year of the credit card expiration as YYYY. */
  expirationYear: Scalars['String'];
};

/** Input fields for searching for payments by payment method snapshot credit card number criteria. */
export type SearchCreditCardNumberInput = {
  /** Up to four digits of the last four digits of the credit card number. */
  endsWith?: InputMaybe<Scalars['String']>;
  /** Up to the first six digits of the credit card number (the credit card's BIN). */
  startsWith?: InputMaybe<Scalars['String']>;
};

/** Input fields for searching for a date. These ranges are precise to the day. */
export type SearchDateInput = {
  /** Date is greater than or equal to this value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Date']>;
  /** Date is less than or equal to this value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Date']>;
};

/** Input fields for searching for a dispute with a given protection level. */
export type SearchDisputeProtectionLevelInput = {
  /** The dispute's protection level is one of these values. */
  in?: InputMaybe<Array<DisputeProtectionLevel>>;
  /** The dispute's protection level is exactly this value. */
  is?: InputMaybe<DisputeProtectionLevel>;
};

/** Input fields for searching for a dispute with a given reason description. */
export type SearchDisputeReasonInput = {
  /** The dispute reason is one of these values. */
  in?: InputMaybe<Array<DisputeReason>>;
};

/** Input fields for searching for a dispute with a given status. */
export type SearchDisputeStatusInput = {
  /** The dispute status is one of these values. */
  in?: InputMaybe<Array<DisputeStatus>>;
  /** The dispute status is exactly this value. */
  is?: InputMaybe<DisputeStatus>;
};

/** Input fields for searching for a dispute with a given type. */
export type SearchDisputeTypeInput = {
  /** The dispute type is one of these values. */
  in?: InputMaybe<Array<DisputeType>>;
  /** The dispute type is exactly this value. */
  is?: InputMaybe<DisputeType>;
};

/** Input fields for searching for payments by payment method snapshot credit card details criteria. */
export type SearchPaymentCreditCardDetailsInput = {
  /** The brand code of the credit card number used for the payment. */
  brandCode?: InputMaybe<SearchCreditCardBrandCodeInput>;
  /** The card holder name of the credit card number used for the payment. */
  cardholderName?: InputMaybe<SearchTextInput>;
  /** Find payments based on the expiration date of the credit card used for the payment. */
  expirationDate?: InputMaybe<SearchCreditCardExpirationDateInput>;
  /** The credit card number used for the payment. */
  number?: InputMaybe<SearchCreditCardNumberInput>;
  /** The unique identifier of the credit card number used for the payment. */
  uniqueNumberIdentifier?: InputMaybe<SearchTextInput>;
};

/** Input fields for searching payments by customer. */
export type SearchPaymentCustomerInput = {
  /** Find payments with a given customer company. */
  company?: InputMaybe<SearchTextInput>;
  /** Find payments with a customer email. */
  email?: InputMaybe<SearchTextInput>;
  /** Find payments with a given first name. */
  firstName?: InputMaybe<SearchTextInput>;
  /** Find payments with a given customer ID. */
  id?: InputMaybe<SearchValueInput>;
  /** Find payments with a given last name. */
  lastName?: InputMaybe<SearchTextInput>;
};

/** Input fields for searching transactions by payment method snapshot type. */
export type SearchPaymentMethodSnapshotTypeInput = {
  /** These values represent the payment method type used to create a transaction. In the case of credit cards, these values also encode the origin from which a customer provided that payment method. */
  in?: InputMaybe<Array<PaymentMethodSnapshotSearchType>>;
  /** This value represents the payment method type used to create a transaction. In the case of credit cards, this value also encode the origin from which a customer provided that payment method. */
  is?: InputMaybe<PaymentMethodSnapshotSearchType>;
};

/** Input fields for searching for payments by payment method snapshot PayPal details criteria. */
export type SearchPaymentPayPalDetailsInput = {
  /** "The email address of the PayPal payer. */
  email?: InputMaybe<SearchTextInput>;
};

/** Input fields for searching for payments by payment method criteria. */
export type SearchPaymentPaymentMethodInput = {
  /** The ID of the vaulted payment method used for the payment. */
  paymentMethodId?: InputMaybe<SearchValueInput>;
  /** The snapshot of the payment method at the time of payment creation. */
  paymentMethodSnapshot?: InputMaybe<SearchPaymentPaymentMethodSnapshotInput>;
};

/** Input fields for searching for payments by payment method snapshot criteria. */
export type SearchPaymentPaymentMethodSnapshotInput = {
  /** Find payments made with credit cards, based on the details of the credit card used for the payment. Passing an object with non-empty, non-null fields will scope your search to *only* credit card payment methods. This overrides the `type` field. */
  creditCardDetails?: InputMaybe<SearchPaymentCreditCardDetailsInput>;
  /** Find payments made with PayPal, based on the PayPal details used for the payment. Passing a value here will scope your search to *only* PayPal payment methods. This overrides the `type` field. */
  payPalDetails?: InputMaybe<SearchPaymentPayPalDetailsInput>;
  /** Find SEPA payments with SEPA details. Passing a value here will scope your search to *only* SEPA Direct Debit payment methods. This overrides the `type` field. */
  sepaDirectDebitDetails?: InputMaybe<SearchPaymentSepaDirectDebitDetailsInput>;
  /** Find payments based on the payment instrument type. */
  type?: InputMaybe<SearchPaymentMethodSnapshotTypeInput>;
};

/** Input field for searching for payments by payment method snapshot SEPA Direct Debit details criteria. */
export type SearchPaymentSepaDirectDebitDetailsInput = {
  /** PayPal V2 OrderId. */
  paymentId?: InputMaybe<SearchValueInput>;
};

/** Input fields for searching for a transaction or refund created with a given source. */
export type SearchPaymentSourceInput = {
  /** The transaction source is one of these values. */
  in?: InputMaybe<Array<PaymentSource>>;
};

/** Input fields for searching for a transaction or refund with a given status. */
export type SearchPaymentStatusInput = {
  /** The transaction status is one of these values. */
  in?: InputMaybe<Array<PaymentStatus>>;
};

/** Payment status transition times. */
export type SearchPaymentStatusTransitionInput = {
  /** Find transactions with a given authorization expired at time. */
  authorizationExpiredAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given authorized at time. */
  authorizedAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given failed at time. */
  failedAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given gateway rejected at time. */
  gatewayRejectedAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given processor declined at time. */
  processorDeclinedAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given settled at time. */
  settledAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given submitted for settlement time. */
  submittedForSettlementAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given voided at time. */
  voidedAt?: InputMaybe<SearchTimestampInput>;
};

/** Input fields for searching for payments by implementing type. */
export type SearchPaymentTypeInput = {
  /** The payment is a transaction and/or a refund. */
  in?: InputMaybe<Array<PaymentSearchType>>;
};

/** Input fields for searching for a dispute with a given pre-dispute program. */
export type SearchPreDisputeProgramInput = {
  /** The dispute's pre-dispute program is one of these values. */
  in?: InputMaybe<Array<PreDisputeProgram>>;
  /** The dispute's pre-dispute program is exactly this value. */
  is?: InputMaybe<PreDisputeProgram>;
};

/** Input fields for searching for a range. */
export type SearchRangeInput = {
  /** Field is greater than or equal to this value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']>;
  /** Field is exactly this value. */
  is?: InputMaybe<Scalars['String']>;
  /** Field is less than or equal to this value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']>;
};

/** Input fields for searching for a version number. */
export type SearchSoftwareVersionInput = {
  /** Field contains this value. */
  contains?: InputMaybe<Scalars['String']>;
  /** Field is exactly this value. */
  is?: InputMaybe<Scalars['String']>;
  /** Field is not this value. */
  isNot?: InputMaybe<Scalars['String']>;
  /** Field starts with this value. */
  startsWith?: InputMaybe<Scalars['String']>;
};

/** Input fields for searching text fields. */
export type SearchTextInput = {
  /** Field contains this value. */
  contains?: InputMaybe<Scalars['String']>;
  /** Field ends with this value. */
  endsWith?: InputMaybe<Scalars['String']>;
  /** Field is exactly this value. */
  is?: InputMaybe<Scalars['String']>;
  /** Field is not this value. */
  isNot?: InputMaybe<Scalars['String']>;
  /** Field starts with this value. */
  startsWith?: InputMaybe<Scalars['String']>;
};

/** Input fields for searching by timestamp. These ranges are precise to the minute; the results of searching for an object created between 12/17/2015 17:00 and 12/17/2015 17:00 (i.e., the same minute) will include objects created at 12/17/2015 17:00:59. If no timezone is provided, it will be assumed to be UTC. */
export type SearchTimestampInput = {
  /** Timestamp is greater than or equal to this value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Timestamp']>;
  /** Timestamp is less than or equal to this value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Timestamp']>;
};

/** Input fields for searching for a transaction created with a given source. */
export type SearchTransactionSourceInput = {
  /** The transaction source is one of these values. */
  in?: InputMaybe<Array<PaymentSource>>;
};

/** Input fields for searching for a transaction with a given status. */
export type SearchTransactionStatusInput = {
  /** The transaction status is one of these values. */
  in?: InputMaybe<Array<PaymentStatus>>;
  /** The transaction status is exactly this value. */
  is?: InputMaybe<PaymentStatus>;
};

/** Transaction status transition times. */
export type SearchTransactionStatusTransitionInput = {
  /** Find transactions with a given failed at time. */
  failedAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given settled at time. */
  settledAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given submitted for settlement time. */
  submittedForSettlementAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given voided at time. */
  voidedAt?: InputMaybe<SearchTimestampInput>;
};

/** Input fields for searching for specific values. */
export type SearchValueInput = {
  /** Field is one of these values. */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Field is exactly this value. */
  is?: InputMaybe<Scalars['String']>;
};

/** Input fields for searching for a verification with a given status. */
export type SearchVerificationStatusInput = {
  /** The verification status is one of these values. */
  in?: InputMaybe<Array<VerificationStatus>>;
  /** The verification status is exactly this value. */
  is?: InputMaybe<VerificationStatus>;
};

/** Details about a selected financing option by a PayPal buyer. */
export type SelectedPayPalFinancingOptionDetails = {
  __typename?: 'SelectedPayPalFinancingOptionDetails';
  /** The amount reduced from the total transaction amount. */
  discountAmount?: Maybe<MonetaryAmount>;
  /** The percent discount off the total transaction amount due to the selected financing option. */
  discountPercentage?: Maybe<Scalars['Percentage']>;
  /** The amount for each monthly payment. */
  monthlyPayment?: Maybe<MonetaryAmount>;
  /** Total number of payments over which to finance the transaction. */
  term?: Maybe<Scalars['Int']>;
};

/** Input fields indicating a selected financing option by a PayPal buyer. */
export type SelectedPayPalFinancingOptionInput = {
  /** The currency code for the monthly payment and discount amount. */
  currencyCode: Scalars['CurrencyCodeAlpha'];
  /** The amount reduced from the total transaction amount. */
  discountAmount?: InputMaybe<Scalars['Amount']>;
  /** The percent discount off the total transaction amount due to the selected financing option. */
  discountPercentage?: InputMaybe<Scalars['Percentage']>;
  /** The amount for each monthly payment. */
  monthlyPayment: Scalars['Amount'];
  /** Total number of payments over which to finance the transaction. */
  term: Scalars['Int'];
};

/** Accompanying information for a settled transaction. */
export type SettledEvent = PaymentStatusEvent & {
  __typename?: 'SettledEvent';
  /** The amount the transaction was settled for, in the same currency as the original authorization (aka the "presentment" currency.) If you have elected to settle the transaction into a bank account with a different currency, this will not reflect that. */
  amount?: Maybe<MonetaryAmount>;
  /** Fields describing the payment processor response. */
  processorResponse?: Maybe<TransactionSettlementProcessorResponse>;
  /** The ID of the settlement batch in which the transaction was processed. */
  settlementBatchId?: Maybe<Scalars['String']>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the transaction was settled. */
  timestamp?: Maybe<Scalars['Timestamp']>;
};

/** Accompanying information for a settlement confirmed transaction. */
export type SettlementConfirmedEvent = PaymentStatusEvent & {
  __typename?: 'SettlementConfirmedEvent';
  /** The amount of the transaction for this status event. */
  amount?: Maybe<MonetaryAmount>;
  /** Fields describing the payment processor response to the settlement request. */
  processorResponse?: Maybe<TransactionSettlementProcessorResponse>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the transaction became settlement confirmed. */
  timestamp?: Maybe<Scalars['Timestamp']>;
};

/** Accompanying information for a settlement declined transaction. */
export type SettlementDeclinedEvent = PaymentStatusEvent & {
  __typename?: 'SettlementDeclinedEvent';
  /** The amount of the transaction for this status event. */
  amount?: Maybe<MonetaryAmount>;
  /** Fields describing the payment processor response to the settlement request. */
  processorResponse?: Maybe<TransactionSettlementProcessorResponse>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the processor declined to settle this transaction. */
  timestamp?: Maybe<Scalars['Timestamp']>;
};

/** Accompanying information for a settlement pending transaction. This typically only occurs for PayPal transactions. */
export type SettlementPendingEvent = PaymentStatusEvent & {
  __typename?: 'SettlementPendingEvent';
  /** The amount of the transaction for this status event. */
  amount?: Maybe<MonetaryAmount>;
  /** Fields describing the payment processor response to the settlement request. */
  processorResponse?: Maybe<TransactionSettlementProcessorResponse>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the transaction became settlement pending. */
  timestamp?: Maybe<Scalars['Timestamp']>;
  /** User name of the person who performed an action that triggered the status change of the transaction. */
  userName?: Maybe<Scalars['String']>;
};

/** Accompanying information for a transaction that is settling. This is typically a transient state during which the transaction is being settled with the processor. */
export type SettlingEvent = PaymentStatusEvent & {
  __typename?: 'SettlingEvent';
  /** The amount of the transaction for this status event. This should match the amount submitted for settlement. */
  amount?: Maybe<MonetaryAmount>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the transaction began settling. */
  timestamp?: Maybe<Scalars['Timestamp']>;
};

/** Accompanying information for a transaction that is submitted for settlement. This status indicates that the transaction is scheduled to be settled. */
export type SubmittedForSettlementEvent = PaymentStatusEvent & {
  __typename?: 'SubmittedForSettlementEvent';
  /** The amount that was submitted for settlement. This can differ from the authorized amount, but by default is the same. */
  amount?: Maybe<MonetaryAmount>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the transaction was submitted for settlement. */
  timestamp?: Maybe<Scalars['Timestamp']>;
  /** User name of the person who performed an action that triggered the status change of the transaction. */
  userName?: Maybe<Scalars['String']>;
};

/** Input fields for local payment tax information. */
export type TaxInfoInput = {
  /** The payer's tax identifier value. */
  identifier: Scalars['String'];
  /** The payer's tax identifier type. */
  type: TaxInfoType;
};

/** The type of tax identifier. */
export enum TaxInfoType {
  BrCnpj = 'BR_CNPJ',
  BrCpf = 'BR_CPF'
}

/** Information about the 3D Secure authentication for a payment method. */
export type ThreeDSecureAuthentication = {
  __typename?: 'ThreeDSecureAuthentication';
  /** A unique identifier for the 3D Secure interaction with the access control server. */
  acsTransactionId?: Maybe<Scalars['String']>;
  /** The 3D Secure authentication status of the card. */
  authenticationStatus?: Maybe<ThreeDSecureAuthenticationStatus>;
  /** Indicates whether the card is enrolled in a 3D Secure program. */
  cardEnrolled?: Maybe<ThreeDSecureCardEnrolled>;
  /** The cardholder authentication verification value. This value should be appended to the authorization message signifying that the transaction has been successfully authenticated with 3D Secure. This value will be encoded according to the merchant's configuration with CardinalCommerce, with either Base64 or Hex encoding. The decoded value will be of different length and format per card scheme. */
  cavv?: Maybe<Scalars['String']>;
  /** A unique identifier for the 3D Secure interaction with the card brand directory server. */
  directoryServerTransactionId?: Maybe<Scalars['String']>;
  /** The electronic commerce indicator. */
  eciFlag?: Maybe<Scalars['ECommerceIndicator']>;
  /** A boolean indicating if the card is eligible for liability shift. */
  liabilityShiftPossible?: Maybe<Scalars['Boolean']>;
  /** A boolean indicating if the card has received liability shift. */
  liabilityShifted?: Maybe<Scalars['Boolean']>;
  /** Indicates the current status of the 3D Secure authentication from the 3D Secure server for 3D Secure 1.0 authentications. */
  paresStatus?: Maybe<ThreeDSecureAuthenticationStatusIndicator>;
  /** A unique identifier for the 3D Secure interaction with the 3D Secure server. */
  threeDSecureServerTransactionId?: Maybe<Scalars['String']>;
  /** Indicates the current status of the 3D Secure authentication from the 3D Secure server for 3D Secure 2.0 authentications. */
  transactionStatus?: Maybe<ThreeDSecureAuthenticationStatusIndicator>;
  /** Indicates the reason for the transaction status. This will be null if status is `SUCCESSFUL_AUTHENTICATION`. */
  transactionStatusReason?: Maybe<Scalars['String']>;
  /** The version of the 3D Secure protocol used during authentication. */
  version?: Maybe<Scalars['String']>;
  /** A unique identifier for the 3D Secure interaction with the provider. */
  xId?: Maybe<Scalars['String']>;
};

/** An override field that a merchant can pass in to set the challenge window size to display to the end cardholder. The ACS will reply with content that is formatted appropriately to this window size to allow for the best user experience. The sizes are width x height in pixels of the window displayed in the cardholder browser window. */
export enum ThreeDSecureAuthenticationAcsWindowSize {
  FullPage = 'FULL_PAGE',
  W250H400 = 'W250_H400',
  W390H400 = 'W390_H400',
  W500H600 = 'W500_H600',
  W600H400 = 'W600_H400'
}

/** Indicates the delivery timeframe if applicable. */
export enum ThreeDSecureAuthenticationDeliveryTimeframe {
  ElectronicDelivery = 'ELECTRONIC_DELIVERY',
  OvernightShipping = 'OVERNIGHT_SHIPPING',
  SameDayShipping = 'SAME_DAY_SHIPPING',
  TwoOrMoreDayShipping = 'TWO_OR_MORE_DAY_SHIPPING'
}

/** Input fields for passing auxillary 3D Secure information manually, as opposed to tokenized on a single-use payment method ID. */
export type ThreeDSecureAuthenticationInput = {
  /** Braintree unique ID of the 3D Secure authentication performed for this transaction. You will only need to use this field if you are charging or authorizing a vaulted payment method ID. */
  authenticationId?: InputMaybe<Scalars['String']>;
  /** Results of a merchant-performed 3D Secure authentication. You will only need to use these fields if you've performed your own integration with a 3D Secure MPI provider (e.g. Cardinal Centinel). Otherwise, Braintree's SDKs handle this for you in our standard 3D Secure integration. */
  passThrough?: InputMaybe<ThreeDSecurePassThroughInput>;
  /** Specify whether to require 3D Secure verification to succeed before creating a transaction. Defaults to true for transactions sent through 3D Secure verification but to false for transactions not sent through 3D Secure verification. */
  required?: InputMaybe<Scalars['Boolean']>;
};

/** Merchant product code. */
export enum ThreeDSecureAuthenticationMerchantProductCode {
  AccommodationRetail = 'ACCOMMODATION_RETAIL',
  Airline = 'AIRLINE',
  CarRental = 'CAR_RENTAL',
  CashDispensing = 'CASH_DISPENSING',
  DigitalGoods = 'DIGITAL_GOODS',
  Fuel = 'FUEL',
  GeneralRetail = 'GENERAL_RETAIL',
  LuxuryRetail = 'LUXURY_RETAIL',
  Other = 'OTHER',
  Restaurant = 'RESTAURANT',
  Services = 'SERVICES',
  Travel = 'TRAVEL'
}

/** Indicates the shipping type for the transaction. */
export enum ThreeDSecureAuthenticationShippingType {
  DigitalGoods = 'DIGITAL_GOODS',
  Other = 'OTHER',
  ShipToAddressOnFile = 'SHIP_TO_ADDRESS_ON_FILE',
  ShipToBillingAddress = 'SHIP_TO_BILLING_ADDRESS',
  ShipToOtherAddress = 'SHIP_TO_OTHER_ADDRESS',
  ShipToStore = 'SHIP_TO_STORE',
  TicketsNotShipped = 'TICKETS_NOT_SHIPPED'
}

/** The 3D Secure authentication status of the card. */
export enum ThreeDSecureAuthenticationStatus {
  AuthenticateAttemptSuccessful = 'AUTHENTICATE_ATTEMPT_SUCCESSFUL',
  AuthenticateError = 'AUTHENTICATE_ERROR',
  AuthenticateFailed = 'AUTHENTICATE_FAILED',
  AuthenticateFailedAcsError = 'AUTHENTICATE_FAILED_ACS_ERROR',
  AuthenticateFrictionlessFailed = 'AUTHENTICATE_FRICTIONLESS_FAILED',
  AuthenticateRejected = 'AUTHENTICATE_REJECTED',
  AuthenticateSignatureVerificationFailed = 'AUTHENTICATE_SIGNATURE_VERIFICATION_FAILED',
  AuthenticateSuccessful = 'AUTHENTICATE_SUCCESSFUL',
  /** @deprecated No longer applicable. */
  AuthenticateSuccessfulIssuerNotParticipating = 'AUTHENTICATE_SUCCESSFUL_ISSUER_NOT_PARTICIPATING',
  AuthenticateUnableToAuthenticate = 'AUTHENTICATE_UNABLE_TO_AUTHENTICATE',
  AuthenticationBypassed = 'AUTHENTICATION_BYPASSED',
  AuthenticationUnavailable = 'AUTHENTICATION_UNAVAILABLE',
  ChallengeRequired = 'CHALLENGE_REQUIRED',
  DataOnlySuccessful = 'DATA_ONLY_SUCCESSFUL',
  LookupBypassed = 'LOOKUP_BYPASSED',
  LookupCardError = 'LOOKUP_CARD_ERROR',
  LookupEnrolled = 'LOOKUP_ENROLLED',
  LookupError = 'LOOKUP_ERROR',
  LookupFailedAcsError = 'LOOKUP_FAILED_ACS_ERROR',
  LookupNotEnrolled = 'LOOKUP_NOT_ENROLLED',
  LookupServerError = 'LOOKUP_SERVER_ERROR',
  UnsupportedAccountType = 'UNSUPPORTED_ACCOUNT_TYPE',
  UnsupportedCard = 'UNSUPPORTED_CARD',
  UnsupportedThreeDSecureVersion = 'UNSUPPORTED_THREE_D_SECURE_VERSION'
}

/** Indicates the current status of the 3D Secure authentication. */
export enum ThreeDSecureAuthenticationStatusIndicator {
  AuthenticationRejected = 'AUTHENTICATION_REJECTED',
  ChallengeRequiredDecoupledAuthentication = 'CHALLENGE_REQUIRED_DECOUPLED_AUTHENTICATION',
  ChallengeRequiredForAuthentication = 'CHALLENGE_REQUIRED_FOR_AUTHENTICATION',
  FailedAuthentication = 'FAILED_AUTHENTICATION',
  InformationalChallengePreferenceAcknowledged = 'INFORMATIONAL_CHALLENGE_PREFERENCE_ACKNOWLEDGED',
  SuccessfulAttemptsTransaction = 'SUCCESSFUL_ATTEMPTS_TRANSACTION',
  SuccessfulAuthentication = 'SUCCESSFUL_AUTHENTICATION',
  UnableToCompleteAuthentication = 'UNABLE_TO_COMPLETE_AUTHENTICATION'
}

/** Indicates the type of transaction for 3D Secure authentication. */
export enum ThreeDSecureAuthenticationTransactionType {
  AddCard = 'ADD_CARD',
  CardholderVerification = 'CARDHOLDER_VERIFICATION',
  Installment = 'INSTALLMENT',
  MaintainCard = 'MAINTAIN_CARD',
  Payment = 'PAYMENT',
  Recurring = 'RECURRING'
}

/** Indicates whether the card is enrolled in a 3D Secure program. */
export enum ThreeDSecureCardEnrolled {
  /** Authentication has been bypassed. This status will be returned if you set up bypass rules with CardinalCommerce, and they are triggered. */
  Bypass = 'BYPASS',
  /** There was an error in determining whether the card is enrolled in a 3D Secure program. */
  Error = 'ERROR',
  /** The card is not enrolled. */
  No = 'NO',
  /** The DS (directory server) or ACS (access control server) is not available for authentication at the time of the request. */
  Unavailable = 'UNAVAILABLE',
  /** The card is enrolled. */
  Yes = 'YES'
}

/** Configuration for 3D Secure. */
export type ThreeDSecureConfiguration = {
  __typename?: 'ThreeDSecureConfiguration';
  /** Authentication information for initializing Cardinal's songbird.js library. */
  cardinalAuthenticationJWT?: Maybe<Scalars['String']>;
};

/** 3D Secure information for the payment method. */
export type ThreeDSecureDetails = {
  __typename?: 'ThreeDSecureDetails';
  /**
   * A unique identifier for the 3D Secure interaction with the access control server.
   * @deprecated Use ThreeDSecureDetails.authentication.acsTransactionId instead.
   */
  acsTransactionId?: Maybe<Scalars['String']>;
  /** Contains relevant data fields if the payment method has been authenticated using 3D Secure. Only available on 3D Secure authenticated single-use payment methods and 3D Secure paymentMethodSnapshots. */
  authentication?: Maybe<ThreeDSecureAuthentication>;
  /** Information about the [customer authentication regulation environment](https://developers.braintreepayments.com/guides/3d-secure/migration/javascript/v3#authentication-insight) that applies to the payment method when processed with the provided merchant account. This can be used to determine whether to perform 3D Secure authentication. */
  authenticationInsight?: Maybe<AuthenticationInsight>;
  /**
   * The 3D Secure authentication status of the card.
   * @deprecated Use ThreeDSecureDetails.authentication.authenticationStatus instead.
   */
  authenticationStatus?: Maybe<ThreeDSecureAuthenticationStatus>;
  /**
   * Indicates whether the card is enrolled in a 3D Secure program.
   * @deprecated Use ThreeDSecureDetails.authentication.cardEnrolled instead.
   */
  cardEnrolled?: Maybe<ThreeDSecureCardEnrolled>;
  /**
   * The cardholder authentication verification value. This value should be appended to the authorization message signifying that the transaction has been successfully authenticated with 3D Secure. This value will be encoded according to the merchant's configuration with CardinalCommerce, with either Base64 or Hex encoding. The decoded value will be of different length and format per card scheme.
   * @deprecated Use ThreeDSecureDetails.authentication.cavv instead.
   */
  cavv?: Maybe<Scalars['String']>;
  /**
   * A unique identifier for the 3D Secure interaction with the card brand directory server.
   * @deprecated Use ThreeDSecureDetails.authentication.directoryServerTransactionId instead.
   */
  directoryServerTransactionId?: Maybe<Scalars['String']>;
  /**
   * The electronic commerce indicator.
   * @deprecated Use ThreeDSecureDetails.authentication.eciFlag instead.
   */
  eciFlag?: Maybe<Scalars['ECommerceIndicator']>;
  /**
   * A boolean indicating if the card is eligible for liability shift.
   * @deprecated Use ThreeDSecureDetails.authentication.liabilityShiftPossible instead.
   */
  liabilityShiftPossible?: Maybe<Scalars['Boolean']>;
  /**
   * A boolean indicating if the card has received liability shift.
   * @deprecated Use ThreeDSecureDetails.authentication.liabilityShifted instead.
   */
  liabilityShifted?: Maybe<Scalars['Boolean']>;
  /**
   * Indicates the current status of the 3D Secure authentication from the 3D Secure server for 3D Secure 1.0 authentications.
   * @deprecated Use ThreeDSecureDetails.authentication.paresStatus instead.
   */
  paresStatus?: Maybe<ThreeDSecureAuthenticationStatusIndicator>;
  /**
   * A unique identifier for the 3D Secure interaction with the 3D Secure server.
   * @deprecated Use ThreeDSecureDetails.authentication.threeDSecureServerTransactionId instead.
   */
  threeDSecureServerTransactionId?: Maybe<Scalars['String']>;
  /**
   * Indicates the current status of the 3D Secure authentication from the 3D Secure server for 3D Secure 2.0 authentications.
   * @deprecated Use ThreeDSecureDetails.authentication.transactionStatus instead.
   */
  transactionStatus?: Maybe<ThreeDSecureAuthenticationStatusIndicator>;
  /**
   * Indicates the reason for the transaction status. This will be null if status is `SUCCESSFUL_AUTHENTICATION`.
   * @deprecated Use ThreeDSecureDetails.authentication.transactionStatusReason instead.
   */
  transactionStatusReason?: Maybe<Scalars['String']>;
  /**
   * The version of the 3D Secure protocol used during authentication.
   * @deprecated Use ThreeDSecureDetails.authentication.version instead.
   */
  version?: Maybe<Scalars['String']>;
  /**
   * A unique identifier for the 3D Secure interaction with the provider.
   * @deprecated Use ThreeDSecureDetails.authentication.xId instead.
   */
  xId?: Maybe<Scalars['String']>;
};


/** 3D Secure information for the payment method. */
export type ThreeDSecureDetailsAuthenticationInsightArgs = {
  input: AuthenticationInsightInput;
};

/**  The billing address of the cardholder sent with 3D Secure Lookup requests. */
export type ThreeDSecureLookupBillingAddressInput = {
  /** Country code of billing address used for verification. */
  countryCode?: InputMaybe<Scalars['String']>;
  /** The given (first) name associated with the billing address used for verification. */
  givenName?: InputMaybe<Scalars['String']>;
  /** Line 1 of the billing address used for verification. */
  line1?: InputMaybe<Scalars['String']>;
  /** Line 2 of the billing address used for verification. */
  line2?: InputMaybe<Scalars['String']>;
  /** Line 3 of the billing address used for verification. */
  line3?: InputMaybe<Scalars['String']>;
  /** City or locality of billing address used for verification. */
  locality?: InputMaybe<Scalars['String']>;
  /** The billing phone number used for verification. */
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** Postal code of billing address used for verification. */
  postalCode?: InputMaybe<Scalars['String']>;
  /** State or region of billing address used for verification. */
  region?: InputMaybe<Scalars['String']>;
  /** The surname (last name) associated with the billing address used for verification. */
  surname?: InputMaybe<Scalars['String']>;
};

/** Additional information about the cardholder when authenticating through 3D Secure. */
export type ThreeDSecureLookupCardholderInformationInput = {
  /** The billing address of the cardholder. */
  billingAddress?: InputMaybe<ThreeDSecureLookupBillingAddressInput>;
};

/** Information about the client side lookup process. */
export type ThreeDSecureLookupClientInformationInput = {
  /** Number of milliseconds taken for the issuer to collect device data. */
  issuerDeviceDataCollectionMillisecondsElapsed?: InputMaybe<Scalars['Int']>;
  /** Whether device data collection by the issuer succeeded. */
  issuerDeviceDataCollectionResult?: InputMaybe<Scalars['Boolean']>;
  /** Version of 3D Secure requested when performing the lookup. */
  requestedThreeDSecureVersion?: InputMaybe<Scalars['String']>;
  /** Version of the Braintree client-side SDK being used. */
  sdkVersion?: InputMaybe<Scalars['String']>;
  /** Number of milliseconds taken for the 3D Secure server to collect device data. */
  threeDSecureServerDeviceDataCollectionMillisecondsElapsed?: InputMaybe<Scalars['Int']>;
};

/** Data fields containing information from the MPI provider about the 3D Secure Lookup result. */
export type ThreeDSecureLookupData = {
  __typename?: 'ThreeDSecureLookupData';
  /** The URL to use to issue a challenge to the cardholder for 3D Secure authentication. */
  acsUrl?: Maybe<Scalars['String']>;
  /** Braintree unique ID of the 3D Secure authentication performed for this transaction. You will only need to use this field if you are charging or authorizing a vaulted payment method ID. */
  authenticationId?: Maybe<Scalars['String']>;
  /** The unique 3D Secure identifier assigned by Braintree to track the 3D Secure call as it progresses. */
  md?: Maybe<Scalars['String']>;
  /** The "PAReq" or "Payment Authentication Request" is the encoded request message used to initiate authentication. */
  pareq?: Maybe<Scalars['String']>;
  /** A fully qualified URL that the customer will be redirected to once the authentication completes. */
  termUrl?: Maybe<Scalars['String']>;
  /** A unique identifier used by the MPI provider to identify the 3D Secure interaction. The MPI provider provides the framework for determining if a card is enrolled in a 3D Secure program and for facilitating interactions with the issuer. */
  transactionId?: Maybe<Scalars['String']>;
  /** The version of the 3D Secure protocol used in the authentication. */
  version?: Maybe<Scalars['String']>;
};

/**  The shipping address of the transaction to be sent with 3D Secure Lookup requests. */
export type ThreeDSecureLookupShippingAddressInput = {
  /** Country code of shipping address used for verification. */
  countryCode?: InputMaybe<Scalars['String']>;
  /** The given (first) name associated with the shipping address used for verification. */
  givenName?: InputMaybe<Scalars['String']>;
  /** Line 1 of the shipping address used for verification. */
  line1?: InputMaybe<Scalars['String']>;
  /** Line 2 of the shipping address used for verification. */
  line2?: InputMaybe<Scalars['String']>;
  /** Line 3 of the shipping address used for verification. */
  line3?: InputMaybe<Scalars['String']>;
  /** City or locality of shipping address used for verification. */
  locality?: InputMaybe<Scalars['String']>;
  /** The shipping phone number used for verification. */
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** Postal code of shipping address used for verification. */
  postalCode?: InputMaybe<Scalars['String']>;
  /** State or region of shipping address used for verification. */
  region?: InputMaybe<Scalars['String']>;
  /** The surname (last name) associated with the shipping address used for verification. */
  surname?: InputMaybe<Scalars['String']>;
};

/** Indicates the shipping method chosen for the transaction in the 3D Secure lookup. */
export enum ThreeDSecureLookupShippingMethod {
  ElectronicDelivery = 'ELECTRONIC_DELIVERY',
  Ground = 'GROUND',
  OvernightExpedited = 'OVERNIGHT_EXPEDITED',
  Priority = 'PRIORITY',
  SameDay = 'SAME_DAY',
  ShipToStore = 'SHIP_TO_STORE'
}

/** Additional information about the transaction when authenticating through 3D Secure. */
export type ThreeDSecureLookupTransactionInformationInput = {
  /** Date the cardholder's account was last changed. This includes changes to the billing or shipping address, new payment accounts or new users added. */
  accountChangeDate?: InputMaybe<Scalars['Date']>;
  /** Indicates whether the cardholder changed the account during this transaction. This includes changes to the billing or shipping address, new payment accounts or new users added. */
  accountChangedDuringTransaction?: InputMaybe<Scalars['Boolean']>;
  /** Date the cardholder opened the account. */
  accountCreateDate?: InputMaybe<Scalars['Date']>;
  /** Indicates whether the cardholder created the account during this transaction. */
  accountCreatedDuringTransaction?: InputMaybe<Scalars['Boolean']>;
  /** Additional cardholder account information. */
  accountId?: InputMaybe<Scalars['String']>;
  /** Indicates if the cardholder name on the account is identical to the shipping name used for the transaction. */
  accountNameMatchesShippingName?: InputMaybe<Scalars['Boolean']>;
  /** Date the cardholder changed or reset the password on the account. */
  accountPasswordChangeDate?: InputMaybe<Scalars['Date']>;
  /** Indicates whether the cardholder changed or reset the password on the account during this transaction. */
  accountPasswordChangedDuringTransaction?: InputMaybe<Scalars['Boolean']>;
  /** Number of purchases with this cardholder account during the previous six months. */
  accountPurchases?: InputMaybe<Scalars['Int']>;
  /** An override field that a merchant can pass in to set the challenge window size to display to the end cardholder. The ACS will reply with content that is formatted appropriately to this window size to allow for the best user experience. The sizes are width x height in pixels of the window displayed in the cardholder browser window. */
  acsWindowSize?: InputMaybe<ThreeDSecureAuthenticationAcsWindowSize>;
  /** Number of attempts that have been made to add a card to this account in the last 24 hours. */
  addCardAttempts?: InputMaybe<Scalars['Int']>;
  /** Indicates whether cardholder billing and shipping addresses match. */
  billingAddressMatchesShippingAddress?: InputMaybe<Scalars['Boolean']>;
  /** For electronic delivery, email address to which the product was delivered. */
  deliveryEmail?: InputMaybe<Scalars['String']>;
  /** Indicates the delivery timeframe if applicable. */
  deliveryTimeframe?: InputMaybe<ThreeDSecureAuthenticationDeliveryTimeframe>;
  /** The email associated with the transaction. */
  email?: InputMaybe<Scalars['String']>;
  /** Indicates whether this transaction represents the first use of this shipping address. */
  firstUseOfShippingAddress?: InputMaybe<Scalars['Boolean']>;
  /** The purchase amount total for prepaid gift cards. */
  giftCardAmount?: InputMaybe<Scalars['Amount']>;
  /** Total count of individual prepaid gift cards purchased. */
  giftCardCount?: InputMaybe<Scalars['Int']>;
  /** ISO 4217 currency code for the gift card purchased. */
  giftCardCurrencyCode?: InputMaybe<Scalars['CurrencyCodeAlpha']>;
  /** Indicates the maximum number of authorizations for installment payments. An integer value greater than 1 indicating the maximum number of permitted authorizations for installment payments. */
  installment?: InputMaybe<Scalars['Int']>;
  /** The IP address of the cardholder. Both IPv4 and IPv6 formats are supported. */
  ipAddress?: InputMaybe<Scalars['String']>;
  /** Brief Description of items purchased. */
  orderDescription?: InputMaybe<Scalars['String']>;
  /** Indicates whether the payment method was added to the cardholder account during this transaction. */
  paymentMethodAddedDuringTransaction?: InputMaybe<Scalars['Boolean']>;
  /** Date the payment method was added to the cardholder account. */
  paymentMethodAddedToAccountDate?: InputMaybe<Scalars['Date']>;
  /** The phone number associated with the transaction. */
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** Expected date that a pre-ordered purchase will be available. */
  preorderDate?: InputMaybe<Scalars['Date']>;
  /** Indicates whether cardholder is placing an order with a future availability or release date. */
  preorderIndicator?: InputMaybe<Scalars['Boolean']>;
  /** Merchant product code. */
  productCode?: InputMaybe<ThreeDSecureAuthenticationMerchantProductCode>;
  /** Datetime of original purchase. */
  purchaseDate?: InputMaybe<Scalars['Timestamp']>;
  /** The date after which no further recurring authorizations should be performed. */
  recurringEnd?: InputMaybe<Scalars['Date']>;
  /** Integer value indicating the minimum number of days between recurring authorizations. A frequency of monthly is indicated by the value 28. Multiple of 28 days will be used to indicate months. Example: 6 months = 168. */
  recurringFrequency?: InputMaybe<Scalars['Int']>;
  /** Indicates whether the cardholder is reordering merchandise purchased in a previous order. */
  reorderIndicator?: InputMaybe<Scalars['Boolean']>;
  /** This field indicates the maximum amount of time for all 3DS 2.0 messages to be communicated between all components (in minutes). Minimum is 05. Defaults to 15. */
  sdkMaxTimeout?: InputMaybe<Scalars['Int']>;
  /** The shipping address for the transaction. */
  shippingAddress?: InputMaybe<ThreeDSecureLookupShippingAddressInput>;
  /** Date when the shipping address used for this transaction was first used. */
  shippingAddressFirstUsageDate?: InputMaybe<Scalars['Date']>;
  /** Indicates the shipping method chosen for the transaction in the 3D Secure lookup. */
  shippingMethod?: InputMaybe<ThreeDSecureLookupShippingMethod>;
  /** Indicates shipping type chosen for the transaction. */
  shippingType?: InputMaybe<ThreeDSecureAuthenticationShippingType>;
  /** Indicates whether the merchant experienced suspicious activity (including previous fraud) on the account. */
  suspiciousActivityObserved?: InputMaybe<Scalars['Boolean']>;
  /** Tax amount. */
  taxAmount?: InputMaybe<Scalars['Amount']>;
  /** Number of transactions (successful or incomplete) for this cardholder account within the last 24 hours. */
  transactionCountDay?: InputMaybe<Scalars['Int']>;
  /** Number of transactions (successful or incomplete) for this cardholder account within the last year. */
  transactionCountYear?: InputMaybe<Scalars['Int']>;
  /** Indicates the type of transaction. */
  transactionType?: InputMaybe<ThreeDSecureAuthenticationTransactionType>;
  /** The exact content of the HTTP user agent header. */
  userAgent?: InputMaybe<Scalars['String']>;
  /** The work phone number associated with the transaction. */
  workPhoneNumber?: InputMaybe<Scalars['String']>;
};

/** Results of a merchant-performed 3D Secure authentication. */
export type ThreeDSecurePassThroughInput = {
  /** The 3D Secure authentication response status code. */
  authenticationResponse?: InputMaybe<Scalars['ThreeDSecureStatusCode']>;
  /** Cardholder authentication verification value or CAVV. The main encrypted message issuers and card networks use to verify authentication has occurred. Mastercard uses an AVV (Authentication Verification Value) message and American Express uses an AEVV (American Express Verification Value) message, each of which should also be passed in the cavv parameter. */
  cavv?: InputMaybe<Scalars['String']>;
  /** The algorithm used to generate the CAVV value. This is only returned for Mastercard SecureCode transactions (3DS 1.0). */
  cavvAlgorithm?: InputMaybe<Scalars['ThreeDSecureCavvAlgorithm']>;
  /** The 3D Secure directory server response. */
  directoryServerResponse?: InputMaybe<Scalars['ThreeDSecureStatusCode']>;
  /** A unique identifier for the 3D Secure 2 interaction with the card brand directory server. This field must be supplied for Mastercard Identity Check. */
  directoryServerTransactionId?: InputMaybe<Scalars['String']>;
  /** The value of the electronic commerce indicator (ECI) flag, which indicates the outcome of the 3D Secure authentication. */
  eciFlag: Scalars['ECommerceIndicator'];
  /** 3D Secure server transaction identifier resulting from 3D Secure authentication. */
  threeDSecureServerTransactionId?: InputMaybe<Scalars['String']>;
  /** The version of 3D Secure authentication used for the transaction. Required on Visa and Mastercard authentications. */
  version?: InputMaybe<Scalars['ThreeDSecureVersion']>;
  /** Transaction identifier resulting from 3D Secure authentication. Uniquely identifies the transaction and sometimes required in the authorization message. Must be base64-encoded. This field will no longer be used in 3D Secure 2 authentications. */
  xId?: InputMaybe<Scalars['String']>;
};

/** Top-level input fields for tokenizing a credit card. */
export type TokenizeCreditCardInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for a credit card. */
  creditCard: CreditCardInput;
  /** Credit card tokenization options. */
  options?: InputMaybe<TokenizeCreditCardOptionsInput>;
};

/** Credit card tokenization options. */
export type TokenizeCreditCardOptionsInput = {
  /** Whether to run validations on credit card fields. Validations are not run by default. */
  validate?: InputMaybe<Scalars['Boolean']>;
};

/** Top-level fields returned from a tokenized credit card. */
export type TokenizeCreditCardPayload = {
  __typename?: 'TokenizeCreditCardPayload';
  /**
   * Information about the [customer authentication regulation environment](https://developers.braintreepayments.com/guides/3d-secure/migration/javascript/v3#authentication-insight) that applies to the payment method when processed with the provided merchant account. This can be used to determine whether to perform 3D Secure authentication.
   * @deprecated Use paymentMethod.details.threeDSecure.authenticationInsight instead.
   */
  authenticationInsight?: Maybe<AuthenticationInsight>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * Details about the tokenized card.
   * @deprecated Use `paymentMethod.details` instead.
   */
  creditCard?: Maybe<CreditCardDetails>;
  /** A single-use payment method. */
  paymentMethod?: Maybe<PaymentMethod>;
  /**
   * A single-use payment method.
   * @deprecated Use `paymentMethod` instead.
   */
  singleUseToken?: Maybe<PaymentMethod>;
  /**
   * A one-time-use reference to tokenized sensitive information.
   * @deprecated Use `paymentMethod.id` instead.
   */
  token?: Maybe<Scalars['String']>;
};


/** Top-level fields returned from a tokenized credit card. */
export type TokenizeCreditCardPayloadAuthenticationInsightArgs = {
  input: AuthenticationInsightInput;
};

/** Top-level input fields for tokenizing Custom Actions. */
export type TokenizeCustomActionsPaymentMethodInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for a Custom Actions payment method. */
  customActionsPaymentMethod: CustomActionsPaymentMethodInput;
};

/** Top-level fields returned from tokenizing a CustomActionsPaymentMethod. */
export type TokenizeCustomActionsPaymentMethodPayload = {
  __typename?: 'TokenizeCustomActionsPaymentMethodPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A single-use payment method. */
  paymentMethod?: Maybe<PaymentMethod>;
};

/** Top-level input fields for tokenizing a CVV, otherwise known as CSC or CVC. */
export type TokenizeCvvInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A 3 or 4 digit card verification value assigned to credit cards. The CVV will never be stored, but it can be provided with one-time requests to verify the card. */
  cvv: Scalars['CVV'];
};

/** Top-level fields returned from a tokenized CVV. */
export type TokenizeCvvPayload = {
  __typename?: 'TokenizeCvvPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * A single-use payment method representing just a CVV.
   * @deprecated This mutation does not create a full PaymentMethod. Use `tokenizedCvv` instead.
   */
  singleUseToken?: Maybe<PaymentMethod>;
  /** A single-use tokenized CVV. */
  tokenizedCvv?: Maybe<TokenizedCvv>;
};

/** Top-level input field for tokenizing a network token. */
export type TokenizeNetworkTokenInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for a network token object. */
  networkToken: NetworkTokenInput;
};

/** Top-level fields returned from a tokenized Network Token. */
export type TokenizeNetworkTokenPayload = {
  __typename?: 'TokenizeNetworkTokenPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A single-use payment method. */
  paymentMethod?: Maybe<PaymentMethod>;
};

/** Top-level input fields for tokenizing a PayPal account. */
export type TokenizePayPalBillingAgreementInput = {
  /** Input fields for a PayPal Billing Agreement. */
  billingAgreement: PayPalBillingAgreementInput;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Top-level fields returned from a tokenized PayPal account. */
export type TokenizePayPalBillingAgreementPayload = {
  __typename?: 'TokenizePayPalBillingAgreementPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A single-use payment method. */
  paymentMethod?: Maybe<PaymentMethod>;
};

/** Top-level input fields for tokenizing a PayPal account. */
export type TokenizePayPalOneTimePaymentInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Braintree merchant account ID associated with the PayPal account to be used for the One-Time payment tokenization. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Input fields for a PayPal One-Time Payment. */
  paypalOneTimePayment: PayPalOneTimePaymentInput;
};

/** Top-level fields returned from a tokenized PayPal account. */
export type TokenizePayPalOneTimePaymentPayload = {
  __typename?: 'TokenizePayPalOneTimePaymentPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A single-use payment method. */
  paymentMethod?: Maybe<PaymentMethod>;
};

/** Top-level input field for tokenizing a Samsung Pay card. */
export type TokenizeSamsungPayCardInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for a Samsung Pay card. */
  samsungPayCard: SamsungPayCardInput;
};

/** Top-level fields returned from a tokenized Samsung Pay card. */
export type TokenizeSamsungPayCardPayload = {
  __typename?: 'TokenizeSamsungPayCardPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A single-use payment method. */
  paymentMethod?: Maybe<PaymentMethod>;
  /**
   * A one-time-use reference to tokenized sensitive information.
   * @deprecated Use `paymentMethod` instead.
   */
  singleUseToken?: Maybe<PaymentMethod>;
};

/** Top-level input fields for tokenizing a US bank account. */
export type TokenizeUsBankAccountInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for a US bank account object. */
  usBankAccount: UsBankAccountInput;
};

/** Top-level fields returned from a tokenized US bank account. */
export type TokenizeUsBankAccountPayload = {
  __typename?: 'TokenizeUsBankAccountPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A single-use payment method. */
  paymentMethod?: Maybe<PaymentMethod>;
};

/** Top-level input fields for tokenizing a US bank login. */
export type TokenizeUsBankLoginInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for a US bank login. */
  usBankLogin: UsBankLoginInput;
};

/** A single-use, tokenized value representing a CVV (card verification value), otherwise known as CSC or CVC. This cannot be charged or authorized, since it is not a payment method, but it can be used alongside a multi-use credit card payment method. */
export type TokenizedCvv = {
  __typename?: 'TokenizedCvv';
  /** Unique identifier for the tokenized CVV. */
  id: Scalars['ID'];
};

/** A charge on a payment method. */
export type Transaction = Node & Payment & {
  __typename?: 'Transaction';
  /** The amount charged in this transaction. For transactions that are partially captured, this amount will be the cummulative amount captured on this transaction. For transactions that are partially authorized, the amount will be less than the `initialRequestedAuthorizationAmount`. */
  amount?: Maybe<MonetaryAmount>;
  /** A collection of AuthorizationAdjustments associated with the transaction. */
  authorizationAdjustments?: Maybe<Array<AuthorizationAdjustment>>;
  /** The billing address associated with the transaction. */
  billingAddress?: Maybe<Address>;
  /** If the transaction request was performed through a shopping cart provider or Braintree partner, this field will have a string identifier for that shopping cart provider or partner. For PayPal transactions, this maps to the PayPal account's bn_code. */
  channel?: Maybe<Scalars['String']>;
  /** Date and time when the transaction was created. */
  createdAt?: Maybe<Scalars['Timestamp']>;
  /** Collection of custom field/value pairs. Custom fields are [defined in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#store-and-pass-back-fields). */
  customFields?: Maybe<Array<CustomField>>;
  /** Customer associated with the transaction, if applicable. */
  customer?: Maybe<Customer>;
  /** Fields used to define what will appear on customers' credit card statements for a specific purchase. */
  descriptor?: Maybe<TransactionDescriptor>;
  /** The disbursement details associated with this transaction. This field is only available after the transaction is SETTLED and if you have an eligible merchant account. */
  disbursementDetails?: Maybe<DisbursementDetails>;
  /** Discount amount that was included in the total transaction amount. */
  discountAmount?: Maybe<Scalars['String']>;
  /** A collection of disputes associated with the transaction. */
  disputes?: Maybe<Array<Dispute>>;
  /** If the transaction request was performed using payment information from a third party via the Grant API, Shared Vault or Google Pay, these fields will capture information about the third party. These fields are primarily useful for the merchant of record. */
  facilitatorDetails?: Maybe<FacilitatorDetails>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** The initial requested authorization amount for this transaction. */
  initialRequestedAuthorizationAmount?: Maybe<MonetaryAmount>;
  /** Installment details associated with the transaction. */
  installmentDetails?: Maybe<TransactionInstallmentDetails>;
  /** Legacy unique identifier. */
  legacyId: Scalars['ID'];
  /** Line items for this transaction. */
  lineItems?: Maybe<Array<TransactionLineItem>>;
  /** The ID of the merchant account that processed this transaction. */
  merchantAccountId?: Maybe<Scalars['ID']>;
  /** The address of the merchant that processed this transaction. */
  merchantAddress?: Maybe<Address>;
  /** The ID of the merchant that processed this transaction. */
  merchantId?: Maybe<Scalars['String']>;
  /** The display name of the merchant that processed this transaction. */
  merchantName?: Maybe<Scalars['String']>;
  /** The order ID for this transaction. For PayPal transactions, the PayPal Invoice ID. */
  orderId?: Maybe<Scalars['String']>;
  /** For transactions created or captured using the `partialCaptureTransaction` mutation. This field links a given transaction to its original authorization or all its partial captures. */
  partialCaptureDetails?: Maybe<PartialCaptureDetails>;
  /** The transaction date and time as reported by the in-store payment terminal. */
  paymentInitiatedAt?: Maybe<Scalars['Timestamp']>;
  /** The multi-use payment method associated with the transaction. Only present if a multi-use payment method was used to create the transaction and it has not been deleted. The details of this PaymentMethod may have changed since the transaction was created; details used for the transaction can be found in the `paymentMethodSnapshot` field. */
  paymentMethod?: Maybe<PaymentMethod>;
  /** Snapshot of payment method details used to create the transaction, preserved at the time the transaction was created. This will always be present. */
  paymentMethodSnapshot?: Maybe<PaymentMethodSnapshot>;
  /**
   * Fields describing the payment processor response.
   * @deprecated Use relevant events in `statusHistory` instead.
   */
  processorResponse?: Maybe<TransactionAuthorizationProcessorResponse>;
  /** A purchase order identification value you associate with this transaction. */
  purchaseOrderNumber?: Maybe<Scalars['String']>;
  /** The list of refunds issued against this transaction. */
  refunds?: Maybe<Array<Refund>>;
  /** Whether or not the transaction was automatically retried by Braintree's internal systems. */
  retried?: Maybe<Scalars['Boolean']>;
  /** Risk data evaluated for this transaction. */
  riskData?: Maybe<RiskData>;
  /** The type of Strong Customer Authentication Exemption that was requested for this transaction. */
  scaExemptionRequested?: Maybe<ScaExemptionType>;
  /** Shipping information. */
  shipping?: Maybe<TransactionShipping>;
  /** How the transaction was created. */
  source?: Maybe<PaymentSource>;
  /** The current status of this transaction. */
  status?: Maybe<PaymentStatus>;
  /** The records of all statuses this transaction has passed through, with additional information on why each status occurred. Returned in reverse chronological order, with the most recent event first in the list. */
  statusHistory?: Maybe<Array<PaymentStatusEvent>>;
  /** Tax information. */
  tax?: Maybe<TransactionTaxInformation>;
};

/** Record of processor response data received in response to authorization adjustment requests. */
export type TransactionAuthorizationAdjustmentProcessorResponse = {
  __typename?: 'TransactionAuthorizationAdjustmentProcessorResponse';
  /** Whether or not the decline is the result of a temporary issue. Only present if adjustment is declined. */
  declineType?: Maybe<ProcessorDeclineType>;
  /** The [processor response code](https://developers.braintreepayments.com/reference/general/processor-responses/authorization-responses) indicating the result of attempting the adjustment. */
  legacyCode?: Maybe<Scalars['String']>;
  /** The text explanation of the processor response code. */
  message?: Maybe<Scalars['String']>;
};

/** Detailed response information from the processor when attempting to authorize a transaction. */
export type TransactionAuthorizationProcessorResponse = {
  __typename?: 'TransactionAuthorizationProcessorResponse';
  /** If present, any additional information recieved from the processor. May provide further insight into the `legacyCode`. */
  additionalInformation?: Maybe<Scalars['String']>;
  /** The processor's unique ID or "code" for the authorization. */
  authorizationId?: Maybe<Scalars['String']>;
  /** The processing bank's response to the provided billing postal or zip code. */
  avsPostalCodeResponse?: Maybe<AvsCvvResponseCode>;
  /** The processing bank's response to the provided billing street address. */
  avsStreetAddressResponse?: Maybe<AvsCvvResponseCode>;
  /** The processing bank's response to the provided CVV. */
  cvvResponse?: Maybe<AvsCvvResponseCode>;
  /** Response EMV data provided by the processor if this was an EMV transaction. */
  emvData?: Maybe<Scalars['String']>;
  /** A code based on the response from the processor, indicating the result of attempting to authorize this transaction. See the [list of possible processor response codes for authorization](https://developers.braintreepayments.com/reference/general/processor-responses/authorization-responses). */
  legacyCode?: Maybe<Scalars['String']>;
  /** The text explanation of the processor response legacyCode. */
  message?: Maybe<Scalars['String']>;
  /** The processor's reference number for the authorization. */
  retrievalReferenceNumber?: Maybe<Scalars['String']>;
};

/** A paginated list of transactions. */
export type TransactionConnection = {
  __typename?: 'TransactionConnection';
  /** A list of transactions. */
  edges?: Maybe<Array<Maybe<TransactionConnectionEdge>>>;
  /** Information about the page of transactions contained in `edges`. */
  pageInfo: PageInfo;
};

/** A transaction within a TransactionConnection. */
export type TransactionConnectionEdge = {
  __typename?: 'TransactionConnectionEdge';
  /** This transaction's location within the TransactionConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The transaction. */
  node?: Maybe<Transaction>;
};

/** Customer details to be stored on the transaction itself, if the transaction is not associated with a customer. Used for fraud detection purposes. */
export type TransactionCustomerDetailsInput = {
  /** Email address for the customer. */
  email?: InputMaybe<Scalars['String']>;
  /** Phone number for the customer. */
  phoneNumber?: InputMaybe<Scalars['String']>;
};

/** Fields used to define what will appear on a customer's bank statement for a specific purchase. */
export type TransactionDescriptor = {
  __typename?: 'TransactionDescriptor';
  /** The value in the business name field of a customer's statement. */
  name?: Maybe<Scalars['String']>;
  /** The value in the phone number field of a customer's statement. */
  phone?: Maybe<Scalars['String']>;
  /** The value in the URL/web address field of a customer's statement. */
  url?: Maybe<Scalars['String']>;
};

/** Fields used to define what will appear on a customer's bank statement for a specific purchase. */
export type TransactionDescriptorInput = {
  /** The value in the business name field of a customer's statement. */
  name?: InputMaybe<Scalars['String']>;
  /** The value in the phone number field of a customer's statement. */
  phone?: InputMaybe<Scalars['String']>;
  /** The value in the URL/web address field of a customer's statement. */
  url?: InputMaybe<Scalars['String']>;
};

/** Input for transactions created with credit cards vaulted in an external vault, not the Braintree Vault. Do not use for transactions created from Braintree multi-use payment methods, or from single-use payment methods which will not be stored in an external vault. */
export type TransactionExternalVaultOptionsInput = {
  /** The credit card's assocation with an external vault. */
  status: ExternalVaultStatus;
  /** The network transaction ID of the first _transaction_ after which this payment method was stored in the external vault. If the `status` is `WILL_VAULT`, do not pass this value; the network transaction ID of the resulting transaction can be passed in this field for _subsequent_ transactions. If the `status` is `VAULTED`, but the customer is directly initiating the charge, do not pass this value. */
  verifyingNetworkTransactionId?: InputMaybe<Scalars['String']>;
};

/** Input fields for creating a transaction. */
export type TransactionInput = {
  /** Billing amount of the request. This value must be greater than 0, and must match the currency format of the merchant account. This can only contain numbers and one decimal point (e.g. x.xx). Can't be greater than the maximum allowed by the processor. */
  amount: Scalars['Amount'];
  /** For partners and shopping carts only. If you are a shopping cart provider or other Braintree partner, pass a string identifier for your service. For PayPal transactions, this maps to paypal.bn_code. */
  channel?: InputMaybe<Scalars['String']>;
  /** Collection of custom field/value pairs. You must [set up each custom field in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#creating-a-custom-field) prior to passing it with a request. */
  customFields?: InputMaybe<Array<CustomFieldInput>>;
  /**
   * Customer information to be stored on the transaction and used for fraud protection. Use this if you wish to pass customer information on a transaction without creating an independent stored customer record in the vault.
   *
   * This parameter can only be used if you do not pass `customerId`, and if you are not using a vaulted/multi-use payment method. In other words, this field is only valid when the transaction will not be associated with an existing customer.
   *
   * If `vaultPaymentMethodAfterTransacting` is also passed, these values will be used when creating a new customer for the newly-vaulted payment method.
   */
  customerDetails?: InputMaybe<TransactionCustomerDetailsInput>;
  /** If charging a single-use payment method, optional ID of a customer to associate the transaction with. If vaulting the single-use payment method, this customer will be associated with the resulting multi-use payment method. */
  customerId?: InputMaybe<Scalars['ID']>;
  /** Fields used to define what will appear on a customer's bank statement for a specific purchase. */
  descriptor?: InputMaybe<TransactionDescriptorInput>;
  /**
   * Discount amount that was included in the total transaction amount. Does not add to the total amount the payment method will be charged. This value can't be negative. Please note that this field is not used on PayPal transactions.
   *
   * *Required for Level 3 processing*.
   */
  discountAmount?: InputMaybe<Scalars['String']>;
  /** ID of exchange rate quote to be used for the transaction. */
  exchangeRateQuoteId?: InputMaybe<Scalars['ID']>;
  /**
   * Line items for this transaction. Up to 249 line items may be specified.
   *
   * *Required for Level 3 processing*.
   */
  lineItems?: InputMaybe<Array<TransactionLineItemInput>>;
  /** Merchant account ID used to process the transaction. Currency is also determined by merchant account ID. If no merchant account ID is specified, we will use your default merchant account. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Additional information about the transaction. On PayPal transactions, this field maps to the PayPal invoice number. PayPal invoice numbers must be unique in your PayPal business account. Maximum 255 characters or 127 for PayPal transactions. */
  orderId?: InputMaybe<Scalars['String']>;
  /** The initiator of the payment. Payment can either be merchant-initiated or customer-initiated. If the transaction is an ecommerce transaction initiated by the customer, no value is passed. */
  paymentInitiator?: InputMaybe<PaymentInitiator>;
  /**
   * A purchase order identification value you associate with this transaction.
   *
   * *Required for Level 2 processing*.
   */
  purchaseOrderNumber?: InputMaybe<Scalars['String']>;
  /** Deprecated: This field is included for supporting legacy clients. Please use `paymentInitiator` instead. */
  recurring?: InputMaybe<RecurringType>;
  /** Customer device information, which is sent directly to supported processors for fraud analysis. */
  riskData?: InputMaybe<RiskDataInput>;
  /**
   * Shipping information.
   *
   * *Required for Level 3 processing*.
   */
  shipping?: InputMaybe<TransactionShippingInput>;
  /**
   * Tax information about the transaction.
   *
   * *Required for Level 2 processing*.
   */
  tax?: InputMaybe<TransactionTaxInput>;
  /**
   * Deprecated: This field is included for supporting legacy clients. This field is specific to credit card payment methods only, and cannot be applied to transactions with other payment method types. If you need to pass this field, please use `authorizeCreditCard` or `chargeCreditCard`. See the `CreditCardTransactionOptionsInput` type for details.
   *
   * Results of a merchant-performed 3D Secure authentication. You will only need to use these fields if you've performed your own integration with a 3D Secure MPI provider (e.g. Cardinal Centinel). Otherwise, Braintree's SDKs handle this for you in our standard 3D Secure integration.
   */
  threeDSecurePassThrough?: InputMaybe<ThreeDSecurePassThroughInput>;
  /** When a single-use payment method is used to create this transaction, it can be automatically stored in the vault after transacting. If this field is left blank, the single-use payment method will not be vaulted. */
  vaultPaymentMethodAfterTransacting?: InputMaybe<VaultPaymentMethodAfterTransactingInput>;
};

/** Transaction Installment information. */
export type TransactionInstallment = {
  __typename?: 'TransactionInstallment';
  /** The date that the funds associated with this installment were actually disbursed. */
  actualDisbursementDate?: Maybe<Scalars['Date']>;
  /** List of adjustments associated with the installment. */
  adjustments?: Maybe<Array<TransactionInstallmentAdjustment>>;
  /** Installment amount.The total transaction amount is split equally into each installment. */
  amount?: Maybe<Scalars['Amount']>;
  /** Installment ID. */
  id: Scalars['ID'];
  /** The projected date for the funds associated with this installment to be disbursed. */
  projectedDisbursementDate?: Maybe<Scalars['Date']>;
};

/** Adjustment information. */
export type TransactionInstallmentAdjustment = {
  __typename?: 'TransactionInstallmentAdjustment';
  /** The date that the funds associated with this adjustments were actually disbursed. */
  actualDisbursementDate?: Maybe<Scalars['Date']>;
  /** Adjustment amount for the installment. */
  amount?: Maybe<Scalars['Amount']>;
  /** The projected date for the funds associated with the adjustements to be disbursed. */
  projectedDisbursementDate?: Maybe<Scalars['Date']>;
  /** Transaction Installment Adjustment type. */
  type: TransactionInstallmentAdjustmentType;
};

/** Transaction Installment Adjustment type to indicate the reason for the adjustment. */
export enum TransactionInstallmentAdjustmentType {
  /** Dispute. */
  Dispute = 'DISPUTE',
  /** Refund. */
  Refund = 'REFUND'
}

/** Installment details for the transaction. */
export type TransactionInstallmentDetails = {
  __typename?: 'TransactionInstallmentDetails';
  /** The installment count associated with the transaction. */
  count?: Maybe<Scalars['String']>;
  /** List of installments associated with the transaction. */
  installments?: Maybe<Array<TransactionInstallment>>;
};

/** The [transaction-level fee report](https://articles.braintreepayments.com/control-panel/reporting/transaction-level-fee-report) provides a breakdown of fees per individual transactions and refunds. This type is no longer in use; see `PaymentLevelFeeReport` instead. */
export type TransactionLevelFeeReport = {
  __typename?: 'TransactionLevelFeeReport';
  /** The URL where you can access the requested report. */
  url?: Maybe<Scalars['String']>;
};

/** Data for individual line items on a transaction. */
export type TransactionLineItem = {
  __typename?: 'TransactionLineItem';
  /** Code used to classify items purchased and track the total amount spent across various categories of products and services. Different corporate purchasing organizations may use different standards, but the [United Nations Standard Products and Services Code (UNSPSC)](https://www.unspsc.org/) is frequently used. */
  commodityCode?: Maybe<Scalars['String']>;
  /** Item description. */
  description?: Maybe<Scalars['String']>;
  /** The discount amount of the line item. */
  discountAmount?: Maybe<Scalars['String']>;
  /** URL to an image that represents the product. Max 1024 characters. */
  imageUrl?: Maybe<Scalars['String']>;
  /** The type of the line item, i.e., physical, digital etc. */
  itemType?: Maybe<Scalars['String']>;
  /** Indicates whether the line item is a sale or refund. */
  kind?: Maybe<TransactionLineItemType>;
  /** Item name. */
  name?: Maybe<Scalars['String']>;
  /** Product or UPC code for the item. */
  productCode?: Maybe<Scalars['String']>;
  /** Number of units of the item purchased. */
  quantity?: Maybe<Scalars['String']>;
  /** Tax amount for the line item. */
  taxAmount?: Maybe<Scalars['String']>;
  /** Total price amount for the line item, i.e. quantity multiplied by unit amount. */
  totalAmount?: Maybe<Scalars['String']>;
  /** Per-unit price of the item. */
  unitAmount?: Maybe<Scalars['String']>;
  /** The unit of measure or the unit of measure code. */
  unitOfMeasure?: Maybe<Scalars['String']>;
  /** Per-unit tax price of the item. */
  unitTaxAmount?: Maybe<Scalars['String']>;
  /** The URL to product information. */
  url?: Maybe<Scalars['String']>;
};

/** Data for individual line items on a transaction. */
export type TransactionLineItemInput = {
  /**
   * Code used to classify items purchased and track the total amount spent across various categories of products and services. Different corporate purchasing organizations may use different standards, but the [United Nations Standard Products and Services Code (UNSPSC)](https://www.unspsc.org/) is frequently used. Maximum 12 characters.
   *
   * *Required for Level 3 processing*.
   */
  commodityCode?: InputMaybe<Scalars['String']>;
  /**
   * Item description. Maximum 127 characters.
   *
   * *Required for Level 3 processing*.
   */
  description?: InputMaybe<Scalars['String']>;
  /**
   * Amount of discount for the line item. Can include up to 2 decimal places. This value can't be negative. Please note that this field is not used on PayPal transactions.
   *
   * *Required for Level 3 processing*.
   */
  discountAmount?: InputMaybe<Scalars['String']>;
  /** URL to an image that represents the product. Max 1024 characters. */
  imageUrl?: InputMaybe<Scalars['String']>;
  /** The type of the line item, i.e., physical, digital etc. */
  itemType?: InputMaybe<Scalars['String']>;
  /**
   * Indicates whether the line item is a sale or refund.
   *
   * *Required for Level 3 processing*.
   */
  kind: TransactionLineItemType;
  /**
   * Item name. Maximum 35 characters, or 127 characters for PayPal transactions.
   *
   * *Required for Level 3 processing*.
   */
  name: Scalars['String'];
  /**
   * Product or UPC code for the item. Maximum 12 characters, or 127 characters for PayPal transactions.
   *
   * *Required for Level 3 processing*.
   */
  productCode?: InputMaybe<Scalars['String']>;
  /**
   * Number of units of the item purchased. Can include up to 4 decimal places. This value can't be negative or zero.
   *
   * *Required for Level 3 processing*.
   */
  quantity: Scalars['String'];
  /**
   * Tax amount for the line item. Can include up to 2 decimal places. This value can't be negative.
   *
   * *Required for Level 3 processing*.
   */
  taxAmount?: InputMaybe<Scalars['String']>;
  /**
   * Total price amount for the line item: quantity multiplied by unitAmount. Can include up to 2 decimal places.
   *
   * *Required for Level 3 processing*.
   */
  totalAmount: Scalars['String'];
  /**
   * Per-unit price of the item. Maximum 4 decimal places, or 2 decimal places for PayPal transactions. This value can't be negative or zero.
   *
   * *Required for Level 3 processing*.
   */
  unitAmount: Scalars['String'];
  /**
   * The unit of measure or the unit of measure code. Maximum 12 characters.
   *
   * *Required for Level 3 processing*.
   */
  unitOfMeasure?: InputMaybe<Scalars['String']>;
  /**
   * Per-unit tax price of the item. Can include up to 2 decimal places. This value can't be negative or zero.
   *
   * *Required for Level 3 processing*.
   */
  unitTaxAmount?: InputMaybe<Scalars['String']>;
  /**
   * A URL to information about the product.
   *
   * *Required for Level 3 processing*.
   */
  url?: InputMaybe<Scalars['String']>;
};

/** Indicates whether a transaction line item is a debit (sale) or credit (refund). */
export enum TransactionLineItemType {
  Credit = 'CREDIT',
  Debit = 'DEBIT'
}

/** Top-level output field from creating a transaction. */
export type TransactionPayload = {
  __typename?: 'TransactionPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The transaction representing the charge on the payment method. */
  transaction?: Maybe<Transaction>;
};

/** A union of all possible results of a transaction reversal. If the transaction is settled, a refund will be issued and a Refund object will be returned. Otherwise, the transaction will be voided and a Transaction object will be returned. */
export type TransactionReversal = Refund | Transaction;

/** Input fields for searching for transactions. */
export type TransactionSearchInput = {
  /** Find transactions for a given amount or currency. */
  amount?: InputMaybe<MonetaryAmountSearchInput>;
  /** Find transactions by the billing address. */
  billingAddress?: InputMaybe<SearchAddressInput>;
  /** Find transactions based on the time they were created. */
  createdAt?: InputMaybe<SearchTimestampInput>;
  /** Find transactions with a given customer. */
  customer?: InputMaybe<SearchPaymentCustomerInput>;
  /** Find transactions by their disbursement date. Only use this search criteria if you have an eligible merchant account. Note that transactions can only be disbursed after they reach the SETTLED status. */
  disbursementDate?: InputMaybe<SearchDateInput>;
  /** Find transactions created by a third party via the Grant API using a given OAuth application client ID. */
  facilitatorOAuthApplicationClientId?: InputMaybe<SearchValueInput>;
  /** Find transactions with an ID or IDs. */
  id?: InputMaybe<SearchValueInput>;
  /** Find payments processed through a merchant account ID or IDs. */
  merchantAccountId?: InputMaybe<SearchValueInput>;
  /** Find transactions with a given orderId. */
  orderId?: InputMaybe<SearchTextInput>;
  /** Find transactions based on information about the payment method used for the transaction. */
  paymentMethod?: InputMaybe<SearchPaymentPaymentMethodInput>;
  /** Find transactions created by charging payment methods of the given type. */
  paymentMethodSnapshotType?: InputMaybe<SearchPaymentMethodSnapshotTypeInput>;
  /** Find transactions by the batch ID under which the transaction was submitted for settlement. */
  settlementBatchId?: InputMaybe<SearchTextInput>;
  /** Find transactions by the shipping address. */
  shippingAddress?: InputMaybe<SearchAddressInput>;
  /** Find transactions created with a given transaction source. */
  source?: InputMaybe<SearchTransactionSourceInput>;
  /** Find transactions with a given transaction status. */
  status?: InputMaybe<SearchTransactionStatusInput>;
  /** Find transactions based on the given transaction status transition times. */
  statusTransition?: InputMaybe<SearchTransactionStatusTransitionInput>;
  /** Find transactions by the ID of the store that the transaction was processed in. */
  storeId?: InputMaybe<SearchValueInput>;
  /** Find transactions with a user ID or IDs. */
  userId?: InputMaybe<SearchValueInput>;
};

/** Detailed response information from the processor when attempting to settle a transaction. */
export type TransactionSettlementProcessorResponse = {
  __typename?: 'TransactionSettlementProcessorResponse';
  /**
   * The processing bank's response to the provided billing postal or zip code.
   * @deprecated AVS and CVV checks do not take place when capturing a transaction, only when authorizing. Use the `processorResponse` on an authorization-related `PaymentStatusEvent` instead.
   */
  avsPostalCodeResponse?: Maybe<AvsCvvResponseCode>;
  /**
   * The processing bank's response to the provided billing street address.
   * @deprecated AVS and CVV checks do not take place when capturing a transaction, only when authorizing. Use the `processorResponse` on an authorization-related `PaymentStatusEvent` instead.
   */
  avsStreetAddressResponse?: Maybe<AvsCvvResponseCode>;
  /**
   * The processing bank's response to the provided CVV.
   * @deprecated AVS and CVV checks do not take place when capturing a transaction, only when authorizing. Use the `processorResponse` on an authorization-related `PaymentStatusEvent` instead.
   */
  cvvResponse?: Maybe<AvsCvvResponseCode>;
  /** A code based on the response from the processor, indicating the result of attempting to settle this transaction. See the [list of possible processor response codes for settlement](https://developers.braintreepayments.com/reference/general/processor-responses/settlement-responses). */
  legacyCode?: Maybe<Scalars['String']>;
  /** The text explanation of the processor response legacyCode. */
  message?: Maybe<Scalars['String']>;
};

/** Information related to shipping a physical product. */
export type TransactionShipping = {
  __typename?: 'TransactionShipping';
  /** Shipping address information. */
  shippingAddress?: Maybe<Address>;
  /** The shipping cost of the entire transaction. */
  shippingAmount?: Maybe<Scalars['Amount']>;
  /** The postal code of the source shipping location. */
  shipsFromPostalCode?: Maybe<Scalars['String']>;
};

/** Information related to shipping a physical product. */
export type TransactionShippingInput = {
  /**
   * Shipping destination address information.
   *
   * *Required for Level 3 processing*.
   */
  shippingAddress?: InputMaybe<AddressInput>;
  /**
   * Shipping cost on the entire transaction.
   *
   * *Required for Level 3 processing*.
   */
  shippingAmount?: InputMaybe<Scalars['String']>;
  /**
   * The postal code of the source shipping location, in any country's format.
   *
   * *Required for Level 3 processing*.
   */
  shipsFromPostalCode?: InputMaybe<Scalars['String']>;
};

/** Information related to taxes on the transaction. */
export type TransactionTaxInformation = {
  __typename?: 'TransactionTaxInformation';
  /** The amount of tax that was included in the total transaction amount. */
  taxAmount?: Maybe<Scalars['Amount']>;
  /** Whether the transaction should be considered eligible for tax exemption. */
  taxExempt?: Maybe<Scalars['Boolean']>;
};

/** Information related to taxes on the transaction. */
export type TransactionTaxInput = {
  /**
   * Amount of tax that was included in the total transaction amount. Does not add to the total amount the payment method will be charged.
   *
   * *Required for Level 2 processing* unless `taxExempt` is `true`.
   */
  taxAmount?: InputMaybe<Scalars['Amount']>;
  /**
   * Whether the transaction should be considered eligible for tax exemption.
   *
   * *Required for Level 2 processing*.
   */
  taxExempt?: InputMaybe<Scalars['Boolean']>;
};

/** Configuration for UnionPay cards. */
export type UnionPayConfiguration = {
  __typename?: 'UnionPayConfiguration';
  /** The Braintree merchant account ID with UnionPay processing enabled. */
  merchantAccountId?: Maybe<Scalars['String']>;
};

/** Top-level input fields for updating a multi-use credit card to use a new billing address. */
export type UpdateCreditCardBillingAddressInput = {
  /** The new billing address. */
  billingAddress?: InputMaybe<AddressInput>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the merchant account that will be used when verifying the credit card with the new billing address. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** The multi-use credit card for which the billing address will be updated or added. */
  paymentMethodId: Scalars['ID'];
  /** Input fields that specify options for verifying the credit card with the new billing address. By default, a verification will be performed. If the verification fails, the update will not be performed. */
  verification?: InputMaybe<CreditCardVerificationOptionsInput>;
};

/** Top-level fields returned when updating a multi-use credit card to a new billing address. */
export type UpdateCreditCardBillingAddressPayload = {
  __typename?: 'UpdateCreditCardBillingAddressPayload';
  /** The new billing address. Will be `null` if a failed verification prevented the update. */
  billingAddress?: Maybe<Address>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The verification that was run on the payment method prior to updating the billing address, if present. */
  verification?: Maybe<Verification>;
};

/** Top-level field for updating a customer. */
export type UpdateCustomerInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields for the updates to be made on the customer. */
  customer?: InputMaybe<CustomerInput>;
  /** ID of the customer to be updated. */
  customerId: Scalars['ID'];
};

/** Top-level fields returned when updating a customer. */
export type UpdateCustomerPayload = {
  __typename?: 'UpdateCustomerPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Information about the customer that was updated. */
  customer?: Maybe<Customer>;
};

/** Input fields for updating an in-store location. */
export type UpdateInStoreLocationInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input fields to update an in-store location. */
  location: InStoreLocationUpdateInput;
  /** ID of the location to be updated. */
  locationId: Scalars['ID'];
};

/** Top-level fields returned when creating an in-store location. */
export type UpdateInStoreLocationPayload = {
  __typename?: 'UpdateInStoreLocationPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The in-store location. */
  location?: Maybe<InStoreLocation>;
};

/** Input fields for updating an in-store reader. */
export type UpdateInStoreReaderInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The new location ID for the in-store reader. */
  locationId?: InputMaybe<Scalars['ID']>;
  /** The new name for the in-store reader. */
  name?: InputMaybe<Scalars['String']>;
  /** The ID of the in-store reader to update. */
  readerId: Scalars['ID'];
};

/** Top-level input fields for a updating a transaction's amount. */
export type UpdateTransactionAmountInput = {
  /** The new total amount to be authorized on a transaction. This value must be greater than 0, and must match the currency format of the merchant account, and cannot be greater than the maximum allowed by the processor. */
  amount: Scalars['Amount'];
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the transaction on which to perform the adjustment. */
  transactionId: Scalars['ID'];
};

/** Input for creating or updating custom fields on a transaction. */
export type UpdateTransactionCustomFieldsInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The list of custom fields to update. You must [set up each custom field in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#creating-a-custom-field) prior to passing it with a request. */
  customFields: Array<CustomFieldInput>;
  /** The ID of the transaction to update. */
  transactionId: Scalars['ID'];
};

/** Top-level output field from updating custom fields for a specific transaction. */
export type UpdateTransactionCustomFieldsPayload = {
  __typename?: 'UpdateTransactionCustomFieldsPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of all custom fields on the updated transaction. Custom fields are [defined in the Control Panel](https://articles.braintreepayments.com/control-panel/custom-fields#store-and-pass-back-fields). */
  customFields?: Maybe<Array<CustomField>>;
};

/** Details about the customer's acceptance of ACH terms. */
export type UsBankAccountAchMandate = {
  __typename?: 'UsBankAccountAchMandate';
  /** The text the customer agreed to when setting up ACH. */
  acceptanceText?: Maybe<Scalars['String']>;
  /** Date and time when the text terms were accepted. */
  acceptedAt?: Maybe<Scalars['Timestamp']>;
};

/** A billing address for a US bank account. This is a subset of the fields required on `AddressInput`. */
export type UsBankAccountBillingAddressInput = {
  /** The city. */
  city: Scalars['String'];
  /** The extended address informationsuch as an apartment or suite number. */
  extendedAddress?: InputMaybe<Scalars['String']>;
  /** The state. */
  state: UsStateCode;
  /** The street address. */
  streetAddress: Scalars['String'];
  /** The ZIP code. */
  zipCode: Scalars['UsZipCode'];
};

/** The name of the owner of a business US bank account. */
export type UsBankAccountBusinessOwnerInput = {
  /** The name of the business that owns the account. */
  businessName: Scalars['String'];
};

/** Configuration for US bank account processing. */
export type UsBankAccountConfiguration = {
  __typename?: 'UsBankAccountConfiguration';
  /** The public key for Plaid to use to log in to a bank account. */
  plaidPublicKey?: Maybe<Scalars['String']>;
  /** The route ID used to process a US bank account payment. */
  routeId?: Maybe<Scalars['String']>;
};

/** Details about a US bank account. */
export type UsBankAccountDetails = {
  __typename?: 'UsBankAccountDetails';
  /** The bank account type. */
  accountType?: Maybe<UsBankAccountType>;
  /** The name of the accountholder. This is either the business name for a business account, or the owner's full name for an individual account. */
  accountholderName?: Maybe<Scalars['String']>;
  /** NACHA-mandated proof of acceptance of ACH terms. */
  achMandate?: Maybe<UsBankAccountAchMandate>;
  /** The name of the bank at which the account exists. */
  bankName?: Maybe<Scalars['String']>;
  /** The last four digits of the bank account number. */
  last4?: Maybe<Scalars['String']>;
  /** The ownership type of the account, i.e. business or personal. */
  ownershipType?: Maybe<UsBankAccountOwnershipType>;
  /** The routing number of the bank. */
  routingNumber?: Maybe<Scalars['String']>;
  /** Whether or not the bank account has been verified and can be transacted on. */
  verified?: Maybe<Scalars['Boolean']>;
};

/** The name of the owner of a personal US bank account. */
export type UsBankAccountIndividualOwnerInput = {
  /** The first name of the accountholder. */
  firstName: Scalars['String'];
  /** The last name of the accountholder. */
  lastName: Scalars['String'];
};

/** Input fields for a US bank account object. */
export type UsBankAccountInput = {
  /** The account number of the bank account. */
  accountNumber: Scalars['UsBankAccountNumber'];
  /** The type of account. */
  accountType: UsBankAccountType;
  /** Language used to prove that you have the customer's explicit permission to debit their bank account. */
  achMandate: Scalars['String'];
  /** The billing address of the account. */
  billingAddress?: InputMaybe<UsBankAccountBillingAddressInput>;
  /** Information about the business that owns the account. This should only be specified for business accounts. */
  businessOwner?: InputMaybe<UsBankAccountBusinessOwnerInput>;
  /** Information about the individual that owns the account. This should only be specified for individual accounts. */
  individualOwner?: InputMaybe<UsBankAccountIndividualOwnerInput>;
  /** The routing number of the bank that holds the account. */
  routingNumber: Scalars['UsBankRoutingNumber'];
};

/** The ownership type of US Bank Account. */
export enum UsBankAccountOwnershipType {
  Business = 'BUSINESS',
  Personal = 'PERSONAL'
}

/** The type of US Bank Account. */
export enum UsBankAccountType {
  Checking = 'CHECKING',
  Savings = 'SAVINGS'
}

/** Information specific to verifications of US bank account payment methods. */
export type UsBankAccountVerificationDetails = {
  __typename?: 'UsBankAccountVerificationDetails';
  /** Type of US bank account verification performed. */
  method?: Maybe<UsBankAccountVerificationMethod>;
  /** Time at which the verification was determined to be successful or not. If successful, at this time the payment method will be marked `verified` and you will be able to charge it. */
  verificationDeterminedAt?: Maybe<Scalars['Timestamp']>;
};

/** The type of verification on a US bank account payment method. See our [ACH guide](https://articles.braintreepayments.com/guides/payment-methods/ach#verification-methods). */
export enum UsBankAccountVerificationMethod {
  /** Verification conducted independently by the merchant, not through Braintree. */
  IndependentCheck = 'INDEPENDENT_CHECK',
  /** Verification by micro-deposits transferred to the bank account, which the customer must then confirm. The most reliable method, but takes additional time. */
  MicroTransfers = 'MICRO_TRANSFERS',
  /** Verification via account information. Will complete the verification process immediately, but is not supported by all banks. */
  NetworkCheck = 'NETWORK_CHECK',
  /** Verification at the point of tokenization. Requires integration with a third-party provider. Because this requires a different tokenization flow, this method of verification is only supported for vaulting tokenized US bank account logins, and is not supported when re-verifying a US bank account payment method. */
  TokenizedCheck = 'TOKENIZED_CHECK'
}

/** Input fields for a US bank login object. */
export type UsBankLoginInput = {
  /** The login provider account ID used for the bank login. */
  accountId: Scalars['String'];
  /** The type of account. */
  accountType: UsBankAccountType;
  /** Language used to prove that you have the customer's explicit permission to debit their bank account. */
  achMandate: Scalars['String'];
  /** The billing address of the account. */
  billingAddress?: InputMaybe<UsBankAccountBillingAddressInput>;
  /** Information about the business that owns the account. This should only be specified for business accounts. */
  businessOwner?: InputMaybe<UsBankAccountBusinessOwnerInput>;
  /** Information about the individual that owns the account. This should only be specified for individual accounts. */
  individualOwner?: InputMaybe<UsBankAccountIndividualOwnerInput>;
  /** The public token returned from the bank login. */
  publicToken: Scalars['String'];
};

/** A two-letter code representing a US state or territory. */
export enum UsStateCode {
  Ak = 'AK',
  Al = 'AL',
  Ar = 'AR',
  As = 'AS',
  Az = 'AZ',
  Ca = 'CA',
  Co = 'CO',
  Ct = 'CT',
  Dc = 'DC',
  De = 'DE',
  Fl = 'FL',
  Ga = 'GA',
  Gu = 'GU',
  Hi = 'HI',
  Ia = 'IA',
  Id = 'ID',
  Il = 'IL',
  In = 'IN',
  Ks = 'KS',
  Ky = 'KY',
  La = 'LA',
  Ma = 'MA',
  Md = 'MD',
  Me = 'ME',
  Mi = 'MI',
  Mn = 'MN',
  Mo = 'MO',
  Mp = 'MP',
  Ms = 'MS',
  Mt = 'MT',
  Nc = 'NC',
  Nd = 'ND',
  Ne = 'NE',
  Nh = 'NH',
  Nj = 'NJ',
  Nm = 'NM',
  Nv = 'NV',
  Ny = 'NY',
  Oh = 'OH',
  Ok = 'OK',
  Or = 'OR',
  Pa = 'PA',
  Pr = 'PR',
  Ri = 'RI',
  Sc = 'SC',
  Sd = 'SD',
  Tn = 'TN',
  Tx = 'TX',
  Um = 'UM',
  Ut = 'UT',
  Va = 'VA',
  Vi = 'VI',
  Vt = 'VT',
  Wa = 'WA',
  Wi = 'WI',
  Wv = 'WV',
  Wy = 'WY'
}

/** Details about the user. */
export type User = {
  __typename?: 'User';
  /** Email address. */
  email?: Maybe<Scalars['String']>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Full name. */
  name?: Maybe<Scalars['String']>;
  /** Associated roles. */
  roles?: Maybe<Array<Role>>;
  /** Current status. */
  status?: Maybe<UserStatus>;
};

/** The status of the user. */
export enum UserStatus {
  Active = 'ACTIVE',
  Deleted = 'DELETED',
  Passive = 'PASSIVE',
  Pending = 'PENDING',
  Suspended = 'SUSPENDED'
}

/** Options used to indicate when a credit card is externally vaulted. */
export type VaultCreditCardExternalVaultOptionsInput = {
  /** For use if this credit card is stored in an external vault. The network transaction ID of the first _transaction_ after which this credit card was stored in the external vault. */
  verifyingNetworkTransactionId?: InputMaybe<Scalars['String']>;
};

/** Top-level input field for vaulting a credit card so it can be used multiple times. */
export type VaultCreditCardInput = {
  /** The type of account to be used when verifying a combo card. */
  accountType?: InputMaybe<CardAccountType>;
  /** A billing address to associate with the vaulted credit card. If billing address data was included when tokenizing the credit card, it will be *merged* with this input value. */
  billingAddress?: InputMaybe<AddressInput>;
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the customer to associate the resulting multi-use payment method with. */
  customerId?: InputMaybe<Scalars['ID']>;
  /** Options used to indicate when a credit card is externally vaulted. */
  externalVault?: InputMaybe<VaultCreditCardExternalVaultOptionsInput>;
  /** ID of an existing single-use credit card payment method to be vaulted. */
  paymentMethodId: Scalars['ID'];
  /** Customer device information, which is sent directly to supported processors for fraud analysis. */
  riskData?: InputMaybe<RiskDataInput>;
  /** Results of a merchant-performed 3D Secure authentication. You will only need to use these fields if you've performed your own integration with a 3D Secure MPI provider (e.g. Cardinal Centinel). Otherwise, Braintree's SDKs handle this for you in our standard 3D Secure integration. */
  threeDSecurePassThrough?: InputMaybe<ThreeDSecurePassThroughInput>;
  /** Input fields that specify options for verifying the credit card before vaulting. By default, a verification will be performed. If the verification fails, the credit card will not be vaulted. */
  verification?: InputMaybe<VaultCreditCardVerificationOptionsInput>;
};

/** Input fields that specify options for verifying the vaulted credit card. */
export type VaultCreditCardVerificationOptionsInput = {
  /** The amount to use to verify the credit card. */
  amount?: InputMaybe<Scalars['Amount']>;
  /** Control which fraud tools will be applied to this transaction. Fraud tools cannot be retroactively applied to a transaction if skipped. */
  fraudTools?: InputMaybe<CreditCardFraudToolsOptionsInput>;
  /** ID of the merchant account to use when verifying the credit card. The verification will use the default merchant account if this field is left blank. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Whether to opt out of verifying the credit card. Defaults to `false` for credit cards that support verification. Clients should only pass `true` in the uncommon scenario that the credit card has been verified externally to Braintree. */
  skip?: InputMaybe<Scalars['Boolean']>;
};

/**  Specifies behavior for vaulting a single-use payment method for an in-store transaction. */
export type VaultInStorePaymentMethodAfterTransactingInput = {
  /** Vaulting behavior override for QR code payments. */
  qrcOverride?: InputMaybe<VaultQrcOverride>;
  /** Specifies the criteria which must be met to vault this payment method. */
  when: VaultPaymentMethodCriteria;
};

/** Input fields that provide information about the resulting PayPal account. */
export type VaultLimitedUsePayPalAccountOptionsInput = {
  /** The total amount of the order. This will be the limit to how much may be captured on the resulting payment method. */
  amount?: InputMaybe<Scalars['Amount']>;
  /** Variable passed directly to PayPal for your own tracking purposes. Customers do not see this value. */
  customField?: InputMaybe<Scalars['String']>;
  /** Description of the transaction that is displayed to customers in PayPal email receipts. */
  description?: InputMaybe<Scalars['String']>;
  /** The PayPal invoice number. It must be unique in your PayPal business account and can contain a maximum of 127 characters. If specified, transactions created from the resulting payment method will have this orderId. */
  orderId?: InputMaybe<Scalars['String']>;
  /** Shipping destination address information. */
  shippingAddress?: InputMaybe<AddressInput>;
};

/** Top-level input fields for importing and vaulting a PayPal Billing Agreement. */
export type VaultPayPalBillingAgreementInput = {
  /** ID of a PayPal Billing Agreement, that was not created through Braintree, to import and vault. */
  billingAgreementId: Scalars['String'];
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Optional ID of the customer to associate the resulting payment method with. */
  customerId?: InputMaybe<Scalars['ID']>;
  /** The merchant (payee) PayPal account associated with the PayPal Billing Agreement being vaulted. Only used when the specified merchant account is specially configured to handle indirect PayPal accounts. */
  indirectPayee?: InputMaybe<PayPalAccountInput>;
  /** Optional ID of the merchant account associated with the linked PayPal account to be used to retrieve billing agreement details from PayPal. Only used for merchants with the PayPal multi-account feature enabled in Braintree. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
};

/** Top-level fields returned when importing and vaulting a PayPal Billing Agreement. */
export type VaultPayPalBillingAgreementPayload = {
  __typename?: 'VaultPayPalBillingAgreementPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The vaulted payment method containing the imported PayPal Billing Agreement. */
  paymentMethod?: Maybe<PaymentMethod>;
};

/**  Specifies behavior for vaulting a single-use payment method after transacting with it. */
export type VaultPaymentMethodAfterTransactingInput = {
  /** Specifies the criteria which must be met to vault this payment method. */
  when: VaultPaymentMethodCriteria;
};

/** Defines criteria for vaulting a single-use payment method after transacting with it. */
export enum VaultPaymentMethodCriteria {
  /** Always store the single-use payment method after transacting, regardless of the status of the transaction. */
  Always = 'ALWAYS',
  /** Only store the single-use payment method if it was successfully authorized. */
  OnSuccessfulTransaction = 'ON_SUCCESSFUL_TRANSACTION'
}

/** Top-level input field for vaulting a payment method so it can be used multiple times. */
export type VaultPaymentMethodInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the customer to associate the resulting multi-use payment method with. */
  customerId?: InputMaybe<Scalars['ID']>;
  /** ID of an existing single-use payment method to be vaulted. */
  paymentMethodId: Scalars['ID'];
  /** Customer device information, which is sent directly to supported processors for fraud analysis. */
  riskData?: InputMaybe<RiskDataInput>;
  /** Results of a merchant-performed 3D Secure authentication. You will only need to use these fields if you've performed your own integration with a 3D Secure MPI provider (e.g. Cardinal Centinel). Otherwise, Braintree's SDKs handle this for you in our standard 3D Secure integration. */
  threeDSecurePassThrough?: InputMaybe<ThreeDSecurePassThroughInput>;
  /** Input fields that specify options for verifying the payment method before vaulting. Only applicable if the payment method is of a type that supports verification. For supported types, verification is performed by default. If the verification fails, the payment method will not be vaulted. For additional, payment method-specific verification options, please see other verification mutations such as `verifyCreditCard` or `verifyUsBankAccount`. */
  verification?: InputMaybe<PaymentMethodVerificationOptionsInput>;
  /**
   * Deprecated: This field is included for supporting legacy clients. Please use `verification.merchantAccountId` instead.
   *
   * ID of the merchant account to use when verifying the payment method.
   */
  verificationMerchantAccountId?: InputMaybe<Scalars['ID']>;
};

/** Top-level output field from vaulting a payment method. */
export type VaultPaymentMethodPayload = {
  __typename?: 'VaultPaymentMethodPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A payment method that has been stored in a merchant's vault and can be reused. */
  paymentMethod?: Maybe<PaymentMethod>;
  /** The verification that was run on the payment method prior to vaulting. */
  verification?: Maybe<Verification>;
};

/** The override options for QR code vaulting. */
export enum VaultQrcOverride {
  /** Do not show QR code as a payment option, even if it is enabled. */
  HideQrc = 'HIDE_QRC',
  /** If QR codes are enabled, show as a payment option, but do not vault. */
  ShowQrcNoVault = 'SHOW_QRC_NO_VAULT'
}

/** Top-level input field for vaulting a bank account so it can be used multiple times. */
export type VaultUsBankAccountInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the customer to associate the resulting multi-use payment method with. */
  customerId?: InputMaybe<Scalars['ID']>;
  /** ID of an existing single-use payment method to be vaulted. */
  paymentMethodId: Scalars['ID'];
  /** ID of the merchant account to use when verifying the payment method. */
  verificationMerchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Type of US bank account verification to perform. */
  verificationMethod: UsBankAccountVerificationMethod;
};

/** Details about a Venmo Account. */
export type VenmoAccountDetails = {
  __typename?: 'VenmoAccountDetails';
  /** The Venmo username, as chosen by the user. */
  username?: Maybe<Scalars['String']>;
  /** The Venmo user ID. */
  venmoUserId?: Maybe<Scalars['String']>;
};

/** Configuration for Pay with Venmo. */
export type VenmoConfiguration = {
  __typename?: 'VenmoConfiguration';
  /** Authorization to use when tokenizing a Venmo payment method. */
  accessToken?: Maybe<Scalars['String']>;
  /** The Venmo environment. */
  environment?: Maybe<VenmoEnvironment>;
  /** The Venmo merchant ID. */
  merchantId?: Maybe<Scalars['String']>;
};

/** The environment being used for Venmo. */
export enum VenmoEnvironment {
  Production = 'PRODUCTION',
  Sandbox = 'SANDBOX'
}

/** Information about a payer's Venmo account. */
export type VenmoPayerInfo = {
  __typename?: 'VenmoPayerInfo';
  /** The payer's billing address. */
  billingAddress?: Maybe<Address>;
  /** The payer's email address. */
  email?: Maybe<Scalars['EmailAddress']>;
  /** The external ID of the payer's Venmo account. */
  externalId?: Maybe<Scalars['String']>;
  /** The payer's first name. */
  firstName?: Maybe<Scalars['String']>;
  /** The payer's last name. */
  lastName?: Maybe<Scalars['String']>;
  /** The payer's phone number. */
  phoneNumber?: Maybe<Scalars['String']>;
  /** The payer's shipping address. */
  shippingAddress?: Maybe<Address>;
  /** The username of the payer's Venmo account. */
  userName?: Maybe<Scalars['String']>;
};

/** Information about a payer's Venmo account. */
export type VenmoPayerInfoInput = {
  /** The payer's billing address. */
  billingAddress?: InputMaybe<AddressInput>;
  /** The payer's email address. */
  email?: InputMaybe<Scalars['EmailAddress']>;
  /** The external ID of the payer's Venmo account. */
  externalId?: InputMaybe<Scalars['String']>;
  /** The payer's first name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** The payer's last name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** The payer's phone number. */
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** The payer's shipping address. */
  shippingAddress?: InputMaybe<AddressInput>;
  /** The username of the payer's Venmo account. */
  userName?: InputMaybe<Scalars['String']>;
};

/** A verification reporting whether the payment method has passed your fraud rules and the issuer has ensured it is associated with a valid account. */
export type Verification = Node & {
  __typename?: 'Verification';
  /**
   * For a credit card, the amount used when performing the verification.
   * @deprecated Depending on the type of payment method being verified, some verifications do not have an amount. On a credit card verification, use `paymentMethodVerificationDetails.amount` instead.
   */
  amount?: Maybe<MonetaryAmount>;
  /** Date and time at which the verification was created. */
  createdAt?: Maybe<Scalars['Timestamp']>;
  /** The reason the verification was rejected. This will only be set if status is GATEWAY_REJECTED. */
  gatewayRejectionReason?: Maybe<GatewayRejectionReason>;
  /** Unique identifier. */
  id: Scalars['ID'];
  /** Legacy unique identifier. */
  legacyId: Scalars['ID'];
  /** The merchant account used for the verification. */
  merchantAccountId?: Maybe<Scalars['ID']>;
  /** Fields describing the network response to the verification request. */
  networkResponse?: Maybe<PaymentNetworkResponse>;
  /** The multi-use payment method that was verified, if it was vaulted. The details of this PaymentMethod may have changed since it was verified. */
  paymentMethod?: Maybe<PaymentMethod>;
  /** Snapshot of payment method details that were verified. This will always be present. */
  paymentMethodSnapshot?: Maybe<PaymentMethodSnapshot>;
  /** Details unique to the verification based on payment method type being verified. */
  paymentMethodVerificationDetails?: Maybe<VerificationDetails>;
  /** Detailed response information from the processor. Will not be present if the verification was rejected prior to contacting the processor. */
  processorResponse?: Maybe<VerificationProcessorResponse>;
  /** Risk data evaluated for this verification. */
  riskData?: Maybe<RiskData>;
  /** The current status of this verification, indicating whether the verification was successful. Braintree recommends only vaulting payment methods that are successfully verified. */
  status?: Maybe<VerificationStatus>;
};

/** A paginated list of verifications. */
export type VerificationConnection = {
  __typename?: 'VerificationConnection';
  /** A list of verifications. */
  edges?: Maybe<Array<Maybe<VerificationConnectionEdge>>>;
  /** Information about the page of verifications contained in `edges`. */
  pageInfo: PageInfo;
};

/** A verification within a VerificationConnection. */
export type VerificationConnectionEdge = {
  __typename?: 'VerificationConnectionEdge';
  /** The verification's location within the VerificationConnection. Used for requesting additional pages. */
  cursor?: Maybe<Scalars['String']>;
  /** The verification. */
  node?: Maybe<Verification>;
};

/** A union of all possible verification details specific to the type of payment method being verified. */
export type VerificationDetails = CreditCardVerificationDetails | UsBankAccountVerificationDetails;

/** Detailed response information from the processor. */
export type VerificationProcessorResponse = {
  __typename?: 'VerificationProcessorResponse';
  /** If present, any additional information recieved from the processor. May provide further insight into the `legacyCode`. */
  additionalInformation?: Maybe<Scalars['String']>;
  /** The processing bank's response to the provided billing postal or zip code. */
  avsPostalCodeResponse?: Maybe<AvsCvvResponseCode>;
  /** The processing bank's response to the provided billing street address. */
  avsStreetAddressResponse?: Maybe<AvsCvvResponseCode>;
  /** The processing bank's response to the provided CVV. */
  cvvResponse?: Maybe<AvsCvvResponseCode>;
  /** The [processor response code](https://developers.braintreepayments.com/reference/general/processor-responses/authorization-responses) indicating the result of attempting the verification. */
  legacyCode?: Maybe<Scalars['String']>;
  /** The text explanation of the processor response code. */
  message?: Maybe<Scalars['String']>;
};

/** Input fields for searching for verifications. */
export type VerificationSearchInput = {
  /** Find verifications with a given created at time. */
  createdAt?: InputMaybe<SearchTimestampInput>;
  /** Find verifications with an ID or IDs. */
  id?: InputMaybe<SearchValueInput>;
  /** Find verifications with a given status. */
  status?: InputMaybe<SearchVerificationStatusInput>;
};

/** The status of the verification, indicating whether the payment method was successfully verified. Braintree recommends only vaulting payment methods with successful verifications. */
export enum VerificationStatus {
  /** Indicates the verification was unsuccessful because of an issue communicating with the processor. */
  Failed = 'FAILED',
  /** Indicates that the verification was unsuccessful because the payment method failed one or more fraud checks. In this case, the `gatewayRejectionReason` will indicate which fraud check failed. */
  GatewayRejected = 'GATEWAY_REJECTED',
  /** Indicates that the verification is pending. */
  Pending = 'PENDING',
  /** Indicates that the verification was unsuccessful based on the response from the processor. */
  ProcessorDeclined = 'PROCESSOR_DECLINED',
  /** Indicates that the verification was successful. */
  Verified = 'VERIFIED',
  /** Indicates that the verification is in the process of verifying. */
  Verifying = 'VERIFYING'
}

/** Verifone specific in-store reader information. */
export type VerifoneVendor = {
  __typename?: 'VerifoneVendor';
  /** Model name or number of reader. */
  model?: Maybe<Scalars['String']>;
  /** Current OS version running on the reader. */
  osVersion?: Maybe<Scalars['String']>;
  /** Vendor-specific device serial number. */
  serialNumber?: Maybe<Scalars['String']>;
};

/** Top-level input field for verifying a multi-use credit card. */
export type VerifyCreditCardInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the merchant account to use when verifying the credit card. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** Input fields for verifying a credit card. */
  options?: InputMaybe<CreditCardVerificationOptionsInput>;
  /** ID of an existing multi-use payment method to be vaulted. */
  paymentMethodId: Scalars['ID'];
};

/** Top-level input field for verifying a multi-use payment method. */
export type VerifyPaymentMethodInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the merchant account to use when verifying the payment method. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** ID of an existing multi-use payment method to be verified. */
  paymentMethodId: Scalars['ID'];
};

/** Top-level output field from verifying a payment method. */
export type VerifyPaymentMethodPayload = {
  __typename?: 'VerifyPaymentMethodPayload';
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The verification that was run on the payment method. */
  verification?: Maybe<Verification>;
};

/** Top-level input field for retrying a verification on a bank account. */
export type VerifyUsBankAccountInput = {
  /** An identifier used to reconcile requests and responses. 255 characters maximum. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the merchant account to use when verifying the payment method. */
  merchantAccountId?: InputMaybe<Scalars['ID']>;
  /** ID of an existing multi-use payment method to be vaulted. */
  paymentMethodId: Scalars['ID'];
  /** Type of US bank account verification to perform. */
  verificationMethod: UsBankAccountVerificationMethod;
};

/** Details about the user and merchant authenticated in this request. */
export type Viewer = {
  __typename?: 'Viewer';
  /**
   * Email address.
   * @deprecated Use `user` for email instead.
   */
  email?: Maybe<Scalars['String']>;
  /**
   * Unique identifier.
   * @deprecated Use `user` for id instead.
   */
  id?: Maybe<Scalars['ID']>;
  /** Details about the authenticated merchant. */
  merchant?: Maybe<Merchant>;
  /**
   * Full name.
   * @deprecated Use `user` for name instead.
   */
  name?: Maybe<Scalars['String']>;
  /** Associated rights based on authentication. */
  rights?: Maybe<Array<Right>>;
  /**
   * Associated roles.
   * @deprecated Use `user` for roles instead.
   */
  roles?: Maybe<Array<Role>>;
  /**
   * Current status.
   * @deprecated Use `user` for status instead.
   */
  status?: Maybe<UserStatus>;
  /** Details about the authenticated user. */
  user?: Maybe<User>;
};

/** Configuration for Visa Checkout. */
export type VisaCheckoutConfiguration = {
  __typename?: 'VisaCheckoutConfiguration';
  /** The Visa Checkout API key. */
  apiKey?: Maybe<Scalars['String']>;
  /** The Visa Checkout encryption key. */
  encryptionKey?: Maybe<Scalars['String']>;
  /** The Visa Checkout external client ID. */
  externalClientId?: Maybe<Scalars['String']>;
  /** A list of card brands supported by the merchant for Visa Checkout. */
  supportedCardBrands?: Maybe<Array<CreditCardBrandCode>>;
};

/** Additional information about the payment method specific to Visa Checkout. */
export type VisaCheckoutOriginDetails = {
  __typename?: 'VisaCheckoutOriginDetails';
  /** The first 6 digits of the credit card, known as the Bank Identification Number. This BIN may differ from the BIN of the customer's actual card. */
  bin?: Maybe<Scalars['String']>;
  /** The Visa assigned identifier for the transaction. */
  callId?: Maybe<Scalars['String']>;
};

/** Accompanying information for a transaction that has been voided. */
export type VoidedEvent = PaymentStatusEvent & {
  __typename?: 'VoidedEvent';
  /** The amount of the voided transaction. This should match the authorization amount. */
  amount?: Maybe<MonetaryAmount>;
  /** The source for the transaction change to the new status. */
  source?: Maybe<PaymentSource>;
  /** The new status of the transaction. */
  status?: Maybe<PaymentStatus>;
  /** Whether or not this is the final state for the transaction. */
  terminal?: Maybe<Scalars['Boolean']>;
  /** Date and time when the transaction was voided. */
  timestamp?: Maybe<Scalars['Timestamp']>;
  /** User name of the person who performed an action that triggered the status change of the transaction. */
  userName?: Maybe<Scalars['String']>;
};

export type Vs_AboutPage = Vs_Entry & {
  __typename?: 'vs_AboutPage'
  careers?: Maybe<Vs_FeatureBanner>
  contentfulMetadata: Vs_ContentfulMetadata
  gallery?: Maybe<Vs_SlideGallery>
  hero?: Maybe<Vs_Heroes>
  linkedFrom?: Maybe<Vs_AboutPageLinkingCollections>
  locationsSection?: Maybe<Vs_LocationsSection>
  quote?: Maybe<Vs_FeatureBanner>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  storySection?: Maybe<Vs_StorySection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_AboutPageCareersArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_AboutPageGalleryArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_AboutPageHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_AboutPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_AboutPageLocationsSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_AboutPageQuoteArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_AboutPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_AboutPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_AboutPageStorySectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_AboutPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_AboutPageCollection = {
  __typename?: 'vs_AboutPageCollection'
  items: Array<Maybe<Vs_AboutPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_AboutPageLinkingCollections = {
  __typename?: 'vs_AboutPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_AboutPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AnnouncementBanner = Vs_Entry & {
  __typename?: 'vs_AnnouncementBanner'
  bannerHexColor?: Maybe<Scalars['String']>
  bodyText?: Maybe<Vs_AnnouncementBannerBodyText>
  contentfulMetadata: Vs_ContentfulMetadata
  enabledPaths?: Maybe<Array<Maybe<Scalars['String']>>>
  linkHexColor?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_AnnouncementBannerLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  textHexColor?: Maybe<Scalars['String']>
}

export type Vs_AnnouncementBannerBannerHexColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_AnnouncementBannerBodyTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_AnnouncementBannerEnabledPathsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_AnnouncementBannerLinkHexColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_AnnouncementBannerLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_AnnouncementBannerSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_AnnouncementBannerTextHexColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_AnnouncementBannerBodyText = {
  __typename?: 'vs_AnnouncementBannerBodyText'
  links: Vs_AnnouncementBannerBodyTextLinks
}

export type Vs_AnnouncementBannerBodyTextAssets = {
  __typename?: 'vs_AnnouncementBannerBodyTextAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_AnnouncementBannerBodyTextEntries = {
  __typename?: 'vs_AnnouncementBannerBodyTextEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_AnnouncementBannerBodyTextLinks = {
  __typename?: 'vs_AnnouncementBannerBodyTextLinks'
  assets: Vs_AnnouncementBannerBodyTextAssets
  entries: Vs_AnnouncementBannerBodyTextEntries
}

export type Vs_AnnouncementBannerLinkingCollections = {
  __typename?: 'vs_AnnouncementBannerLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_AnnouncementBannerLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Asset = {
  __typename?: 'vs_Asset'
  contentType?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  fileName?: Maybe<Scalars['String']>
  height?: Maybe<Scalars['Int']>
  linkedFrom?: Maybe<Vs_AssetLinkingCollections>
  size?: Maybe<Scalars['Int']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  url?: Maybe<Scalars['String']>
  width?: Maybe<Scalars['Int']>
}

export type Vs_AssetLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_AssetUrlArgs = {
  transform?: InputMaybe<Vs_ImageTransformOptions>
}

export type Vs_AssetCollection = {
  __typename?: 'vs_AssetCollection'
  items: Array<Maybe<Vs_Asset>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_AssetLinkingCollections = {
  __typename?: 'vs_AssetLinkingCollections'
  configurationConfirmationEmailCollection?: Maybe<Vs_ConfigurationConfirmationEmailCollection>
  configurationConfirmationNewCustomerEmailCollection?: Maybe<Vs_ConfigurationConfirmationNewCustomerEmailCollection>
  configurationInviteEmailCollection?: Maybe<Vs_ConfigurationInviteEmailCollection>
  egContentBlockCollection?: Maybe<Vs_EgContentBlockCollection>
  egFileWrapperCollection?: Maybe<Vs_EgFileWrapperCollection>
  egGlobalFooterCollection?: Maybe<Vs_EgGlobalFooterCollection>
  egGlobalHeaderCollection?: Maybe<Vs_EgGlobalHeaderCollection>
  egHeroCollection?: Maybe<Vs_EgHeroCollection>
  egLinkCollection?: Maybe<Vs_EgLinkCollection>
  egMediaCollection?: Maybe<Vs_EgMediaCollection>
  egMediaCollectionCollection?: Maybe<Vs_EgMediaCollectionCollection>
  egProductHeroCollection?: Maybe<Vs_EgProductHeroCollection>
  egProductSpecsPanelCollection?: Maybe<Vs_EgProductSpecsPanelCollection>
  egRpvStoryHeroCollection?: Maybe<Vs_EgRpvStoryHeroCollection>
  egSharingMetadataCollection?: Maybe<Vs_EgSharingMetadataCollection>
  egStoryBlockImageStackCollection?: Maybe<Vs_EgStoryBlockImageStackCollection>
  egStylePackCollection?: Maybe<Vs_EgStylePackCollection>
  egTextBlockCollection?: Maybe<Vs_EgTextBlockCollection>
  egTrimsSectionCollection?: Maybe<Vs_EgTrimsSectionCollection>
  egVideoCollection?: Maybe<Vs_EgVideoCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  featureBannerCollection?: Maybe<Vs_FeatureBannerCollection>
  featureCollection?: Maybe<Vs_FeatureCollection>
  featuresSectionCollection?: Maybe<Vs_FeaturesSectionCollection>
  flUiElementCollection?: Maybe<Vs_FlUiElementCollection>
  footerCollection?: Maybe<Vs_FooterCollection>
  headerCollection?: Maybe<Vs_HeaderCollection>
  highlightSectionCollection?: Maybe<Vs_HighlightSectionCollection>
  linkCollection?: Maybe<Vs_LinkCollection>
  mediaCollection?: Maybe<Vs_MediaCollection>
  ntfyMediaCollection?: Maybe<Vs_NtfyMediaCollection>
  orderAccountPageCardCollection?: Maybe<Vs_OrderAccountPageCardCollection>
  orderAccountPageSectionCollection?: Maybe<Vs_OrderAccountPageSectionCollection>
  orderConfigAccessoryHeroBlockCollection?: Maybe<Vs_OrderConfigAccessoryHeroBlockCollection>
  orderConfigAccessoryImageBlockCollection?: Maybe<Vs_OrderConfigAccessoryImageBlockCollection>
  orderLinkCollection?: Maybe<Vs_OrderLinkCollection>
  orderMediaCollection?: Maybe<Vs_OrderMediaCollection>
  orderUiElementCollection?: Maybe<Vs_OrderUiElementCollection>
  orderVideoCollection?: Maybe<Vs_OrderVideoCollection>
  pageCollection?: Maybe<Vs_PageCollection>
  pagesCollection?: Maybe<Vs_PagesCollection>
  preOrderCancellationEmailCollection?: Maybe<Vs_PreOrderCancellationEmailCollection>
  preOrderConfirmationEmailCollection?: Maybe<Vs_PreOrderConfirmationEmailCollection>
  quoteCollection?: Maybe<Vs_QuoteCollection>
  quoteSectionCollection?: Maybe<Vs_QuoteSectionCollection>
  responsiveImageCollection?: Maybe<Vs_ResponsiveImageCollection>
  sharingMetadataCollection?: Maybe<Vs_SharingMetadataCollection>
  slideContentCollection?: Maybe<Vs_SlideContentCollection>
  specViewCollection?: Maybe<Vs_SpecViewCollection>
  specificationsCollection?: Maybe<Vs_SpecificationsCollection>
  storySectionCollection?: Maybe<Vs_StorySectionCollection>
  t2DUiElementCollection?: Maybe<Vs_T2DUiElementCollection>
  technologyFeatureCollection?: Maybe<Vs_TechnologyFeatureCollection>
  technologyTabCollection?: Maybe<Vs_TechnologyTabCollection>
  videoCollection?: Maybe<Vs_VideoCollection>
  videoSectionCollection?: Maybe<Vs_VideoSectionCollection>
  vsUiElementCollection?: Maybe<Vs_VsUiElementCollection>
}

export type Vs_AssetLinkingCollectionsConfigurationConfirmationEmailCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsConfigurationConfirmationNewCustomerEmailCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsConfigurationInviteEmailCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgContentBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgFileWrapperCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgGlobalFooterCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgGlobalHeaderCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgLinkCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgMediaCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgMediaCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgProductHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgProductSpecsPanelCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgRpvStoryHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgSharingMetadataCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgStoryBlockImageStackCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgStylePackCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgTextBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgTrimsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEgVideoCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsFeatureBannerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsFeatureCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsFeaturesSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsFlUiElementCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsFooterCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsHeaderCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsHighlightSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsLinkCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsMediaCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsNtfyMediaCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsOrderAccountPageCardCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsOrderAccountPageSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsOrderConfigAccessoryHeroBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsOrderConfigAccessoryImageBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsOrderLinkCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsOrderMediaCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsOrderUiElementCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsOrderVideoCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsPagesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsPreOrderCancellationEmailCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsPreOrderConfirmationEmailCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsQuoteCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsQuoteSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsResponsiveImageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsSharingMetadataCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsSlideContentCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsSpecViewCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsSpecificationsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsT2DUiElementCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsTechnologyFeatureCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsTechnologyTabCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsVideoCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsVideoSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_AssetLinkingCollectionsVsUiElementCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Banner = Vs_Entry & {
  __typename?: 'vs_Banner'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_BannerLinkingCollections>
  media?: Maybe<Vs_Media>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_BannerLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_BannerMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_BannerSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_BannerTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_BannerCollection = {
  __typename?: 'vs_BannerCollection'
  items: Array<Maybe<Vs_Banner>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_BannerLinkingCollections = {
  __typename?: 'vs_BannerLinkingCollections'
  basePageCollection?: Maybe<Vs_BasePageCollection>
  careersPageCollection?: Maybe<Vs_CareersPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  faqPageCollection?: Maybe<Vs_FaqPageCollection>
  homePageCollection?: Maybe<Vs_HomePageCollection>
  rivianIdHomePageCollection?: Maybe<Vs_RivianIdHomePageCollection>
  rivianIdProfilePageCollection?: Maybe<Vs_RivianIdProfilePageCollection>
  rivianIdPwResetPageCollection?: Maybe<Vs_RivianIdPwResetPageCollection>
  rivianIdRegistrationPageCollection?: Maybe<Vs_RivianIdRegistrationPageCollection>
  thankYouPageCollection?: Maybe<Vs_ThankYouPageCollection>
}

export type Vs_BannerLinkingCollectionsBasePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_BannerLinkingCollectionsCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_BannerLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_BannerLinkingCollectionsFaqPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_BannerLinkingCollectionsHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_BannerLinkingCollectionsRivianIdHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_BannerLinkingCollectionsRivianIdProfilePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_BannerLinkingCollectionsRivianIdPwResetPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_BannerLinkingCollectionsRivianIdRegistrationPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_BannerLinkingCollectionsThankYouPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_BasePage = Vs_Entry & {
  __typename?: 'vs_BasePage'
  banner?: Maybe<Vs_Banner>
  body?: Maybe<Vs_BasePageBody>
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_BasePageLinkingCollections>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_BasePageBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_BasePageBodyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_BasePageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_BasePageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_BasePageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_BasePageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_BasePageBody = {
  __typename?: 'vs_BasePageBody'
  links: Vs_BasePageBodyLinks
}

export type Vs_BasePageBodyAssets = {
  __typename?: 'vs_BasePageBodyAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_BasePageBodyEntries = {
  __typename?: 'vs_BasePageBodyEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_BasePageBodyLinks = {
  __typename?: 'vs_BasePageBodyLinks'
  assets: Vs_BasePageBodyAssets
  entries: Vs_BasePageBodyEntries
}

export type Vs_BasePageCollection = {
  __typename?: 'vs_BasePageCollection'
  items: Array<Maybe<Vs_BasePage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_BasePageLinkingCollections = {
  __typename?: 'vs_BasePageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_BasePageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_CsatData = {
  comment?: InputMaybe<Scalars['String']>
  context?: InputMaybe<Scalars['String']>
  question?: InputMaybe<Scalars['String']>
  rating?: InputMaybe<Vs_CsatRating>
  type: Scalars['String']
}

export type Vs_CsatIdentifier = {
  id: Scalars['String']
  name: Scalars['String']
}

export type Vs_CsatInput = {
  header: Vs_DatalakeHeader
  newImage: Vs_CsatMeta
}

export type Vs_CsatMeta = {
  data?: InputMaybe<Array<InputMaybe<Vs_CsatData>>>
  from: Scalars['String']
  identifiers?: InputMaybe<Array<InputMaybe<Vs_CsatIdentifier>>>
}

export type Vs_CsatRating = {
  scale: Scalars['String']
  value: Scalars['String']
}

export type Vs_CsatResponse = {
  __typename?: 'vs_CSATResponse'
  message?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  status?: Maybe<Scalars['String']>
}

export type Vs_CareersPage = Vs_Entry & {
  __typename?: 'vs_CareersPage'
  banner?: Maybe<Vs_Banner>
  contentfulMetadata: Vs_ContentfulMetadata
  helperText?: Maybe<Array<Maybe<Scalars['String']>>>
  linkedFrom?: Maybe<Vs_CareersPageLinkingCollections>
  locationOptions?: Maybe<Vs_LocationsSection>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  storySection?: Maybe<Vs_StorySection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_CareersPageBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_CareersPageHelperTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CareersPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_CareersPageLocationOptionsArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_CareersPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_CareersPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CareersPageStorySectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_CareersPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CareersPageCollection = {
  __typename?: 'vs_CareersPageCollection'
  items: Array<Maybe<Vs_CareersPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_CareersPageLinkingCollections = {
  __typename?: 'vs_CareersPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_CareersPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ChargingPage = Vs_Entry & {
  __typename?: 'vs_ChargingPage'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_ChargingPageLinkingCollections>
  sys: Vs_Sys
}

export type Vs_ChargingPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ChargingPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ChargingPageLinkingCollections = {
  __typename?: 'vs_ChargingPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_ChargingPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_CloudinaryDemo = Vs_Entry & {
  __typename?: 'vs_CloudinaryDemo'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_CloudinaryDemoLinkingCollections>
  sys: Vs_Sys
}

export type Vs_CloudinaryDemoCloudinaryImageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CloudinaryDemoLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_CloudinaryDemoLinkingCollections = {
  __typename?: 'vs_CloudinaryDemoLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_CloudinaryDemoLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ConfigurationConfirmationEmail = Vs_Entry & {
  __typename?: 'vs_ConfigurationConfirmationEmail'
  bannerImage?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_ConfigurationConfirmationEmailLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_ConfigurationConfirmationEmailBannerImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ConfigurationConfirmationEmailLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ConfigurationConfirmationEmailTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ConfigurationConfirmationEmailCollection = {
  __typename?: 'vs_ConfigurationConfirmationEmailCollection'
  items: Array<Maybe<Vs_ConfigurationConfirmationEmail>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ConfigurationConfirmationEmailLinkingCollections = {
  __typename?: 'vs_ConfigurationConfirmationEmailLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_ConfigurationConfirmationEmailLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ConfigurationConfirmationNewCustomerEmail = Vs_Entry & {
  __typename?: 'vs_ConfigurationConfirmationNewCustomerEmail'
  bannerImage?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_ConfigurationConfirmationNewCustomerEmailLinkingCollections>
  r1SBannerImage?: Maybe<Vs_Asset>
  r1TBannerImage?: Maybe<Vs_Asset>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_ConfigurationConfirmationNewCustomerEmailBannerImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ConfigurationConfirmationNewCustomerEmailLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ConfigurationConfirmationNewCustomerEmailR1SBannerImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ConfigurationConfirmationNewCustomerEmailR1TBannerImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ConfigurationConfirmationNewCustomerEmailTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ConfigurationConfirmationNewCustomerEmailCollection = {
  __typename?: 'vs_ConfigurationConfirmationNewCustomerEmailCollection'
  items: Array<Maybe<Vs_ConfigurationConfirmationNewCustomerEmail>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ConfigurationConfirmationNewCustomerEmailLinkingCollections = {
  __typename?: 'vs_ConfigurationConfirmationNewCustomerEmailLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_ConfigurationConfirmationNewCustomerEmailLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ConfigurationInviteEmail = Vs_Entry & {
  __typename?: 'vs_ConfigurationInviteEmail'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_ConfigurationInviteEmailLinkingCollections>
  r1SImage?: Maybe<Vs_Asset>
  r1TImage?: Maybe<Vs_Asset>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_ConfigurationInviteEmailLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ConfigurationInviteEmailR1SImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ConfigurationInviteEmailR1TImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ConfigurationInviteEmailTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ConfigurationInviteEmailCollection = {
  __typename?: 'vs_ConfigurationInviteEmailCollection'
  items: Array<Maybe<Vs_ConfigurationInviteEmail>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ConfigurationInviteEmailLinkingCollections = {
  __typename?: 'vs_ConfigurationInviteEmailLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_ConfigurationInviteEmailLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ContentTypeLocation = Vs_Entry & {
  __typename?: 'vs_ContentTypeLocation'
  contentfulMetadata: Vs_ContentfulMetadata
  id?: Maybe<Scalars['String']>
  label?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_ContentTypeLocationLinkingCollections>
  location?: Maybe<Vs_Location>
  preLabel?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_ContentTypeLocationIdArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ContentTypeLocationLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ContentTypeLocationLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ContentTypeLocationLocationArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ContentTypeLocationPreLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ContentTypeLocationLinkingCollections = {
  __typename?: 'vs_ContentTypeLocationLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  locationsSectionCollection?: Maybe<Vs_LocationsSectionCollection>
}

export type Vs_ContentTypeLocationLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ContentTypeLocationLinkingCollectionsLocationsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ContentTypeString = Vs_Entry & {
  __typename?: 'vs_ContentTypeString'
  contentfulMetadata: Vs_ContentfulMetadata
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_ContentTypeStringLinkingCollections>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_ContentTypeStringKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ContentTypeStringLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ContentTypeStringValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ContentTypeStringLinkingCollections = {
  __typename?: 'vs_ContentTypeStringLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_ContentTypeStringLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ContentfulMetadata = {
  __typename?: 'vs_ContentfulMetadata'
  tags: Array<Maybe<Vs_ContentfulTag>>
}

export type Vs_ContentfulMetadataFilter = {
  tags?: InputMaybe<Vs_ContentfulMetadataTagsFilter>
  tags_exists?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ContentfulMetadataTagsFilter = {
  id_contains_all?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  id_contains_none?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  id_contains_some?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ContentfulTag = {
  __typename?: 'vs_ContentfulTag'
  id?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
}

export type Vs_CsChatString = Vs_Entry & {
  __typename?: 'vs_CsChatString'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_CsChatStringLinkingCollections>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_CsChatStringEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CsChatStringKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CsChatStringLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_CsChatStringValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CsChatStringGroup = Vs_Entry & {
  __typename?: 'vs_CsChatStringGroup'
  contentfulMetadata: Vs_ContentfulMetadata
  csChatStringsCollection?: Maybe<Vs_CsChatStringGroupCsChatStringsCollection>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_CsChatStringGroupLinkingCollections>
  name?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_CsChatStringGroupCsChatStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_CsChatStringGroupEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CsChatStringGroupLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_CsChatStringGroupNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CsChatStringGroupCollection = {
  __typename?: 'vs_CsChatStringGroupCollection'
  items: Array<Maybe<Vs_CsChatStringGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_CsChatStringGroupCsChatStringsCollection = {
  __typename?: 'vs_CsChatStringGroupCsChatStringsCollection'
  items: Array<Maybe<Vs_CsChatString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_CsChatStringGroupLinkingCollections = {
  __typename?: 'vs_CsChatStringGroupLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_CsChatStringGroupLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_CsChatStringLinkingCollections = {
  __typename?: 'vs_CsChatStringLinkingCollections'
  csChatStringGroupCollection?: Maybe<Vs_CsChatStringGroupCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_CsChatStringLinkingCollectionsCsChatStringGroupCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_CsChatStringLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_CsSupportPageString = Vs_Entry & {
  __typename?: 'vs_CsSupportPageString'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_CsSupportPageStringLinkingCollections>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_CsSupportPageStringEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CsSupportPageStringKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CsSupportPageStringLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_CsSupportPageStringValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CsSupportPageStringGroup = Vs_Entry & {
  __typename?: 'vs_CsSupportPageStringGroup'
  contentfulMetadata: Vs_ContentfulMetadata
  csSupportPageStringCollection?: Maybe<Vs_CsSupportPageStringGroupCsSupportPageStringCollection>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_CsSupportPageStringGroupLinkingCollections>
  name?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_CsSupportPageStringGroupCsSupportPageStringCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_CsSupportPageStringGroupEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CsSupportPageStringGroupLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_CsSupportPageStringGroupNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_CsSupportPageStringGroupCollection = {
  __typename?: 'vs_CsSupportPageStringGroupCollection'
  items: Array<Maybe<Vs_CsSupportPageStringGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_CsSupportPageStringGroupCsSupportPageStringCollection = {
  __typename?: 'vs_CsSupportPageStringGroupCsSupportPageStringCollection'
  items: Array<Maybe<Vs_CsSupportPageString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_CsSupportPageStringGroupLinkingCollections = {
  __typename?: 'vs_CsSupportPageStringGroupLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_CsSupportPageStringGroupLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_CsSupportPageStringLinkingCollections = {
  __typename?: 'vs_CsSupportPageStringLinkingCollections'
  csSupportPageStringGroupCollection?: Maybe<Vs_CsSupportPageStringGroupCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_CsSupportPageStringLinkingCollectionsCsSupportPageStringGroupCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_CsSupportPageStringLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_DatalakeHeader = {
  primaryKey: Scalars['String']
  source?: InputMaybe<Scalars['String']>
  tableName?: InputMaybe<Scalars['String']>
}

export type Vs_DemoString = Vs_Entry & {
  __typename?: 'vs_DemoString'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_DemoStringLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_DemoStringLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_DemoStringTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_DemoStringLinkingCollections = {
  __typename?: 'vs_DemoStringLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_DemoStringLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccordionBlock = Vs_Entry & {
  __typename?: 'vs_EgAccordionBlock'
  accordionBlocksCollection?: Maybe<Vs_EgAccordionBlockAccordionBlocksCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_EgAccordionBlockDescription>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgAccordionBlockLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgAccordionBlockAccordionBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccordionBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccordionBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccordionBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAccordionBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccordionBlockAccordionBlocksCollection = {
  __typename?: 'vs_EgAccordionBlockAccordionBlocksCollection'
  items: Array<Maybe<Vs_EgAccordionGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAccordionBlockCollection = {
  __typename?: 'vs_EgAccordionBlockCollection'
  items: Array<Maybe<Vs_EgAccordionBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAccordionBlockDescription = {
  __typename?: 'vs_EgAccordionBlockDescription'
  links: Vs_EgAccordionBlockDescriptionLinks
}

export type Vs_EgAccordionBlockDescriptionAssets = {
  __typename?: 'vs_EgAccordionBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgAccordionBlockDescriptionEntries = {
  __typename?: 'vs_EgAccordionBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgAccordionBlockDescriptionLinks = {
  __typename?: 'vs_EgAccordionBlockDescriptionLinks'
  assets: Vs_EgAccordionBlockDescriptionAssets
  entries: Vs_EgAccordionBlockDescriptionEntries
}

export type Vs_EgAccordionBlockLinkingCollections = {
  __typename?: 'vs_EgAccordionBlockLinkingCollections'
  egCareersPeopleSectionCollection?: Maybe<Vs_EgCareersPeopleSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAccordionBlockLinkingCollectionsEgCareersPeopleSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccordionBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccordionGroup = Vs_Entry & {
  __typename?: 'vs_EgAccordionGroup'
  bodyCopy?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgAccordionGroupLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgAccordionGroupBodyCopyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccordionGroupEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccordionGroupLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAccordionGroupMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccordionGroupTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccordionGroupCollection = {
  __typename?: 'vs_EgAccordionGroupCollection'
  items: Array<Maybe<Vs_EgAccordionGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAccordionGroupLinkingCollections = {
  __typename?: 'vs_EgAccordionGroupLinkingCollections'
  egAccordionBlockCollection?: Maybe<Vs_EgAccordionBlockCollection>
  egCareersLocationsSectionCollection?: Maybe<Vs_EgCareersLocationsSectionCollection>
  egRpvAccordionBlockCollection?: Maybe<Vs_EgRpvAccordionBlockCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAccordionGroupLinkingCollectionsEgAccordionBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccordionGroupLinkingCollectionsEgCareersLocationsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccordionGroupLinkingCollectionsEgRpvAccordionBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccordionGroupLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountHomeContentBlock = Vs_Entry & {
  __typename?: 'vs_EgAccountHomeContentBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  ctaLink?: Maybe<Vs_EgAccountHomeContentBlockCtaLink>
  description?: Maybe<Vs_EgString>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgAccountHomeContentBlockLinkingCollections>
  pretitle?: Maybe<Vs_EgString>
  sys: Vs_Sys
  title?: Maybe<Vs_EgString>
}

export type Vs_EgAccountHomeContentBlockCtaLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomeContentBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomeContentBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccountHomeContentBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAccountHomeContentBlockPretitleArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomeContentBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomeContentBlockCollection = {
  __typename?: 'vs_EgAccountHomeContentBlockCollection'
  items: Array<Maybe<Vs_EgAccountHomeContentBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAccountHomeContentBlockCtaLink = Vs_EgLink | Vs_EgShellInternalLink

export type Vs_EgAccountHomeContentBlockLinkingCollections = {
  __typename?: 'vs_EgAccountHomeContentBlockLinkingCollections'
  egAccountHomeImageCopySectionCollection?: Maybe<Vs_EgAccountHomeImageCopySectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAccountHomeContentBlockLinkingCollectionsEgAccountHomeImageCopySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountHomeContentBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountHomeHero = Vs_Entry & {
  __typename?: 'vs_EgAccountHomeHero'
  backgroundImage?: Maybe<Vs_EgBreakpointMedia>
  contentfulMetadata: Vs_ContentfulMetadata
  displayText?: Maybe<Vs_EgString>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgAccountHomeHeroLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgAccountHomeHeroBackgroundImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomeHeroDisplayTextArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomeHeroEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccountHomeHeroLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAccountHomeHeroCollection = {
  __typename?: 'vs_EgAccountHomeHeroCollection'
  items: Array<Maybe<Vs_EgAccountHomeHero>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAccountHomeHeroLinkingCollections = {
  __typename?: 'vs_EgAccountHomeHeroLinkingCollections'
  egAccountHomepageCollection?: Maybe<Vs_EgAccountHomepageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAccountHomeHeroLinkingCollectionsEgAccountHomepageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountHomeHeroLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountHomeImageCopySection = Vs_Entry & {
  __typename?: 'vs_EgAccountHomeImageCopySection'
  blocks?: Maybe<Vs_EgAccountHomeContentBlock>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgAccountHomeImageCopySectionLinkingCollections>
  media?: Maybe<Vs_EgBreakpointMedia>
  ownershipState?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgAccountHomeImageCopySectionBlocksArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomeImageCopySectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccountHomeImageCopySectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAccountHomeImageCopySectionMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomeImageCopySectionOwnershipStateArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccountHomeImageCopySectionCollection = {
  __typename?: 'vs_EgAccountHomeImageCopySectionCollection'
  items: Array<Maybe<Vs_EgAccountHomeImageCopySection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAccountHomeImageCopySectionLinkingCollections = {
  __typename?: 'vs_EgAccountHomeImageCopySectionLinkingCollections'
  egAccountHomepageCollection?: Maybe<Vs_EgAccountHomepageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAccountHomeImageCopySectionLinkingCollectionsEgAccountHomepageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountHomeImageCopySectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountHomeVideoSection = Vs_Entry & {
  __typename?: 'vs_EgAccountHomeVideoSection'
  backgroundImage?: Maybe<Vs_EgBreakpointMedia>
  contentfulMetadata: Vs_ContentfulMetadata
  egVideo?: Maybe<Vs_EgVideo>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgAccountHomeVideoSectionLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgAccountHomeVideoSectionBackgroundImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomeVideoSectionEgVideoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomeVideoSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccountHomeVideoSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAccountHomeVideoSectionCollection = {
  __typename?: 'vs_EgAccountHomeVideoSectionCollection'
  items: Array<Maybe<Vs_EgAccountHomeVideoSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAccountHomeVideoSectionLinkingCollections = {
  __typename?: 'vs_EgAccountHomeVideoSectionLinkingCollections'
  egAccountHomepageCollection?: Maybe<Vs_EgAccountHomepageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAccountHomeVideoSectionLinkingCollectionsEgAccountHomepageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountHomeVideoSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountHomepage = Vs_Entry & {
  __typename?: 'vs_EgAccountHomepage'
  contentfulMetadata: Vs_ContentfulMetadata
  egAccountMediaSection?: Maybe<Vs_EgAccountMediaSection>
  egAccountVideoSection?: Maybe<Vs_EgAccountHomeVideoSection>
  egHero?: Maybe<Vs_EgAccountHomeHero>
  entryTitle?: Maybe<Scalars['String']>
  imageCopySectionsCollection?: Maybe<Vs_EgAccountHomepageImageCopySectionsCollection>
  linkedFrom?: Maybe<Vs_EgAccountHomepageLinkingCollections>
  storySection?: Maybe<Vs_EgStorySection>
  sys: Vs_Sys
}

export type Vs_EgAccountHomepageEgAccountMediaSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomepageEgAccountVideoSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomepageEgHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomepageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccountHomepageImageCopySectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountHomepageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAccountHomepageStorySectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountHomepageCollection = {
  __typename?: 'vs_EgAccountHomepageCollection'
  items: Array<Maybe<Vs_EgAccountHomepage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAccountHomepageImageCopySectionsCollection = {
  __typename?: 'vs_EgAccountHomepageImageCopySectionsCollection'
  items: Array<Maybe<Vs_EgAccountHomeImageCopySection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAccountHomepageLinkingCollections = {
  __typename?: 'vs_EgAccountHomepageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAccountHomepageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountMediaSection = Vs_Entry & {
  __typename?: 'vs_EgAccountMediaSection'
  contentfulMetadata: Vs_ContentfulMetadata
  ctaLink?: Maybe<Vs_EgAccountMediaSectionCtaLink>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgAccountMediaSectionLinkingCollections>
  media?: Maybe<Vs_EgBreakpointMedia>
  sys: Vs_Sys
}

export type Vs_EgAccountMediaSectionCtaLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountMediaSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAccountMediaSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAccountMediaSectionMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAccountMediaSectionCollection = {
  __typename?: 'vs_EgAccountMediaSectionCollection'
  items: Array<Maybe<Vs_EgAccountMediaSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAccountMediaSectionCtaLink = Vs_EgLink | Vs_EgShellInternalLink

export type Vs_EgAccountMediaSectionLinkingCollections = {
  __typename?: 'vs_EgAccountMediaSectionLinkingCollections'
  egAccountHomepageCollection?: Maybe<Vs_EgAccountHomepageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAccountMediaSectionLinkingCollectionsEgAccountHomepageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAccountMediaSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgActivity = Vs_Entry & {
  __typename?: 'vs_EgActivity'
  amsId?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  image?: Maybe<Vs_EgMedia>
  linkedFrom?: Maybe<Vs_EgActivityLinkingCollections>
  maxGroupSize?: Maybe<Scalars['Int']>
  name?: Maybe<Scalars['String']>
  stringsCollection?: Maybe<Vs_EgActivityStringsCollection>
  sys: Vs_Sys
  videoSection?: Maybe<Vs_EgCarousel>
}

export type Vs_EgActivityAmsIdArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgActivityDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgActivityEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgActivityImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgActivityLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgActivityMaxGroupSizeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgActivityNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgActivityStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgActivityVideoSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgActivityCollection = {
  __typename?: 'vs_EgActivityCollection'
  items: Array<Maybe<Vs_EgActivity>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgActivityLinkingCollections = {
  __typename?: 'vs_EgActivityLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgActivityLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgActivityStringsCollection = {
  __typename?: 'vs_EgActivityStringsCollection'
  items: Array<Maybe<Vs_EgString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAnchorNav = Vs_Entry & {
  __typename?: 'vs_EgAnchorNav'
  anchorLinksCollection?: Maybe<Vs_EgAnchorNavAnchorLinksCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  externalLink?: Maybe<Vs_EgLink>
  linkedFrom?: Maybe<Vs_EgAnchorNavLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgAnchorNavAnchorLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAnchorNavEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAnchorNavExternalLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAnchorNavLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAnchorNavTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAnchorNavAnchorLinksCollection = {
  __typename?: 'vs_EgAnchorNavAnchorLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAnchorNavCollection = {
  __typename?: 'vs_EgAnchorNavCollection'
  items: Array<Maybe<Vs_EgAnchorNav>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAnchorNavLinkingCollections = {
  __typename?: 'vs_EgAnchorNavLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAnchorNavLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAnnouncementBanner = Vs_Entry & {
  __typename?: 'vs_EgAnnouncementBanner'
  bannerHexColor?: Maybe<Scalars['String']>
  bodyText?: Maybe<Vs_EgAnnouncementBannerBodyText>
  contentfulMetadata: Vs_ContentfulMetadata
  enabledPaths?: Maybe<Array<Maybe<Scalars['String']>>>
  entryTitle?: Maybe<Scalars['String']>
  linkHexColor?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgAnnouncementBannerLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  textHexColor?: Maybe<Scalars['String']>
}

export type Vs_EgAnnouncementBannerBannerHexColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAnnouncementBannerBodyTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAnnouncementBannerEnabledPathsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAnnouncementBannerEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAnnouncementBannerLinkHexColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAnnouncementBannerLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAnnouncementBannerSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAnnouncementBannerTextHexColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAnnouncementBannerBodyText = {
  __typename?: 'vs_EgAnnouncementBannerBodyText'
  links: Vs_EgAnnouncementBannerBodyTextLinks
}

export type Vs_EgAnnouncementBannerBodyTextAssets = {
  __typename?: 'vs_EgAnnouncementBannerBodyTextAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgAnnouncementBannerBodyTextEntries = {
  __typename?: 'vs_EgAnnouncementBannerBodyTextEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgAnnouncementBannerBodyTextLinks = {
  __typename?: 'vs_EgAnnouncementBannerBodyTextLinks'
  assets: Vs_EgAnnouncementBannerBodyTextAssets
  entries: Vs_EgAnnouncementBannerBodyTextEntries
}

export type Vs_EgAnnouncementBannerLinkingCollections = {
  __typename?: 'vs_EgAnnouncementBannerLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAnnouncementBannerLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAppointmentDetailPage = Vs_Entry & {
  __typename?: 'vs_EgAppointmentDetailPage'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  heroImageOverlay?: Maybe<Vs_EgMedia>
  linkedFrom?: Maybe<Vs_EgAppointmentDetailPageLinkingCollections>
  slug?: Maybe<Scalars['String']>
  stringListsCollection?: Maybe<Vs_EgAppointmentDetailPageStringListsCollection>
  stringsCollection?: Maybe<Vs_EgAppointmentDetailPageStringsCollection>
  sys: Vs_Sys
}

export type Vs_EgAppointmentDetailPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAppointmentDetailPageHeroImageOverlayArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAppointmentDetailPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAppointmentDetailPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAppointmentDetailPageStringListsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAppointmentDetailPageStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAppointmentDetailPageCollection = {
  __typename?: 'vs_EgAppointmentDetailPageCollection'
  items: Array<Maybe<Vs_EgAppointmentDetailPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAppointmentDetailPageLinkingCollections = {
  __typename?: 'vs_EgAppointmentDetailPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAppointmentDetailPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAppointmentDetailPageStringListsCollection = {
  __typename?: 'vs_EgAppointmentDetailPageStringListsCollection'
  items: Array<Maybe<Vs_EgStringList>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAppointmentDetailPageStringsCollection = {
  __typename?: 'vs_EgAppointmentDetailPageStringsCollection'
  items: Array<Maybe<Vs_EgString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAppointmentSchedulerPage = Vs_Entry & {
  __typename?: 'vs_EgAppointmentSchedulerPage'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  heroImage?: Maybe<Vs_EgMedia>
  linkedFrom?: Maybe<Vs_EgAppointmentSchedulerPageLinkingCollections>
  slug?: Maybe<Scalars['String']>
  stringsCollection?: Maybe<Vs_EgAppointmentSchedulerPageStringsCollection>
  sys: Vs_Sys
}

export type Vs_EgAppointmentSchedulerPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAppointmentSchedulerPageHeroImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgAppointmentSchedulerPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgAppointmentSchedulerPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgAppointmentSchedulerPageStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAppointmentSchedulerPageCollection = {
  __typename?: 'vs_EgAppointmentSchedulerPageCollection'
  items: Array<Maybe<Vs_EgAppointmentSchedulerPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgAppointmentSchedulerPageLinkingCollections = {
  __typename?: 'vs_EgAppointmentSchedulerPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgAppointmentSchedulerPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgAppointmentSchedulerPageStringsCollection = {
  __typename?: 'vs_EgAppointmentSchedulerPageStringsCollection'
  items: Array<Maybe<Vs_EgString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgBreakpointMedia = Vs_Entry & {
  __typename?: 'vs_EgBreakpointMedia'
  altText?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgBreakpointMediaLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgBreakpointMediaAltTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgBreakpointMediaDesktopArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgBreakpointMediaEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgBreakpointMediaLaptopArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgBreakpointMediaLargerThanDesktopArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgBreakpointMediaLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgBreakpointMediaMobileArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgBreakpointMediaTabletArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgBreakpointMediaLinkingCollections = {
  __typename?: 'vs_EgBreakpointMediaLinkingCollections'
  egAccountHomeHeroCollection?: Maybe<Vs_EgAccountHomeHeroCollection>
  egAccountHomeImageCopySectionCollection?: Maybe<Vs_EgAccountHomeImageCopySectionCollection>
  egAccountHomeVideoSectionCollection?: Maybe<Vs_EgAccountHomeVideoSectionCollection>
  egAccountMediaSectionCollection?: Maybe<Vs_EgAccountMediaSectionCollection>
  egLeadCapturePageCollection?: Maybe<Vs_EgLeadCapturePageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgBreakpointMediaLinkingCollectionsEgAccountHomeHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgBreakpointMediaLinkingCollectionsEgAccountHomeImageCopySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgBreakpointMediaLinkingCollectionsEgAccountHomeVideoSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgBreakpointMediaLinkingCollectionsEgAccountMediaSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgBreakpointMediaLinkingCollectionsEgLeadCapturePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgBreakpointMediaLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCareersIntroSection = Vs_Entry & {
  __typename?: 'vs_EgCareersIntroSection'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_EgCareersIntroSectionDescription>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgCareersIntroSectionLinkingCollections>
  subtitle?: Maybe<Array<Maybe<Scalars['String']>>>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgCareersIntroSectionDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersIntroSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersIntroSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCareersIntroSectionSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersIntroSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersIntroSectionDescription = {
  __typename?: 'vs_EgCareersIntroSectionDescription'
  links: Vs_EgCareersIntroSectionDescriptionLinks
}

export type Vs_EgCareersIntroSectionDescriptionAssets = {
  __typename?: 'vs_EgCareersIntroSectionDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgCareersIntroSectionDescriptionEntries = {
  __typename?: 'vs_EgCareersIntroSectionDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgCareersIntroSectionDescriptionLinks = {
  __typename?: 'vs_EgCareersIntroSectionDescriptionLinks'
  assets: Vs_EgCareersIntroSectionDescriptionAssets
  entries: Vs_EgCareersIntroSectionDescriptionEntries
}

export type Vs_EgCareersIntroSectionLinkingCollections = {
  __typename?: 'vs_EgCareersIntroSectionLinkingCollections'
  egCareersPageCollection?: Maybe<Vs_EgCareersPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCareersIntroSectionLinkingCollectionsEgCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCareersIntroSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCareersLocationsSection = Vs_Entry & {
  __typename?: 'vs_EgCareersLocationsSection'
  accordionBlocksCollection?: Maybe<Vs_EgCareersLocationsSectionAccordionBlocksCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_EgCareersLocationsSectionDescription>
  entryTitle?: Maybe<Scalars['String']>
  image?: Maybe<Vs_EgMedia>
  linkedFrom?: Maybe<Vs_EgCareersLocationsSectionLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgCareersLocationsSectionAccordionBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCareersLocationsSectionDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersLocationsSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersLocationsSectionImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCareersLocationsSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCareersLocationsSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersLocationsSectionAccordionBlocksCollection = {
  __typename?: 'vs_EgCareersLocationsSectionAccordionBlocksCollection'
  items: Array<Maybe<Vs_EgAccordionGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCareersLocationsSectionCollection = {
  __typename?: 'vs_EgCareersLocationsSectionCollection'
  items: Array<Maybe<Vs_EgCareersLocationsSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCareersLocationsSectionDescription = {
  __typename?: 'vs_EgCareersLocationsSectionDescription'
  links: Vs_EgCareersLocationsSectionDescriptionLinks
}

export type Vs_EgCareersLocationsSectionDescriptionAssets = {
  __typename?: 'vs_EgCareersLocationsSectionDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgCareersLocationsSectionDescriptionEntries = {
  __typename?: 'vs_EgCareersLocationsSectionDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgCareersLocationsSectionDescriptionLinks = {
  __typename?: 'vs_EgCareersLocationsSectionDescriptionLinks'
  assets: Vs_EgCareersLocationsSectionDescriptionAssets
  entries: Vs_EgCareersLocationsSectionDescriptionEntries
}

export type Vs_EgCareersLocationsSectionLinkingCollections = {
  __typename?: 'vs_EgCareersLocationsSectionLinkingCollections'
  egCareersPageCollection?: Maybe<Vs_EgCareersPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCareersLocationsSectionLinkingCollectionsEgCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCareersLocationsSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCareersPage = Vs_Entry & {
  __typename?: 'vs_EgCareersPage'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  hero?: Maybe<Vs_EgHero>
  introSection?: Maybe<Vs_EgCareersIntroSection>
  jobOpeningsSection?: Maybe<Vs_EgJobOpeningsSection>
  linkedFrom?: Maybe<Vs_EgCareersPageLinkingCollections>
  locationsSection?: Maybe<Vs_EgCareersLocationsSection>
  navigation?: Maybe<Vs_EgStickyNav>
  peopleSection?: Maybe<Vs_EgCareersPeopleSection>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgCareersPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersPageHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCareersPageIntroSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCareersPageJobOpeningsSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCareersPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCareersPageLocationsSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCareersPageNavigationArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCareersPagePeopleSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCareersPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCareersPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersPageCollection = {
  __typename?: 'vs_EgCareersPageCollection'
  items: Array<Maybe<Vs_EgCareersPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCareersPageLinkingCollections = {
  __typename?: 'vs_EgCareersPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCareersPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCareersPeopleSection = Vs_Entry & {
  __typename?: 'vs_EgCareersPeopleSection'
  blocksCollection?: Maybe<Vs_EgCareersPeopleSectionBlocksCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgCareersPeopleSectionLinkingCollections>
  playList?: Maybe<Vs_EgCarousel>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgCareersPeopleSectionBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCareersPeopleSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersPeopleSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCareersPeopleSectionPlayListArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCareersPeopleSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCareersPeopleSectionBlocksCollection = {
  __typename?: 'vs_EgCareersPeopleSectionBlocksCollection'
  items: Array<Maybe<Vs_EgCareersPeopleSectionBlocksItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCareersPeopleSectionBlocksItem =
  | Vs_EgAccordionBlock
  | Vs_EgStoryBlockImageStack
  | Vs_EgStoryBlockQuote
  | Vs_EgStoryBlockText

export type Vs_EgCareersPeopleSectionCollection = {
  __typename?: 'vs_EgCareersPeopleSectionCollection'
  items: Array<Maybe<Vs_EgCareersPeopleSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCareersPeopleSectionLinkingCollections = {
  __typename?: 'vs_EgCareersPeopleSectionLinkingCollections'
  egCareersPageCollection?: Maybe<Vs_EgCareersPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCareersPeopleSectionLinkingCollectionsEgCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCareersPeopleSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarousel = Vs_Entry & {
  __typename?: 'vs_EgCarousel'
  closeOverlayLabel?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgCarouselLinkingCollections>
  loadMoreLabel?: Maybe<Scalars['String']>
  showOverlayLabel?: Maybe<Scalars['String']>
  slidesCollection?: Maybe<Vs_EgCarouselSlidesCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  variant?: Maybe<Scalars['String']>
  videoSupportMessage?: Maybe<Scalars['String']>
}

export type Vs_EgCarouselCloseOverlayLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCarouselLoadMoreLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselShowOverlayLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSlidesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselVariantArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselVideoSupportMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselCollection = {
  __typename?: 'vs_EgCarouselCollection'
  items: Array<Maybe<Vs_EgCarousel>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCarouselLinkingCollections = {
  __typename?: 'vs_EgCarouselLinkingCollections'
  egActivityCollection?: Maybe<Vs_EgActivityCollection>
  egCareersPeopleSectionCollection?: Maybe<Vs_EgCareersPeopleSectionCollection>
  egCarouselSectionCollection?: Maybe<Vs_EgCarouselSectionCollection>
  egHomePageCollection?: Maybe<Vs_EgHomePageCollection>
  egProductPageSectionCollection?: Maybe<Vs_EgProductPageSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCarouselLinkingCollectionsEgActivityCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselLinkingCollectionsEgCareersPeopleSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselLinkingCollectionsEgCarouselSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselLinkingCollectionsEgHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselLinkingCollectionsEgProductPageSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselOverlay = Vs_Entry & {
  __typename?: 'vs_EgCarouselOverlay'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgCarouselOverlayLinkingCollections>
  overlayBody?: Maybe<Vs_EgCarouselOverlayOverlayBody>
  overlayMedia?: Maybe<Vs_EgMedia>
  sys: Vs_Sys
}

export type Vs_EgCarouselOverlayEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselOverlayLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCarouselOverlayOverlayBodyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselOverlayOverlayMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCarouselOverlayCollection = {
  __typename?: 'vs_EgCarouselOverlayCollection'
  items: Array<Maybe<Vs_EgCarouselOverlay>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCarouselOverlayLinkingCollections = {
  __typename?: 'vs_EgCarouselOverlayLinkingCollections'
  egCarouselSlideCollection?: Maybe<Vs_EgCarouselSlideCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCarouselOverlayLinkingCollectionsEgCarouselSlideCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselOverlayLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselOverlayOverlayBody = {
  __typename?: 'vs_EgCarouselOverlayOverlayBody'
  links: Vs_EgCarouselOverlayOverlayBodyLinks
}

export type Vs_EgCarouselOverlayOverlayBodyAssets = {
  __typename?: 'vs_EgCarouselOverlayOverlayBodyAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgCarouselOverlayOverlayBodyEntries = {
  __typename?: 'vs_EgCarouselOverlayOverlayBodyEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgCarouselOverlayOverlayBodyLinks = {
  __typename?: 'vs_EgCarouselOverlayOverlayBodyLinks'
  assets: Vs_EgCarouselOverlayOverlayBodyAssets
  entries: Vs_EgCarouselOverlayOverlayBodyEntries
}

export type Vs_EgCarouselSection = Vs_Entry & {
  __typename?: 'vs_EgCarouselSection'
  backgroundColor?: Maybe<Scalars['String']>
  carousel?: Maybe<Vs_EgCarousel>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgCarouselSectionLinkingCollections>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgCarouselSectionBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSectionCarouselArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCarouselSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCarouselSectionSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSectionCollection = {
  __typename?: 'vs_EgCarouselSectionCollection'
  items: Array<Maybe<Vs_EgCarouselSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCarouselSectionLinkingCollections = {
  __typename?: 'vs_EgCarouselSectionLinkingCollections'
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCarouselSectionLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselSectionLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselSlide = Vs_Entry & {
  __typename?: 'vs_EgCarouselSlide'
  block?: Maybe<Vs_EgMediaBlock>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgCarouselSlideLinkingCollections>
  overlayCtaLabel?: Maybe<Scalars['String']>
  richDescription?: Maybe<Vs_EgCarouselSlideRichDescription>
  showOverlay?: Maybe<Scalars['Boolean']>
  slideCaption?: Maybe<Scalars['String']>
  slideContent?: Maybe<Vs_EgCarouselSlideSlideContent>
  slideImage?: Maybe<Vs_Media>
  slideOverlay?: Maybe<Vs_EgCarouselOverlay>
  slideText?: Maybe<Scalars['String']>
  slideVideo?: Maybe<Vs_EgVideo>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgCarouselSlideBlockArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCarouselSlideEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSlideLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCarouselSlideOverlayCtaLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSlideRichDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSlideShowOverlayArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSlideSlideCaptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSlideSlideContentArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCarouselSlideSlideImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCarouselSlideSlideOverlayArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCarouselSlideSlideTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSlideSlideVideoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCarouselSlideTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCarouselSlideCollection = {
  __typename?: 'vs_EgCarouselSlideCollection'
  items: Array<Maybe<Vs_EgCarouselSlide>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCarouselSlideLinkingCollections = {
  __typename?: 'vs_EgCarouselSlideLinkingCollections'
  egCarouselCollection?: Maybe<Vs_EgCarouselCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCarouselSlideLinkingCollectionsEgCarouselCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselSlideLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCarouselSlideRichDescription = {
  __typename?: 'vs_EgCarouselSlideRichDescription'
  links: Vs_EgCarouselSlideRichDescriptionLinks
}

export type Vs_EgCarouselSlideRichDescriptionAssets = {
  __typename?: 'vs_EgCarouselSlideRichDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgCarouselSlideRichDescriptionEntries = {
  __typename?: 'vs_EgCarouselSlideRichDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgCarouselSlideRichDescriptionLinks = {
  __typename?: 'vs_EgCarouselSlideRichDescriptionLinks'
  assets: Vs_EgCarouselSlideRichDescriptionAssets
  entries: Vs_EgCarouselSlideRichDescriptionEntries
}

export type Vs_EgCarouselSlideSlideContent = Vs_EgMedia | Vs_EgTabComponent | Vs_EgVideo

export type Vs_EgCarouselSlidesCollection = {
  __typename?: 'vs_EgCarouselSlidesCollection'
  items: Array<Maybe<Vs_EgCarouselSlide>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCategory = Vs_Entry & {
  __typename?: 'vs_EgCategory'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  filesCollection?: Maybe<Vs_EgCategoryFilesCollection>
  level?: Maybe<Scalars['Int']>
  linkedFrom?: Maybe<Vs_EgCategoryLinkingCollections>
  slug?: Maybe<Scalars['String']>
  subCategoriesCollection?: Maybe<Vs_EgCategorySubCategoriesCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgCategoryEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCategoryFilesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCategoryLevelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCategoryLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCategorySlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCategorySubCategoriesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCategoryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCategoryCollection = {
  __typename?: 'vs_EgCategoryCollection'
  items: Array<Maybe<Vs_EgCategory>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCategoryFilesCollection = {
  __typename?: 'vs_EgCategoryFilesCollection'
  items: Array<Maybe<Vs_EgFileWrapper>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCategoryLinkingCollections = {
  __typename?: 'vs_EgCategoryLinkingCollections'
  egCategoryCollection?: Maybe<Vs_EgCategoryCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCategoryLinkingCollectionsEgCategoryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCategoryLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCategorySubCategoriesCollection = {
  __typename?: 'vs_EgCategorySubCategoriesCollection'
  items: Array<Maybe<Vs_EgCategory>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgChatString = Vs_Entry & {
  __typename?: 'vs_EgChatString'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgChatStringLinkingCollections>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_EgChatStringEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgChatStringKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgChatStringLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgChatStringValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgChatStringGroup = Vs_Entry & {
  __typename?: 'vs_EgChatStringGroup'
  contentfulMetadata: Vs_ContentfulMetadata
  egChatStringsCollection?: Maybe<Vs_EgChatStringGroupEgChatStringsCollection>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgChatStringGroupLinkingCollections>
  name?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgChatStringGroupEgChatStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgChatStringGroupEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgChatStringGroupLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgChatStringGroupNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgChatStringGroupCollection = {
  __typename?: 'vs_EgChatStringGroupCollection'
  items: Array<Maybe<Vs_EgChatStringGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgChatStringGroupEgChatStringsCollection = {
  __typename?: 'vs_EgChatStringGroupEgChatStringsCollection'
  items: Array<Maybe<Vs_EgChatString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgChatStringGroupLinkingCollections = {
  __typename?: 'vs_EgChatStringGroupLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgChatStringGroupLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgChatStringLinkingCollections = {
  __typename?: 'vs_EgChatStringLinkingCollections'
  egChatStringGroupCollection?: Maybe<Vs_EgChatStringGroupCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgChatStringLinkingCollectionsEgChatStringGroupCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgChatStringLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCheckoutType = Vs_Entry & {
  __typename?: 'vs_EgCheckoutType'
  contentfulMetadata: Vs_ContentfulMetadata
  definitionItem?: Maybe<Vs_EgDefinitionItem>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgCheckoutTypeLinkingCollections>
  secondaryText?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgCheckoutTypeDefinitionItemArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgCheckoutTypeEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCheckoutTypeLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCheckoutTypeSecondaryTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCheckoutTypeCollection = {
  __typename?: 'vs_EgCheckoutTypeCollection'
  items: Array<Maybe<Vs_EgCheckoutType>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCheckoutTypeContainer = Vs_Entry & {
  __typename?: 'vs_EgCheckoutTypeContainer'
  checkoutTypesCollection?: Maybe<Vs_EgCheckoutTypeContainerCheckoutTypesCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgCheckoutTypeContainerLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgCheckoutTypeContainerCheckoutTypesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCheckoutTypeContainerEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCheckoutTypeContainerLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCheckoutTypeContainerCheckoutTypesCollection = {
  __typename?: 'vs_EgCheckoutTypeContainerCheckoutTypesCollection'
  items: Array<Maybe<Vs_EgCheckoutType>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCheckoutTypeContainerCollection = {
  __typename?: 'vs_EgCheckoutTypeContainerCollection'
  items: Array<Maybe<Vs_EgCheckoutTypeContainer>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCheckoutTypeContainerLinkingCollections = {
  __typename?: 'vs_EgCheckoutTypeContainerLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCheckoutTypeContainerLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCheckoutTypeLinkingCollections = {
  __typename?: 'vs_EgCheckoutTypeLinkingCollections'
  egCheckoutTypeContainerCollection?: Maybe<Vs_EgCheckoutTypeContainerCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCheckoutTypeLinkingCollectionsEgCheckoutTypeContainerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCheckoutTypeLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCollectionsContainer = Vs_Entry & {
  __typename?: 'vs_EgCollectionsContainer'
  collectionsCollection?: Maybe<Vs_EgCollectionsContainerCollectionsCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  label?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgCollectionsContainerLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgCollectionsContainerCollectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCollectionsContainerEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCollectionsContainerLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgCollectionsContainerLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgCollectionsContainerCollection = {
  __typename?: 'vs_EgCollectionsContainerCollection'
  items: Array<Maybe<Vs_EgCollectionsContainer>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCollectionsContainerCollectionsCollection = {
  __typename?: 'vs_EgCollectionsContainerCollectionsCollection'
  items: Array<Maybe<Vs_EgTag>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgCollectionsContainerLinkingCollections = {
  __typename?: 'vs_EgCollectionsContainerLinkingCollections'
  egRefineMenuCollection?: Maybe<Vs_EgRefineMenuCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgCollectionsContainerLinkingCollectionsEgRefineMenuCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgCollectionsContainerLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgColumnSection = Vs_Entry & {
  __typename?: 'vs_EgColumnSection'
  anchorTag?: Maybe<Scalars['String']>
  backgroundColor?: Maybe<Scalars['String']>
  blocksCollection?: Maybe<Vs_EgColumnSectionBlocksCollection>
  columns?: Maybe<Scalars['Float']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgColumnSectionLinkingCollections>
  stylePack?: Maybe<Vs_EgStylePack>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgColumnSectionAnchorTagArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgColumnSectionBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgColumnSectionBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgColumnSectionColumnsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgColumnSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgColumnSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgColumnSectionStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgColumnSectionSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgColumnSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgColumnSectionBlocksCollection = {
  __typename?: 'vs_EgColumnSectionBlocksCollection'
  items: Array<Maybe<Vs_EgColumnSectionBlocksItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgColumnSectionBlocksItem = Vs_EgContentBlock | Vs_EgMedia

export type Vs_EgColumnSectionCollection = {
  __typename?: 'vs_EgColumnSectionCollection'
  items: Array<Maybe<Vs_EgColumnSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgColumnSectionLinkingCollections = {
  __typename?: 'vs_EgColumnSectionLinkingCollections'
  egDocsPageCollection?: Maybe<Vs_EgDocsPageCollection>
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgColumnSectionLinkingCollectionsEgDocsPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgColumnSectionLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgColumnSectionLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgColumnSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgContentBlock = Vs_Entry & {
  __typename?: 'vs_EgContentBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  cta?: Maybe<Vs_EgContentBlockCta>
  description?: Maybe<Vs_EgContentBlockDescription>
  entryTitle?: Maybe<Scalars['String']>
  icon?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_EgContentBlockLinkingCollections>
  pretitle?: Maybe<Scalars['String']>
  stylePack?: Maybe<Vs_EgStylePack>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgContentBlockCtaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgContentBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgContentBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgContentBlockIconArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgContentBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgContentBlockPretitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgContentBlockStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgContentBlockSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgContentBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgContentBlockCollection = {
  __typename?: 'vs_EgContentBlockCollection'
  items: Array<Maybe<Vs_EgContentBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgContentBlockCta = Vs_EgLink | Vs_EgOverlayCta

export type Vs_EgContentBlockDescription = {
  __typename?: 'vs_EgContentBlockDescription'
  links: Vs_EgContentBlockDescriptionLinks
}

export type Vs_EgContentBlockDescriptionAssets = {
  __typename?: 'vs_EgContentBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgContentBlockDescriptionEntries = {
  __typename?: 'vs_EgContentBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgContentBlockDescriptionLinks = {
  __typename?: 'vs_EgContentBlockDescriptionLinks'
  assets: Vs_EgContentBlockDescriptionAssets
  entries: Vs_EgContentBlockDescriptionEntries
}

export type Vs_EgContentBlockLinkingCollections = {
  __typename?: 'vs_EgContentBlockLinkingCollections'
  egColumnSectionCollection?: Maybe<Vs_EgColumnSectionCollection>
  egImageCopySectionCollection?: Maybe<Vs_EgImageCopySectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgContentBlockLinkingCollectionsEgColumnSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgContentBlockLinkingCollectionsEgImageCopySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgContentBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDefinitionItem = Vs_Entry & {
  __typename?: 'vs_EgDefinitionItem'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  label?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgDefinitionItemLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgDefinitionItemEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDefinitionItemLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDefinitionItemLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgDefinitionItemSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDefinitionItemLinkingCollections = {
  __typename?: 'vs_EgDefinitionItemLinkingCollections'
  egCheckoutTypeCollection?: Maybe<Vs_EgCheckoutTypeCollection>
  egDimensionKeyCollection?: Maybe<Vs_EgDimensionKeyCollection>
  egDimensionValueCollection?: Maybe<Vs_EgDimensionValueCollection>
  egStoreProductCollection?: Maybe<Vs_EgStoreProductCollection>
  egTagCollection?: Maybe<Vs_EgTagCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgDefinitionItemLinkingCollectionsEgCheckoutTypeCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDefinitionItemLinkingCollectionsEgDimensionKeyCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDefinitionItemLinkingCollectionsEgDimensionValueCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDefinitionItemLinkingCollectionsEgStoreProductCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDefinitionItemLinkingCollectionsEgTagCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDefinitionItemLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDetail = Vs_Entry & {
  __typename?: 'vs_EgDetail'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgDetailLinkingCollections>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgDetailEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDetailLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgDetailSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDetailTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDetailLinkingCollections = {
  __typename?: 'vs_EgDetailLinkingCollections'
  egTextWithDetailsSectionCollection?: Maybe<Vs_EgTextWithDetailsSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgDetailLinkingCollectionsEgTextWithDetailsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDetailLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDimension = Vs_Entry & {
  __typename?: 'vs_EgDimension'
  contentfulMetadata: Vs_ContentfulMetadata
  controlAssets?: Maybe<Scalars['Boolean']>
  dimensionKey?: Maybe<Vs_EgDimensionKey>
  dimensionValuesCollection?: Maybe<Vs_EgDimensionDimensionValuesCollection>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgDimensionLinkingCollections>
  sys: Vs_Sys
  type?: Maybe<Scalars['String']>
}

export type Vs_EgDimensionControlAssetsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDimensionDimensionKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgDimensionDimensionValuesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDimensionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDimensionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgDimensionTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDimensionCollection = {
  __typename?: 'vs_EgDimensionCollection'
  items: Array<Maybe<Vs_EgDimension>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgDimensionDimensionValuesCollection = {
  __typename?: 'vs_EgDimensionDimensionValuesCollection'
  items: Array<Maybe<Vs_EgDimensionValue>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgDimensionKey = Vs_Entry & {
  __typename?: 'vs_EgDimensionKey'
  contentfulMetadata: Vs_ContentfulMetadata
  definitionItem?: Maybe<Vs_EgDefinitionItem>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgDimensionKeyLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgDimensionKeyDefinitionItemArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgDimensionKeyEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDimensionKeyLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgDimensionKeyCollection = {
  __typename?: 'vs_EgDimensionKeyCollection'
  items: Array<Maybe<Vs_EgDimensionKey>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgDimensionKeyLinkingCollections = {
  __typename?: 'vs_EgDimensionKeyLinkingCollections'
  egDimensionCollection?: Maybe<Vs_EgDimensionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgDimensionKeyLinkingCollectionsEgDimensionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDimensionKeyLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDimensionLinkingCollections = {
  __typename?: 'vs_EgDimensionLinkingCollections'
  egStoreProductCollection?: Maybe<Vs_EgStoreProductCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgDimensionLinkingCollectionsEgStoreProductCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDimensionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDimensionValue = Vs_Entry & {
  __typename?: 'vs_EgDimensionValue'
  contentfulMetadata: Vs_ContentfulMetadata
  definitionItem?: Maybe<Vs_EgDefinitionItem>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgDimensionValueLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgDimensionValueDefinitionItemArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgDimensionValueEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDimensionValueLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgDimensionValueCollection = {
  __typename?: 'vs_EgDimensionValueCollection'
  items: Array<Maybe<Vs_EgDimensionValue>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgDimensionValueLinkingCollections = {
  __typename?: 'vs_EgDimensionValueLinkingCollections'
  egDimensionCollection?: Maybe<Vs_EgDimensionCollection>
  egSkuCollection?: Maybe<Vs_EgSkuCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgDimensionValueLinkingCollectionsEgDimensionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDimensionValueLinkingCollectionsEgSkuCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDimensionValueLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDisclaimers = Vs_Entry & {
  __typename?: 'vs_EgDisclaimers'
  body?: Maybe<Vs_EgDisclaimersBody>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgDisclaimersLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgDisclaimersBodyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDisclaimersEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDisclaimersLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgDisclaimersTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDisclaimersBody = {
  __typename?: 'vs_EgDisclaimersBody'
  links: Vs_EgDisclaimersBodyLinks
}

export type Vs_EgDisclaimersBodyAssets = {
  __typename?: 'vs_EgDisclaimersBodyAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgDisclaimersBodyEntries = {
  __typename?: 'vs_EgDisclaimersBodyEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgDisclaimersBodyLinks = {
  __typename?: 'vs_EgDisclaimersBodyLinks'
  assets: Vs_EgDisclaimersBodyAssets
  entries: Vs_EgDisclaimersBodyEntries
}

export type Vs_EgDisclaimersLinkingCollections = {
  __typename?: 'vs_EgDisclaimersLinkingCollections'
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  egProductFeaturesCollection?: Maybe<Vs_EgProductFeaturesCollection>
  egProductPageCollection?: Maybe<Vs_EgProductPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgDisclaimersLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDisclaimersLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDisclaimersLinkingCollectionsEgProductFeaturesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDisclaimersLinkingCollectionsEgProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDisclaimersLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDocsPage = Vs_Entry & {
  __typename?: 'vs_EgDocsPage'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgDocsPageLinkingCollections>
  sectionsCollection?: Maybe<Vs_EgDocsPageSectionsCollection>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  stylePack?: Maybe<Vs_EgStylePack>
  sys: Vs_Sys
}

export type Vs_EgDocsPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDocsPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgDocsPageSectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDocsPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgDocsPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDocsPageStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgDocsPageCollection = {
  __typename?: 'vs_EgDocsPageCollection'
  items: Array<Maybe<Vs_EgDocsPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgDocsPageLinkingCollections = {
  __typename?: 'vs_EgDocsPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgDocsPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDocsPageSectionsCollection = {
  __typename?: 'vs_EgDocsPageSectionsCollection'
  items: Array<Maybe<Vs_EgDocsPageSectionsItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgDocsPageSectionsItem =
  | Vs_EgColumnSection
  | Vs_EgDocumentsCollection
  | Vs_EgTitleIntroSection

export type Vs_EgDocumentsCollection = Vs_Entry & {
  __typename?: 'vs_EgDocumentsCollection'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgDocumentsCollectionLinkingCollections>
  linksCollection?: Maybe<Vs_EgDocumentsCollectionLinksCollection>
  stylePack?: Maybe<Vs_EgStylePack>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgDocumentsCollectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDocumentsCollectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgDocumentsCollectionLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDocumentsCollectionStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgDocumentsCollectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgDocumentsCollectionCollection = {
  __typename?: 'vs_EgDocumentsCollectionCollection'
  items: Array<Maybe<Vs_EgDocumentsCollection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgDocumentsCollectionLinkingCollections = {
  __typename?: 'vs_EgDocumentsCollectionLinkingCollections'
  egDocsPageCollection?: Maybe<Vs_EgDocsPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgDocumentsCollectionLinkingCollectionsEgDocsPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDocumentsCollectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgDocumentsCollectionLinksCollection = {
  __typename?: 'vs_EgDocumentsCollectionLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgEditorialStorySection = Vs_Entry & {
  __typename?: 'vs_EgEditorialStorySection'
  blocksCollection?: Maybe<Vs_EgEditorialStorySectionBlocksCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  fadedBottomBackgroundImage?: Maybe<Vs_Media>
  heroSection?: Maybe<Vs_EgEditorialStorySectionHeroSection>
  linkedFrom?: Maybe<Vs_EgEditorialStorySectionLinkingCollections>
  storyQuote?: Maybe<Vs_EgStoryBlockQuote>
  storyText?: Maybe<Vs_EgStoryBlockText>
  storyVideo?: Maybe<Vs_EgVideo>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgEditorialStorySectionBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgEditorialStorySectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEditorialStorySectionFadedBottomBackgroundImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgEditorialStorySectionHeroSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgEditorialStorySectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgEditorialStorySectionStoryQuoteArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgEditorialStorySectionStoryTextArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgEditorialStorySectionStoryVideoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgEditorialStorySectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEditorialStorySectionBlocksCollection = {
  __typename?: 'vs_EgEditorialStorySectionBlocksCollection'
  items: Array<Maybe<Vs_EgEditorialStorySectionBlocksItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgEditorialStorySectionBlocksItem =
  | Vs_EgMedia
  | Vs_EgRpvAccordionBlock
  | Vs_EgStoryBlockImageStack
  | Vs_EgStoryBlockQuote
  | Vs_EgStoryBlockText
  | Vs_EgVideo

export type Vs_EgEditorialStorySectionCollection = {
  __typename?: 'vs_EgEditorialStorySectionCollection'
  items: Array<Maybe<Vs_EgEditorialStorySection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgEditorialStorySectionHeroSection = Vs_EgProductStoryHero | Vs_EgRpvStoryHero

export type Vs_EgEditorialStorySectionLinkingCollections = {
  __typename?: 'vs_EgEditorialStorySectionLinkingCollections'
  egProductPageSectionCollection?: Maybe<Vs_EgProductPageSectionCollection>
  egRpvPageCollection?: Maybe<Vs_EgRpvPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgEditorialStorySectionLinkingCollectionsEgProductPageSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgEditorialStorySectionLinkingCollectionsEgRpvPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgEditorialStorySectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgEditorialText = Vs_Entry & {
  __typename?: 'vs_EgEditorialText'
  bodyCopy?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgEditorialTextLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgEditorialTextBodyCopyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEditorialTextEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEditorialTextLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgEditorialTextTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEditorialTextLinkingCollections = {
  __typename?: 'vs_EgEditorialTextLinkingCollections'
  egRpvPageCollection?: Maybe<Vs_EgRpvPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgEditorialTextLinkingCollectionsEgRpvPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgEditorialTextLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgErrorPage = Vs_Entry & {
  __typename?: 'vs_EgErrorPage'
  actionLink?: Maybe<Vs_EgLink>
  background?: Maybe<Vs_Media>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgErrorPageLinkingCollections>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgErrorPageActionLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgErrorPageBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgErrorPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgErrorPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgErrorPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgErrorPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgErrorPageSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgErrorPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgErrorPageCollection = {
  __typename?: 'vs_EgErrorPageCollection'
  items: Array<Maybe<Vs_EgErrorPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgErrorPageLinkingCollections = {
  __typename?: 'vs_EgErrorPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgErrorPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgEvent = Vs_Entry & {
  __typename?: 'vs_EgEvent'
  amsId?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  headline?: Maybe<Scalars['String']>
  heroImage?: Maybe<Vs_EgMedia>
  linkedFrom?: Maybe<Vs_EgEventLinkingCollections>
  logoImage?: Maybe<Vs_EgMedia>
  remindersCollection?: Maybe<Vs_EgEventRemindersCollection>
  sys: Vs_Sys
}

export type Vs_EgEventAmsIdArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEventDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEventEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEventHeadlineArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEventHeroImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgEventLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgEventLogoImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgEventRemindersCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgEventCollection = {
  __typename?: 'vs_EgEventCollection'
  items: Array<Maybe<Vs_EgEvent>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgEventLinkingCollections = {
  __typename?: 'vs_EgEventLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgEventLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgEventReminder = Vs_Entry & {
  __typename?: 'vs_EgEventReminder'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgEventReminderLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgEventReminderEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEventReminderLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgEventReminderTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgEventReminderLinkingCollections = {
  __typename?: 'vs_EgEventReminderLinkingCollections'
  egEventCollection?: Maybe<Vs_EgEventCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgEventReminderLinkingCollectionsEgEventCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgEventReminderLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgEventRemindersCollection = {
  __typename?: 'vs_EgEventRemindersCollection'
  items: Array<Maybe<Vs_EgEventReminder>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgFeaturesSection = Vs_Entry & {
  __typename?: 'vs_EgFeaturesSection'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  features?: Maybe<Vs_EgMultimediaCollection>
  linkedFrom?: Maybe<Vs_EgFeaturesSectionLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgFeaturesSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgFeaturesSectionFeaturesArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgFeaturesSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgFeaturesSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgFeaturesSectionCollection = {
  __typename?: 'vs_EgFeaturesSectionCollection'
  items: Array<Maybe<Vs_EgFeaturesSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgFeaturesSectionLinkingCollections = {
  __typename?: 'vs_EgFeaturesSectionLinkingCollections'
  egStoreProductDetailPageCollection?: Maybe<Vs_EgStoreProductDetailPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgFeaturesSectionLinkingCollectionsEgStoreProductDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgFeaturesSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgFileWrapper = Vs_Entry & {
  __typename?: 'vs_EgFileWrapper'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  file?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_EgFileWrapperLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgFileWrapperEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgFileWrapperFileArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgFileWrapperLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgFileWrapperSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgFileWrapperCollection = {
  __typename?: 'vs_EgFileWrapperCollection'
  items: Array<Maybe<Vs_EgFileWrapper>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgFileWrapperLinkingCollections = {
  __typename?: 'vs_EgFileWrapperLinkingCollections'
  egCategoryCollection?: Maybe<Vs_EgCategoryCollection>
  egLegalPageCollection?: Maybe<Vs_EgLegalPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgFileWrapperLinkingCollectionsEgCategoryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgFileWrapperLinkingCollectionsEgLegalPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgFileWrapperLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgFleetOsNotification = Vs_Entry & {
  __typename?: 'vs_EgFleetOsNotification'
  body?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgFleetOsNotificationLinkingCollections>
  source?: Maybe<Scalars['String']>
  subject?: Maybe<Scalars['String']>
  sys: Vs_Sys
  tier?: Maybe<Scalars['String']>
}

export type Vs_EgFleetOsNotificationBodyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgFleetOsNotificationEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgFleetOsNotificationLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgFleetOsNotificationSourceArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgFleetOsNotificationSubjectArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgFleetOsNotificationTierArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgFleetOsNotificationLinkingCollections = {
  __typename?: 'vs_EgFleetOsNotificationLinkingCollections'
  egNotificationEventCollection?: Maybe<Vs_EgNotificationEventCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgFleetOsNotificationLinkingCollectionsEgNotificationEventCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgFleetOsNotificationLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalFooter = Vs_Entry & {
  __typename?: 'vs_EgGlobalFooter'
  contentfulMetadata: Vs_ContentfulMetadata
  copyright?: Maybe<Scalars['String']>
  egNewsletterCallout?: Maybe<Scalars['String']>
  egNewsletterFieldError?: Maybe<Scalars['String']>
  egNewsletterPlaceholder?: Maybe<Scalars['String']>
  egNewsletterSubmissionError?: Maybe<Scalars['String']>
  egNewsletterSuccessMessage?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  firstLevelLinksCollection?: Maybe<Vs_EgGlobalFooterFirstLevelLinksCollection>
  linkedFrom?: Maybe<Vs_EgGlobalFooterLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  newsletterBackground?: Maybe<Vs_Asset>
  secondLevelLinksCollection?: Maybe<Vs_EgGlobalFooterSecondLevelLinksCollection>
  socialLinksCollection?: Maybe<Vs_EgGlobalFooterSocialLinksCollection>
  sys: Vs_Sys
  thirdLevelLinksCollection?: Maybe<Vs_EgGlobalFooterThirdLevelLinksCollection>
}

export type Vs_EgGlobalFooterCopyrightArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgGlobalFooterEgNewsletterCalloutArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgGlobalFooterEgNewsletterFieldErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgGlobalFooterEgNewsletterPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgGlobalFooterEgNewsletterSubmissionErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgGlobalFooterEgNewsletterSuccessMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgGlobalFooterEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgGlobalFooterFirstLevelLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalFooterLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgGlobalFooterMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgGlobalFooterNewsletterBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgGlobalFooterSecondLevelLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalFooterSocialLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalFooterThirdLevelLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalFooterCollection = {
  __typename?: 'vs_EgGlobalFooterCollection'
  items: Array<Maybe<Vs_EgGlobalFooter>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgGlobalFooterFirstLevelLinksCollection = {
  __typename?: 'vs_EgGlobalFooterFirstLevelLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgGlobalFooterLinkingCollections = {
  __typename?: 'vs_EgGlobalFooterLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgGlobalFooterLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalFooterSecondLevelLinksCollection = {
  __typename?: 'vs_EgGlobalFooterSecondLevelLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgGlobalFooterSocialLinksCollection = {
  __typename?: 'vs_EgGlobalFooterSocialLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgGlobalFooterThirdLevelLinksCollection = {
  __typename?: 'vs_EgGlobalFooterThirdLevelLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgGlobalHeader = Vs_Entry & {
  __typename?: 'vs_EgGlobalHeader'
  contentfulMetadata: Vs_ContentfulMetadata
  defaultNavImage?: Maybe<Vs_Asset>
  entryTitle?: Maybe<Scalars['String']>
  headerLogo?: Maybe<Vs_Asset>
  headerLogoAlt?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_EgGlobalHeaderLinkingCollections>
  menuLinksCollection?: Maybe<Vs_EgGlobalHeaderMenuLinksCollection>
  myAccountLinkCollection?: Maybe<Vs_EgGlobalHeaderMyAccountLinkCollection>
  myAccountSignInLinkCollection?: Maybe<Vs_EgGlobalHeaderMyAccountSignInLinkCollection>
  myAccountSignOutLinkCollection?: Maybe<Vs_EgGlobalHeaderMyAccountSignOutLinkCollection>
  subLinksCollection?: Maybe<Vs_EgGlobalHeaderSubLinksCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgGlobalHeaderDefaultNavImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgGlobalHeaderEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgGlobalHeaderHeaderLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgGlobalHeaderHeaderLogoAltArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgGlobalHeaderLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgGlobalHeaderMenuLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalHeaderMyAccountLinkCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalHeaderMyAccountSignInLinkCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalHeaderMyAccountSignOutLinkCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalHeaderSubLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalHeaderTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgGlobalHeaderCollection = {
  __typename?: 'vs_EgGlobalHeaderCollection'
  items: Array<Maybe<Vs_EgGlobalHeader>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgGlobalHeaderLinkingCollections = {
  __typename?: 'vs_EgGlobalHeaderLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgGlobalHeaderLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgGlobalHeaderMenuLinksCollection = {
  __typename?: 'vs_EgGlobalHeaderMenuLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgGlobalHeaderMyAccountLinkCollection = {
  __typename?: 'vs_EgGlobalHeaderMyAccountLinkCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgGlobalHeaderMyAccountSignInLinkCollection = {
  __typename?: 'vs_EgGlobalHeaderMyAccountSignInLinkCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgGlobalHeaderMyAccountSignOutLinkCollection = {
  __typename?: 'vs_EgGlobalHeaderMyAccountSignOutLinkCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgGlobalHeaderSubLinksCollection = {
  __typename?: 'vs_EgGlobalHeaderSubLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgHero = Vs_Entry & {
  __typename?: 'vs_EgHero'
  actionLink?: Maybe<Vs_EgLink>
  backgroundColor?: Maybe<Scalars['String']>
  caption?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  cta?: Maybe<Vs_EgHeroCta>
  displayType?: Maybe<Scalars['String']>
  downloadText?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  file?: Maybe<Vs_Asset>
  largeTitle?: Maybe<Array<Maybe<Scalars['String']>>>
  linkedFrom?: Maybe<Vs_EgHeroLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  pretitle?: Maybe<Scalars['String']>
  smallTitle?: Maybe<Array<Maybe<Scalars['String']>>>
  stylePack?: Maybe<Vs_EgStylePack>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  titleAlignment?: Maybe<Scalars['String']>
}

export type Vs_EgHeroActionLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHeroBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroCaptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroCtaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHeroDisplayTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroDownloadTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroFileArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHeroLargeTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgHeroMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHeroPretitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroSmallTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHeroSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroTitleAlignmentArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHeroCollection = {
  __typename?: 'vs_EgHeroCollection'
  items: Array<Maybe<Vs_EgHero>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgHeroCta = Vs_EgLink | Vs_EgOverlayCta

export type Vs_EgHeroLinkingCollections = {
  __typename?: 'vs_EgHeroLinkingCollections'
  egCareersPageCollection?: Maybe<Vs_EgCareersPageCollection>
  egHomePageCollection?: Maybe<Vs_EgHomePageCollection>
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  egProductPageCollection?: Maybe<Vs_EgProductPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgHeroLinkingCollectionsEgCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHeroLinkingCollectionsEgHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHeroLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHeroLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHeroLinkingCollectionsEgProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHeroLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightItem = Vs_Entry & {
  __typename?: 'vs_EgHighlightItem'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkToSku?: Maybe<Scalars['Boolean']>
  linkedFrom?: Maybe<Vs_EgHighlightItemLinkingCollections>
  sku?: Maybe<Vs_EgSku>
  storeProduct?: Maybe<Vs_EgStoreProduct>
  sys: Vs_Sys
}

export type Vs_EgHighlightItemEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightItemLinkToSkuArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightItemLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgHighlightItemSkuArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHighlightItemStoreProductArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHighlightItemCollection = {
  __typename?: 'vs_EgHighlightItemCollection'
  items: Array<Maybe<Vs_EgHighlightItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgHighlightItemLinkingCollections = {
  __typename?: 'vs_EgHighlightItemLinkingCollections'
  egStoreCollectionPageCollection?: Maybe<Vs_EgStoreCollectionPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgHighlightItemLinkingCollectionsEgStoreCollectionPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightItemLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightSpecItem = Vs_Entry & {
  __typename?: 'vs_EgHighlightSpecItem'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  label?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgHighlightSpecItemLinkingCollections>
  sys: Vs_Sys
  tooltip?: Maybe<Vs_EgTooltip>
  value?: Maybe<Scalars['String']>
}

export type Vs_EgHighlightSpecItemEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightSpecItemLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightSpecItemLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgHighlightSpecItemTooltipArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHighlightSpecItemValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightSpecItemCollection = {
  __typename?: 'vs_EgHighlightSpecItemCollection'
  items: Array<Maybe<Vs_EgHighlightSpecItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgHighlightSpecItemLinkingCollections = {
  __typename?: 'vs_EgHighlightSpecItemLinkingCollections'
  egHighlightSpecSectionCollection?: Maybe<Vs_EgHighlightSpecSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgHighlightSpecItemLinkingCollectionsEgHighlightSpecSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightSpecItemLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightSpecSection = Vs_Entry & {
  __typename?: 'vs_EgHighlightSpecSection'
  anchorTag?: Maybe<Scalars['String']>
  backgroundColor?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  itemsCollection?: Maybe<Vs_EgHighlightSpecSectionItemsCollection>
  linkedFrom?: Maybe<Vs_EgHighlightSpecSectionLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgHighlightSpecSectionAnchorTagArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightSpecSectionBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightSpecSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightSpecSectionItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightSpecSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgHighlightSpecSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightSpecSectionCollection = {
  __typename?: 'vs_EgHighlightSpecSectionCollection'
  items: Array<Maybe<Vs_EgHighlightSpecSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgHighlightSpecSectionItemsCollection = {
  __typename?: 'vs_EgHighlightSpecSectionItemsCollection'
  items: Array<Maybe<Vs_EgHighlightSpecItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgHighlightSpecSectionLinkingCollections = {
  __typename?: 'vs_EgHighlightSpecSectionLinkingCollections'
  egImageCopySectionCollection?: Maybe<Vs_EgImageCopySectionCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgHighlightSpecSectionLinkingCollectionsEgImageCopySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightSpecSectionLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightSpecSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightedText = Vs_Entry & {
  __typename?: 'vs_EgHighlightedText'
  alignment?: Maybe<Scalars['String']>
  anchorTag?: Maybe<Scalars['String']>
  backgroundColor?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgHighlightedTextLinkingCollections>
  richDescription?: Maybe<Vs_EgHighlightedTextRichDescription>
  stylePack?: Maybe<Vs_EgStylePack>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgHighlightedTextAlignmentArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightedTextAnchorTagArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightedTextBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightedTextEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightedTextLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgHighlightedTextRichDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightedTextStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHighlightedTextSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightedTextTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHighlightedTextCollection = {
  __typename?: 'vs_EgHighlightedTextCollection'
  items: Array<Maybe<Vs_EgHighlightedText>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgHighlightedTextLinkingCollections = {
  __typename?: 'vs_EgHighlightedTextLinkingCollections'
  egNewsArticleContentCollection?: Maybe<Vs_EgNewsArticleContentCollection>
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  egProductPageCollection?: Maybe<Vs_EgProductPageCollection>
  egRpvPageCollection?: Maybe<Vs_EgRpvPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgHighlightedTextLinkingCollectionsEgNewsArticleContentCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightedTextLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightedTextLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightedTextLinkingCollectionsEgProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightedTextLinkingCollectionsEgRpvPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightedTextLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgHighlightedTextRichDescription = {
  __typename?: 'vs_EgHighlightedTextRichDescription'
  links: Vs_EgHighlightedTextRichDescriptionLinks
}

export type Vs_EgHighlightedTextRichDescriptionAssets = {
  __typename?: 'vs_EgHighlightedTextRichDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgHighlightedTextRichDescriptionEntries = {
  __typename?: 'vs_EgHighlightedTextRichDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgHighlightedTextRichDescriptionLinks = {
  __typename?: 'vs_EgHighlightedTextRichDescriptionLinks'
  assets: Vs_EgHighlightedTextRichDescriptionAssets
  entries: Vs_EgHighlightedTextRichDescriptionEntries
}

export type Vs_EgHomePage = Vs_Entry & {
  __typename?: 'vs_EgHomePage'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  hero?: Maybe<Vs_EgHero>
  linkedFrom?: Maybe<Vs_EgHomePageLinkingCollections>
  missionSection?: Maybe<Vs_EgMissionSection>
  ogType?: Maybe<Scalars['String']>
  playList?: Maybe<Vs_EgCarousel>
  productSection?: Maybe<Vs_EgProductSection>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  storySection?: Maybe<Vs_EgStorySection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  videoSection?: Maybe<Vs_EgCarousel>
}

export type Vs_EgHomePageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHomePageHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHomePageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgHomePageMissionSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHomePageOgTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHomePagePlayListArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHomePageProductSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHomePageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHomePageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHomePageStorySectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHomePageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgHomePageVideoSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgHomePageCollection = {
  __typename?: 'vs_EgHomePageCollection'
  items: Array<Maybe<Vs_EgHomePage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgHomePageLinkingCollections = {
  __typename?: 'vs_EgHomePageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgHomePageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgImageCopySection = Vs_Entry & {
  __typename?: 'vs_EgImageCopySection'
  addMargin?: Maybe<Array<Maybe<Scalars['String']>>>
  anchorTag?: Maybe<Scalars['String']>
  backgroundColor?: Maybe<Scalars['String']>
  blocksCollection?: Maybe<Vs_EgImageCopySectionBlocksCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgImageCopySectionLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  presentation?: Maybe<Scalars['String']>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  topItem?: Maybe<Scalars['String']>
}

export type Vs_EgImageCopySectionAddMarginArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgImageCopySectionAnchorTagArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgImageCopySectionBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgImageCopySectionBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgImageCopySectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgImageCopySectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgImageCopySectionMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgImageCopySectionPresentationArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgImageCopySectionSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgImageCopySectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgImageCopySectionTopItemArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgImageCopySectionBlocksCollection = {
  __typename?: 'vs_EgImageCopySectionBlocksCollection'
  items: Array<Maybe<Vs_EgImageCopySectionBlocksItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgImageCopySectionBlocksItem = Vs_EgContentBlock | Vs_EgHighlightSpecSection

export type Vs_EgImageCopySectionCollection = {
  __typename?: 'vs_EgImageCopySectionCollection'
  items: Array<Maybe<Vs_EgImageCopySection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgImageCopySectionLinkingCollections = {
  __typename?: 'vs_EgImageCopySectionLinkingCollections'
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgImageCopySectionLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgImageCopySectionLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgImageCopySectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgInvitationPage = Vs_Entry & {
  __typename?: 'vs_EgInvitationPage'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  heroImageOverlay?: Maybe<Vs_EgMedia>
  linkedFrom?: Maybe<Vs_EgInvitationPageLinkingCollections>
  slug?: Maybe<Scalars['String']>
  stringsCollection?: Maybe<Vs_EgInvitationPageStringsCollection>
  sys: Vs_Sys
  triptychImagesCollection?: Maybe<Vs_EgInvitationPageTriptychImagesCollection>
}

export type Vs_EgInvitationPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgInvitationPageHeroImageOverlayArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgInvitationPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgInvitationPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgInvitationPageStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgInvitationPageTriptychImagesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgInvitationPageCollection = {
  __typename?: 'vs_EgInvitationPageCollection'
  items: Array<Maybe<Vs_EgInvitationPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgInvitationPageLinkingCollections = {
  __typename?: 'vs_EgInvitationPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgInvitationPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgInvitationPageStringsCollection = {
  __typename?: 'vs_EgInvitationPageStringsCollection'
  items: Array<Maybe<Vs_EgString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgInvitationPageTriptychImagesCollection = {
  __typename?: 'vs_EgInvitationPageTriptychImagesCollection'
  items: Array<Maybe<Vs_EgMedia>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgJobOpeningsSection = Vs_Entry & {
  __typename?: 'vs_EgJobOpeningsSection'
  allText?: Maybe<Scalars['String']>
  applyText?: Maybe<Scalars['String']>
  commitmentLabel?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  departmentLabel?: Maybe<Scalars['String']>
  description?: Maybe<Scalars['String']>
  emptyText?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  filtersTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgJobOpeningsSectionLinkingCollections>
  locationLabel?: Maybe<Scalars['String']>
  media?: Maybe<Vs_EgMedia>
  openingsText?: Maybe<Scalars['String']>
  resetFiltersLabel?: Maybe<Scalars['String']>
  resetText?: Maybe<Scalars['String']>
  searchPlaceholder?: Maybe<Scalars['String']>
  searchTitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  teamLabel?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
  viewLessText?: Maybe<Scalars['String']>
  viewMoreText?: Maybe<Scalars['String']>
  workTypeLabel?: Maybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionAllTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionApplyTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionCommitmentLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionDepartmentLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionEmptyTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionFiltersTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgJobOpeningsSectionLocationLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgJobOpeningsSectionOpeningsTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionResetFiltersLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionResetTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionSearchPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionSearchTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionTeamLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionViewLessTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionViewMoreTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionWorkTypeLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgJobOpeningsSectionCollection = {
  __typename?: 'vs_EgJobOpeningsSectionCollection'
  items: Array<Maybe<Vs_EgJobOpeningsSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgJobOpeningsSectionLinkingCollections = {
  __typename?: 'vs_EgJobOpeningsSectionLinkingCollections'
  egCareersPageCollection?: Maybe<Vs_EgCareersPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgJobOpeningsSectionLinkingCollectionsEgCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgJobOpeningsSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLeadCaptureForm = Vs_Entry & {
  __typename?: 'vs_EgLeadCaptureForm'
  contactHeading?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  countryLabel?: Maybe<Scalars['String']>
  description?: Maybe<Vs_EgLeadCaptureFormDescription>
  disclaimer?: Maybe<Vs_EgLeadCaptureFormDisclaimer>
  emailErrorMessage?: Maybe<Scalars['String']>
  emailLabel?: Maybe<Scalars['String']>
  emailTakenMessage?: Maybe<Scalars['String']>
  firstNameLabel?: Maybe<Scalars['String']>
  hideCountry?: Maybe<Scalars['Boolean']>
  hideFirstName?: Maybe<Scalars['Boolean']>
  hideLastName?: Maybe<Scalars['Boolean']>
  hidePostalCode?: Maybe<Scalars['Boolean']>
  hideProductInterests?: Maybe<Scalars['Boolean']>
  lastNameLabel?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgLeadCaptureFormLinkingCollections>
  optionalFieldMessage?: Maybe<Scalars['String']>
  postalCodeErrorMessage?: Maybe<Scalars['String']>
  postalCodeLabel?: Maybe<Scalars['String']>
  productInterestLabel?: Maybe<Scalars['String']>
  productInterestsCollection?: Maybe<Vs_EgLeadCaptureFormProductInterestsCollection>
  submitButtonActiveText?: Maybe<Scalars['String']>
  submitButtonText?: Maybe<Scalars['String']>
  submitErrorMessage?: Maybe<Scalars['String']>
  submitSuccessMessage?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormContactHeadingArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormCountryLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormDisclaimerArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormEmailErrorMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormEmailLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormEmailTakenMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormFirstNameLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormHideCountryArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormHideFirstNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormHideLastNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormHidePostalCodeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormHideProductInterestsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormLastNameLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgLeadCaptureFormOptionalFieldMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormPostalCodeErrorMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormPostalCodeLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormProductInterestLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormProductInterestsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLeadCaptureFormSubmitButtonActiveTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormSubmitButtonTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormSubmitErrorMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormSubmitSuccessMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCaptureFormCollection = {
  __typename?: 'vs_EgLeadCaptureFormCollection'
  items: Array<Maybe<Vs_EgLeadCaptureForm>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgLeadCaptureFormDescription = {
  __typename?: 'vs_EgLeadCaptureFormDescription'
  links: Vs_EgLeadCaptureFormDescriptionLinks
}

export type Vs_EgLeadCaptureFormDescriptionAssets = {
  __typename?: 'vs_EgLeadCaptureFormDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgLeadCaptureFormDescriptionEntries = {
  __typename?: 'vs_EgLeadCaptureFormDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgLeadCaptureFormDescriptionLinks = {
  __typename?: 'vs_EgLeadCaptureFormDescriptionLinks'
  assets: Vs_EgLeadCaptureFormDescriptionAssets
  entries: Vs_EgLeadCaptureFormDescriptionEntries
}

export type Vs_EgLeadCaptureFormDisclaimer = {
  __typename?: 'vs_EgLeadCaptureFormDisclaimer'
  links: Vs_EgLeadCaptureFormDisclaimerLinks
}

export type Vs_EgLeadCaptureFormDisclaimerAssets = {
  __typename?: 'vs_EgLeadCaptureFormDisclaimerAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgLeadCaptureFormDisclaimerEntries = {
  __typename?: 'vs_EgLeadCaptureFormDisclaimerEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgLeadCaptureFormDisclaimerLinks = {
  __typename?: 'vs_EgLeadCaptureFormDisclaimerLinks'
  assets: Vs_EgLeadCaptureFormDisclaimerAssets
  entries: Vs_EgLeadCaptureFormDisclaimerEntries
}

export type Vs_EgLeadCaptureFormLinkingCollections = {
  __typename?: 'vs_EgLeadCaptureFormLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgLeadCaptureFormLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLeadCaptureFormProductInterestsCollection = {
  __typename?: 'vs_EgLeadCaptureFormProductInterestsCollection'
  items: Array<Maybe<Vs_EgProductInterest>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgLeadCapturePage = Vs_Entry & {
  __typename?: 'vs_EgLeadCapturePage'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  layoutImage?: Maybe<Vs_EgBreakpointMedia>
  linkedFrom?: Maybe<Vs_EgLeadCapturePageLinkingCollections>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  strings?: Maybe<Vs_EgStringListCollection>
  sys: Vs_Sys
}

export type Vs_EgLeadCapturePageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadCapturePageLayoutImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgLeadCapturePageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgLeadCapturePageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgLeadCapturePageStringsArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgLeadCapturePageCollection = {
  __typename?: 'vs_EgLeadCapturePageCollection'
  items: Array<Maybe<Vs_EgLeadCapturePage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgLeadCapturePageLinkingCollections = {
  __typename?: 'vs_EgLeadCapturePageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgLeadCapturePageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLeadForm = Vs_Entry & {
  __typename?: 'vs_EgLeadForm'
  banner?: Maybe<Vs_EgMedia>
  contentfulMetadata: Vs_ContentfulMetadata
  dataSetsCollection?: Maybe<Vs_EgLeadFormDataSetsCollection>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgLeadFormLinkingCollections>
  slug?: Maybe<Scalars['String']>
  stringsCollection?: Maybe<Vs_EgLeadFormStringsCollection>
  sys: Vs_Sys
}

export type Vs_EgLeadFormBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgLeadFormDataSetsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLeadFormEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadFormLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgLeadFormSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLeadFormStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLeadFormCollection = {
  __typename?: 'vs_EgLeadFormCollection'
  items: Array<Maybe<Vs_EgLeadForm>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgLeadFormDataSetsCollection = {
  __typename?: 'vs_EgLeadFormDataSetsCollection'
  items: Array<Maybe<Vs_EgStringList>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgLeadFormLinkingCollections = {
  __typename?: 'vs_EgLeadFormLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgLeadFormLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLeadFormStringsCollection = {
  __typename?: 'vs_EgLeadFormStringsCollection'
  items: Array<Maybe<Vs_EgString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgLegalPage = Vs_Entry & {
  __typename?: 'vs_EgLegalPage'
  body?: Maybe<Vs_EgLegalPageBody>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  fileWrapper?: Maybe<Vs_EgFileWrapper>
  linkedFrom?: Maybe<Vs_EgLegalPageLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgLegalPageBodyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLegalPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLegalPageFileWrapperArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgLegalPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgLegalPageMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgLegalPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgLegalPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLegalPageSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLegalPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLegalPageBody = {
  __typename?: 'vs_EgLegalPageBody'
  links: Vs_EgLegalPageBodyLinks
}

export type Vs_EgLegalPageBodyAssets = {
  __typename?: 'vs_EgLegalPageBodyAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgLegalPageBodyEntries = {
  __typename?: 'vs_EgLegalPageBodyEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgLegalPageBodyLinks = {
  __typename?: 'vs_EgLegalPageBodyLinks'
  assets: Vs_EgLegalPageBodyAssets
  entries: Vs_EgLegalPageBodyEntries
}

export type Vs_EgLegalPageCollection = {
  __typename?: 'vs_EgLegalPageCollection'
  items: Array<Maybe<Vs_EgLegalPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgLegalPageLinkingCollections = {
  __typename?: 'vs_EgLegalPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgLegalPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLink = Vs_Entry & {
  __typename?: 'vs_EgLink'
  button?: Maybe<Scalars['Boolean']>
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  icon?: Maybe<Vs_Asset>
  linkHref?: Maybe<Scalars['String']>
  linkTitle?: Maybe<Scalars['String']>
  linkType?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgLinkLinkingCollections>
  stylePack?: Maybe<Vs_EgStylePack>
  sys: Vs_Sys
  target?: Maybe<Scalars['Boolean']>
}

export type Vs_EgLinkButtonArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLinkDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLinkEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLinkIconArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgLinkLinkHrefArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLinkLinkTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLinkLinkTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLinkLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgLinkStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgLinkTargetArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLinkCollection = {
  __typename?: 'vs_EgLinkCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgLinkLinkingCollections = {
  __typename?: 'vs_EgLinkLinkingCollections'
  egAccountHomeContentBlockCollection?: Maybe<Vs_EgAccountHomeContentBlockCollection>
  egAccountMediaSectionCollection?: Maybe<Vs_EgAccountMediaSectionCollection>
  egAnchorNavCollection?: Maybe<Vs_EgAnchorNavCollection>
  egContentBlockCollection?: Maybe<Vs_EgContentBlockCollection>
  egDocumentsCollectionCollection?: Maybe<Vs_EgDocumentsCollectionCollection>
  egErrorPageCollection?: Maybe<Vs_EgErrorPageCollection>
  egGlobalFooterCollection?: Maybe<Vs_EgGlobalFooterCollection>
  egGlobalHeaderCollection?: Maybe<Vs_EgGlobalHeaderCollection>
  egHeroCollection?: Maybe<Vs_EgHeroCollection>
  egMediaBlockCollection?: Maybe<Vs_EgMediaBlockCollection>
  egMediaCollectionCollection?: Maybe<Vs_EgMediaCollectionCollection>
  egMissionSectionCollection?: Maybe<Vs_EgMissionSectionCollection>
  egPanelCollection?: Maybe<Vs_EgPanelCollection>
  egProductBuildBannerCollection?: Maybe<Vs_EgProductBuildBannerCollection>
  egStickyNavCollection?: Maybe<Vs_EgStickyNavCollection>
  egStickyNavDropdownCollection?: Maybe<Vs_EgStickyNavDropdownCollection>
  egStoreProductDetailPageCollection?: Maybe<Vs_EgStoreProductDetailPageCollection>
  egStorySectionCollection?: Maybe<Vs_EgStorySectionCollection>
  egStoryTileCollection?: Maybe<Vs_EgStoryTileCollection>
  egTextBlockCollection?: Maybe<Vs_EgTextBlockCollection>
  egTitleIntroSectionCollection?: Maybe<Vs_EgTitleIntroSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  errorPageCollection?: Maybe<Vs_ErrorPageCollection>
  faqPageCollection?: Maybe<Vs_FaqPageCollection>
  featureBannerCollection?: Maybe<Vs_FeatureBannerCollection>
  footerBlockCollection?: Maybe<Vs_FooterBlockCollection>
  footerCollection?: Maybe<Vs_FooterCollection>
  headerCollection?: Maybe<Vs_HeaderCollection>
  heroesCollection?: Maybe<Vs_HeroesCollection>
  panelCollection?: Maybe<Vs_PanelCollection>
  socialCollection?: Maybe<Vs_SocialCollection>
  storyCollection?: Maybe<Vs_StoryCollection>
  storySectionCollection?: Maybe<Vs_StorySectionCollection>
}

export type Vs_EgLinkLinkingCollectionsEgAccountHomeContentBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgAccountMediaSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgAnchorNavCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgContentBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgDocumentsCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgErrorPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgGlobalFooterCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgGlobalHeaderCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgMediaBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgMediaCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgMissionSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgPanelCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgProductBuildBannerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgStickyNavCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgStickyNavDropdownCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgStoreProductDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgStoryTileCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgTextBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEgTitleIntroSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsErrorPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsFaqPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsFeatureBannerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsFooterBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsFooterCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsHeaderCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsHeroesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsPanelCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsSocialCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsStoryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLinkLinkingCollectionsStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgLocationBlock = Vs_Entry & {
  __typename?: 'vs_EgLocationBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_EgLocationBlockDescription>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgLocationBlockLinkingCollections>
  media?: Maybe<Vs_EgStoryBlockImageStack>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgLocationBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLocationBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLocationBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgLocationBlockMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgLocationBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgLocationBlockCollection = {
  __typename?: 'vs_EgLocationBlockCollection'
  items: Array<Maybe<Vs_EgLocationBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgLocationBlockDescription = {
  __typename?: 'vs_EgLocationBlockDescription'
  links: Vs_EgLocationBlockDescriptionLinks
}

export type Vs_EgLocationBlockDescriptionAssets = {
  __typename?: 'vs_EgLocationBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgLocationBlockDescriptionEntries = {
  __typename?: 'vs_EgLocationBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgLocationBlockDescriptionLinks = {
  __typename?: 'vs_EgLocationBlockDescriptionLinks'
  assets: Vs_EgLocationBlockDescriptionAssets
  entries: Vs_EgLocationBlockDescriptionEntries
}

export type Vs_EgLocationBlockLinkingCollections = {
  __typename?: 'vs_EgLocationBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgLocationBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMapBlock = Vs_Entry & {
  __typename?: 'vs_EgMapBlock'
  anchorTag?: Maybe<Scalars['String']>
  backgroundColor?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  latitudeCenter?: Maybe<Scalars['Float']>
  leftSideText?: Maybe<Vs_EgMapBlockLeftSideText>
  linkedFrom?: Maybe<Vs_EgMapBlockLinkingCollections>
  longitudeCenter?: Maybe<Scalars['Float']>
  mapTextOverlay?: Maybe<Vs_EgMapBlockMapTextOverlay>
  mapboxStyleEndpoint?: Maybe<Scalars['String']>
  rightSideText?: Maybe<Vs_EgMapBlockRightSideText>
  sys: Vs_Sys
  zoomInText?: Maybe<Scalars['String']>
  zoomMax?: Maybe<Scalars['Int']>
  zoomMin?: Maybe<Scalars['Int']>
  zoomOutText?: Maybe<Scalars['String']>
  zoomStart?: Maybe<Scalars['Int']>
}

export type Vs_EgMapBlockAnchorTagArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockLatitudeCenterArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockLeftSideTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgMapBlockLongitudeCenterArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockMapTextOverlayArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockMapboxStyleEndpointArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockRightSideTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockZoomInTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockZoomMaxArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockZoomMinArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockZoomOutTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockZoomStartArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMapBlockLeftSideText = {
  __typename?: 'vs_EgMapBlockLeftSideText'
  links: Vs_EgMapBlockLeftSideTextLinks
}

export type Vs_EgMapBlockLeftSideTextAssets = {
  __typename?: 'vs_EgMapBlockLeftSideTextAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgMapBlockLeftSideTextEntries = {
  __typename?: 'vs_EgMapBlockLeftSideTextEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgMapBlockLeftSideTextLinks = {
  __typename?: 'vs_EgMapBlockLeftSideTextLinks'
  assets: Vs_EgMapBlockLeftSideTextAssets
  entries: Vs_EgMapBlockLeftSideTextEntries
}

export type Vs_EgMapBlockLinkingCollections = {
  __typename?: 'vs_EgMapBlockLinkingCollections'
  egPageCollection?: Maybe<Vs_EgPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgMapBlockLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMapBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMapBlockMapTextOverlay = {
  __typename?: 'vs_EgMapBlockMapTextOverlay'
  links: Vs_EgMapBlockMapTextOverlayLinks
}

export type Vs_EgMapBlockMapTextOverlayAssets = {
  __typename?: 'vs_EgMapBlockMapTextOverlayAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgMapBlockMapTextOverlayEntries = {
  __typename?: 'vs_EgMapBlockMapTextOverlayEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgMapBlockMapTextOverlayLinks = {
  __typename?: 'vs_EgMapBlockMapTextOverlayLinks'
  assets: Vs_EgMapBlockMapTextOverlayAssets
  entries: Vs_EgMapBlockMapTextOverlayEntries
}

export type Vs_EgMapBlockRightSideText = {
  __typename?: 'vs_EgMapBlockRightSideText'
  links: Vs_EgMapBlockRightSideTextLinks
}

export type Vs_EgMapBlockRightSideTextAssets = {
  __typename?: 'vs_EgMapBlockRightSideTextAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgMapBlockRightSideTextEntries = {
  __typename?: 'vs_EgMapBlockRightSideTextEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgMapBlockRightSideTextLinks = {
  __typename?: 'vs_EgMapBlockRightSideTextLinks'
  assets: Vs_EgMapBlockRightSideTextAssets
  entries: Vs_EgMapBlockRightSideTextEntries
}

export type Vs_EgMedia = Vs_Entry & {
  __typename?: 'vs_EgMedia'
  backgroundColor?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  desktopImage?: Maybe<Vs_Asset>
  enhancedVideo?: Maybe<Vs_EgVideo>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgMediaLinkingCollections>
  mobileImage?: Maybe<Vs_Asset>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  video?: Maybe<Vs_Asset>
}

export type Vs_EgMediaBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaCloudinaryMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaDesktopImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaEnhancedVideoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgMediaMobileImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaVideoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaBlock = Vs_Entry & {
  __typename?: 'vs_EgMediaBlock'
  caption?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  copyPosition?: Maybe<Scalars['String']>
  cta?: Maybe<Vs_EgMediaBlockCta>
  description?: Maybe<Vs_EgMediaBlockDescription>
  downloadText?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgMediaBlockLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  pretitle?: Maybe<Scalars['String']>
  stringsCollection?: Maybe<Vs_EgMediaBlockStringsCollection>
  stylePack?: Maybe<Vs_EgStylePack>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgMediaBlockCaptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaBlockCopyPositionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaBlockCtaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaBlockDownloadTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgMediaBlockMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaBlockPretitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaBlockStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaBlockStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaBlockCollection = {
  __typename?: 'vs_EgMediaBlockCollection'
  items: Array<Maybe<Vs_EgMediaBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgMediaBlockCta = Vs_EgLink | Vs_EgOverlayCta

export type Vs_EgMediaBlockDescription = {
  __typename?: 'vs_EgMediaBlockDescription'
  links: Vs_EgMediaBlockDescriptionLinks
}

export type Vs_EgMediaBlockDescriptionAssets = {
  __typename?: 'vs_EgMediaBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgMediaBlockDescriptionEntries = {
  __typename?: 'vs_EgMediaBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgMediaBlockDescriptionLinks = {
  __typename?: 'vs_EgMediaBlockDescriptionLinks'
  assets: Vs_EgMediaBlockDescriptionAssets
  entries: Vs_EgMediaBlockDescriptionEntries
}

export type Vs_EgMediaBlockLinkingCollections = {
  __typename?: 'vs_EgMediaBlockLinkingCollections'
  egCarouselSlideCollection?: Maybe<Vs_EgCarouselSlideCollection>
  egMediaCollectionCollection?: Maybe<Vs_EgMediaCollectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgMediaBlockLinkingCollectionsEgCarouselSlideCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaBlockLinkingCollectionsEgMediaCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaBlockStringsCollection = {
  __typename?: 'vs_EgMediaBlockStringsCollection'
  items: Array<Maybe<Vs_EgString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgMediaCollection = Vs_Entry & {
  __typename?: 'vs_EgMediaCollection'
  anchorTag?: Maybe<Scalars['String']>
  backgroundColor?: Maybe<Scalars['String']>
  blocksCollection?: Maybe<Vs_EgMediaCollectionBlocksCollection>
  columns?: Maybe<Scalars['Float']>
  contentfulMetadata: Vs_ContentfulMetadata
  cta?: Maybe<Vs_EgLink>
  downloadText?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  file?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_EgMediaCollectionLinkingCollections>
  linksCollection?: Maybe<Vs_EgMediaCollectionLinksCollection>
  stringsCollection?: Maybe<Vs_EgMediaCollectionStringsCollection>
  stylePack?: Maybe<Vs_EgStylePack>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  variant?: Maybe<Scalars['String']>
}

export type Vs_EgMediaCollectionAnchorTagArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaCollectionBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaCollectionBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaCollectionColumnsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaCollectionCtaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaCollectionDownloadTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaCollectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaCollectionFileArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaCollectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgMediaCollectionLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaCollectionStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaCollectionStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaCollectionSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaCollectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaCollectionVariantArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaCollectionBlocksCollection = {
  __typename?: 'vs_EgMediaCollectionBlocksCollection'
  items: Array<Maybe<Vs_EgMediaBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgMediaCollectionCollection = {
  __typename?: 'vs_EgMediaCollectionCollection'
  items: Array<Maybe<Vs_EgMediaCollection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgMediaCollectionLinkingCollections = {
  __typename?: 'vs_EgMediaCollectionLinkingCollections'
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egOverlayCollection?: Maybe<Vs_EgOverlayCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgMediaCollectionLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaCollectionLinkingCollectionsEgOverlayCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaCollectionLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaCollectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaCollectionLinksCollection = {
  __typename?: 'vs_EgMediaCollectionLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgMediaCollectionStringsCollection = {
  __typename?: 'vs_EgMediaCollectionStringsCollection'
  items: Array<Maybe<Vs_EgString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgMediaLinkingCollections = {
  __typename?: 'vs_EgMediaLinkingCollections'
  egAccordionGroupCollection?: Maybe<Vs_EgAccordionGroupCollection>
  egActivityCollection?: Maybe<Vs_EgActivityCollection>
  egAppointmentDetailPageCollection?: Maybe<Vs_EgAppointmentDetailPageCollection>
  egAppointmentSchedulerPageCollection?: Maybe<Vs_EgAppointmentSchedulerPageCollection>
  egCareersLocationsSectionCollection?: Maybe<Vs_EgCareersLocationsSectionCollection>
  egCarouselOverlayCollection?: Maybe<Vs_EgCarouselOverlayCollection>
  egCarouselSlideCollection?: Maybe<Vs_EgCarouselSlideCollection>
  egColumnSectionCollection?: Maybe<Vs_EgColumnSectionCollection>
  egEditorialStorySectionCollection?: Maybe<Vs_EgEditorialStorySectionCollection>
  egEventCollection?: Maybe<Vs_EgEventCollection>
  egGlobalFooterCollection?: Maybe<Vs_EgGlobalFooterCollection>
  egHeroCollection?: Maybe<Vs_EgHeroCollection>
  egImageCopySectionCollection?: Maybe<Vs_EgImageCopySectionCollection>
  egInvitationPageCollection?: Maybe<Vs_EgInvitationPageCollection>
  egJobOpeningsSectionCollection?: Maybe<Vs_EgJobOpeningsSectionCollection>
  egLeadFormCollection?: Maybe<Vs_EgLeadFormCollection>
  egLegalPageCollection?: Maybe<Vs_EgLegalPageCollection>
  egMediaBlockCollection?: Maybe<Vs_EgMediaBlockCollection>
  egMediaMultitextItemCollection?: Maybe<Vs_EgMediaMultitextItemCollection>
  egMissionSectionCollection?: Maybe<Vs_EgMissionSectionCollection>
  egMultimediaCollectionCollection?: Maybe<Vs_EgMultimediaCollectionCollection>
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egOverlayCollection?: Maybe<Vs_EgOverlayCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  egPanelCollection?: Maybe<Vs_EgPanelCollection>
  egSkuCollection?: Maybe<Vs_EgSkuCollection>
  egSpecMapCollection?: Maybe<Vs_EgSpecMapCollection>
  egSpecsSectionCollection?: Maybe<Vs_EgSpecsSectionCollection>
  egStoreGridAssetCollection?: Maybe<Vs_EgStoreGridAssetCollection>
  egStoreProductCollection?: Maybe<Vs_EgStoreProductCollection>
  egStoreProductDetailPageCollection?: Maybe<Vs_EgStoreProductDetailPageCollection>
  egStorySectionCollection?: Maybe<Vs_EgStorySectionCollection>
  egStoryTileCollection?: Maybe<Vs_EgStoryTileCollection>
  egTabCollection?: Maybe<Vs_EgTabCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgMediaLinkingCollectionsEgAccordionGroupCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgActivityCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgAppointmentDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgAppointmentSchedulerPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgCareersLocationsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgCarouselOverlayCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgCarouselSlideCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgColumnSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgEditorialStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgEventCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgGlobalFooterCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgImageCopySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgInvitationPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgJobOpeningsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgLeadFormCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgLegalPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgMediaBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgMediaMultitextItemCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgMissionSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgMultimediaCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgOverlayCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgPanelCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgSkuCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgSpecMapCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgSpecsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgStoreGridAssetCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgStoreProductCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgStoreProductDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgStoryTileCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEgTabCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaMultitextItem = Vs_Entry & {
  __typename?: 'vs_EgMediaMultitextItem'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgMediaMultitextItemLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  multitextItem?: Maybe<Vs_EgMultitextItem>
  stylePack?: Maybe<Vs_EgStylePack>
  sys: Vs_Sys
}

export type Vs_EgMediaMultitextItemEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMediaMultitextItemLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgMediaMultitextItemMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaMultitextItemMultitextItemArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaMultitextItemStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMediaMultitextItemCollection = {
  __typename?: 'vs_EgMediaMultitextItemCollection'
  items: Array<Maybe<Vs_EgMediaMultitextItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgMediaMultitextItemLinkingCollections = {
  __typename?: 'vs_EgMediaMultitextItemLinkingCollections'
  egMultimediaCollectionCollection?: Maybe<Vs_EgMultimediaCollectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgMediaMultitextItemLinkingCollectionsEgMultimediaCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMediaMultitextItemLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMissionSection = Vs_Entry & {
  __typename?: 'vs_EgMissionSection'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgMissionSectionLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  richDescription?: Maybe<Vs_EgMissionSectionRichDescription>
  storyLink?: Maybe<Vs_EgLink>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgMissionSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMissionSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgMissionSectionMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMissionSectionRichDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMissionSectionStoryLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMissionSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMissionSectionCollection = {
  __typename?: 'vs_EgMissionSectionCollection'
  items: Array<Maybe<Vs_EgMissionSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgMissionSectionLinkingCollections = {
  __typename?: 'vs_EgMissionSectionLinkingCollections'
  egHomePageCollection?: Maybe<Vs_EgHomePageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgMissionSectionLinkingCollectionsEgHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMissionSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMissionSectionRichDescription = {
  __typename?: 'vs_EgMissionSectionRichDescription'
  links: Vs_EgMissionSectionRichDescriptionLinks
}

export type Vs_EgMissionSectionRichDescriptionAssets = {
  __typename?: 'vs_EgMissionSectionRichDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgMissionSectionRichDescriptionEntries = {
  __typename?: 'vs_EgMissionSectionRichDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgMissionSectionRichDescriptionLinks = {
  __typename?: 'vs_EgMissionSectionRichDescriptionLinks'
  assets: Vs_EgMissionSectionRichDescriptionAssets
  entries: Vs_EgMissionSectionRichDescriptionEntries
}

export type Vs_EgMultimediaCollection = Vs_Entry & {
  __typename?: 'vs_EgMultimediaCollection'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  itemsCollection?: Maybe<Vs_EgMultimediaCollectionItemsCollection>
  linkedFrom?: Maybe<Vs_EgMultimediaCollectionLinkingCollections>
  stylePack?: Maybe<Vs_EgStylePack>
  sys: Vs_Sys
}

export type Vs_EgMultimediaCollectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMultimediaCollectionItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMultimediaCollectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgMultimediaCollectionStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgMultimediaCollectionCollection = {
  __typename?: 'vs_EgMultimediaCollectionCollection'
  items: Array<Maybe<Vs_EgMultimediaCollection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgMultimediaCollectionItemsCollection = {
  __typename?: 'vs_EgMultimediaCollectionItemsCollection'
  items: Array<Maybe<Vs_EgMultimediaCollectionItemsItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgMultimediaCollectionItemsItem =
  | Vs_EgMedia
  | Vs_EgMediaMultitextItem
  | Vs_EgMultitextItem

export type Vs_EgMultimediaCollectionLinkingCollections = {
  __typename?: 'vs_EgMultimediaCollectionLinkingCollections'
  egFeaturesSectionCollection?: Maybe<Vs_EgFeaturesSectionCollection>
  egSpecChartCollection?: Maybe<Vs_EgSpecChartCollection>
  egSpecMapCollection?: Maybe<Vs_EgSpecMapCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgMultimediaCollectionLinkingCollectionsEgFeaturesSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMultimediaCollectionLinkingCollectionsEgSpecChartCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMultimediaCollectionLinkingCollectionsEgSpecMapCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMultimediaCollectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMultitextItem = Vs_Entry & {
  __typename?: 'vs_EgMultitextItem'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  field1?: Maybe<Vs_EgMultitextItemField1>
  field2?: Maybe<Vs_EgMultitextItemField2>
  field3?: Maybe<Vs_EgMultitextItemField3>
  field4?: Maybe<Vs_EgMultitextItemField4>
  field5?: Maybe<Vs_EgMultitextItemField5>
  linkedFrom?: Maybe<Vs_EgMultitextItemLinkingCollections>
  prefix?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgMultitextItemEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMultitextItemField1Args = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMultitextItemField2Args = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMultitextItemField3Args = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMultitextItemField4Args = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMultitextItemField5Args = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMultitextItemLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgMultitextItemPrefixArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgMultitextItemField1 = {
  __typename?: 'vs_EgMultitextItemField1'
  links: Vs_EgMultitextItemField1Links
}

export type Vs_EgMultitextItemField1Assets = {
  __typename?: 'vs_EgMultitextItemField1Assets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgMultitextItemField1Entries = {
  __typename?: 'vs_EgMultitextItemField1Entries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgMultitextItemField1Links = {
  __typename?: 'vs_EgMultitextItemField1Links'
  assets: Vs_EgMultitextItemField1Assets
  entries: Vs_EgMultitextItemField1Entries
}

export type Vs_EgMultitextItemField2 = {
  __typename?: 'vs_EgMultitextItemField2'
  links: Vs_EgMultitextItemField2Links
}

export type Vs_EgMultitextItemField2Assets = {
  __typename?: 'vs_EgMultitextItemField2Assets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgMultitextItemField2Entries = {
  __typename?: 'vs_EgMultitextItemField2Entries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgMultitextItemField2Links = {
  __typename?: 'vs_EgMultitextItemField2Links'
  assets: Vs_EgMultitextItemField2Assets
  entries: Vs_EgMultitextItemField2Entries
}

export type Vs_EgMultitextItemField3 = {
  __typename?: 'vs_EgMultitextItemField3'
  links: Vs_EgMultitextItemField3Links
}

export type Vs_EgMultitextItemField3Assets = {
  __typename?: 'vs_EgMultitextItemField3Assets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgMultitextItemField3Entries = {
  __typename?: 'vs_EgMultitextItemField3Entries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgMultitextItemField3Links = {
  __typename?: 'vs_EgMultitextItemField3Links'
  assets: Vs_EgMultitextItemField3Assets
  entries: Vs_EgMultitextItemField3Entries
}

export type Vs_EgMultitextItemField4 = {
  __typename?: 'vs_EgMultitextItemField4'
  links: Vs_EgMultitextItemField4Links
}

export type Vs_EgMultitextItemField4Assets = {
  __typename?: 'vs_EgMultitextItemField4Assets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgMultitextItemField4Entries = {
  __typename?: 'vs_EgMultitextItemField4Entries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgMultitextItemField4Links = {
  __typename?: 'vs_EgMultitextItemField4Links'
  assets: Vs_EgMultitextItemField4Assets
  entries: Vs_EgMultitextItemField4Entries
}

export type Vs_EgMultitextItemField5 = {
  __typename?: 'vs_EgMultitextItemField5'
  links: Vs_EgMultitextItemField5Links
}

export type Vs_EgMultitextItemField5Assets = {
  __typename?: 'vs_EgMultitextItemField5Assets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgMultitextItemField5Entries = {
  __typename?: 'vs_EgMultitextItemField5Entries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgMultitextItemField5Links = {
  __typename?: 'vs_EgMultitextItemField5Links'
  assets: Vs_EgMultitextItemField5Assets
  entries: Vs_EgMultitextItemField5Entries
}

export type Vs_EgMultitextItemLinkingCollections = {
  __typename?: 'vs_EgMultitextItemLinkingCollections'
  egMediaMultitextItemCollection?: Maybe<Vs_EgMediaMultitextItemCollection>
  egMultimediaCollectionCollection?: Maybe<Vs_EgMultimediaCollectionCollection>
  egSpecFrameCollection?: Maybe<Vs_EgSpecFrameCollection>
  egSpecMapCollection?: Maybe<Vs_EgSpecMapCollection>
  egStoreProductDetailPageCollection?: Maybe<Vs_EgStoreProductDetailPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgMultitextItemLinkingCollectionsEgMediaMultitextItemCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMultitextItemLinkingCollectionsEgMultimediaCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMultitextItemLinkingCollectionsEgSpecFrameCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMultitextItemLinkingCollectionsEgSpecMapCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMultitextItemLinkingCollectionsEgStoreProductDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgMultitextItemLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticleContent = Vs_Entry & {
  __typename?: 'vs_EgNewsArticleContent'
  articleSectionsCollection?: Maybe<Vs_EgNewsArticleContentArticleSectionsCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgNewsArticleContentLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgNewsArticleContentArticleSectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticleContentEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsArticleContentLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgNewsArticleContentArticleSectionsCollection = {
  __typename?: 'vs_EgNewsArticleContentArticleSectionsCollection'
  items: Array<Maybe<Vs_EgNewsArticleContentArticleSectionsItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgNewsArticleContentArticleSectionsItem =
  | Vs_EgHighlightedText
  | Vs_EgNewsArticleSection

export type Vs_EgNewsArticleContentCollection = {
  __typename?: 'vs_EgNewsArticleContentCollection'
  items: Array<Maybe<Vs_EgNewsArticleContent>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgNewsArticleContentLinkingCollections = {
  __typename?: 'vs_EgNewsArticleContentLinkingCollections'
  egPageCollection?: Maybe<Vs_EgPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgNewsArticleContentLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticleContentLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticlePage = Vs_Entry & {
  __typename?: 'vs_EgNewsArticlePage'
  contentfulMetadata: Vs_ContentfulMetadata
  disclaimers?: Maybe<Vs_EgDisclaimers>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgNewsArticlePageLinkingCollections>
  sectionsCollection?: Maybe<Vs_EgNewsArticlePageSectionsCollection>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  stylePack?: Maybe<Vs_EgStylePack>
  sys: Vs_Sys
}

export type Vs_EgNewsArticlePageDisclaimersArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgNewsArticlePageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsArticlePageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgNewsArticlePageSectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticlePageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgNewsArticlePageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsArticlePageStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgNewsArticlePageCollection = {
  __typename?: 'vs_EgNewsArticlePageCollection'
  items: Array<Maybe<Vs_EgNewsArticlePage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgNewsArticlePageLinkingCollections = {
  __typename?: 'vs_EgNewsArticlePageLinkingCollections'
  egPageCollection?: Maybe<Vs_EgPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgNewsArticlePageLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticlePageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticlePageSectionsCollection = {
  __typename?: 'vs_EgNewsArticlePageSectionsCollection'
  items: Array<Maybe<Vs_EgNewsArticlePageSectionsItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgNewsArticlePageSectionsItem =
  | Vs_EgCarouselSection
  | Vs_EgColumnSection
  | Vs_EgHero
  | Vs_EgHighlightedText
  | Vs_EgImageCopySection
  | Vs_EgMedia
  | Vs_EgMediaCollection
  | Vs_EgNewsArticleSection
  | Vs_EgTitleIntroSection

export type Vs_EgNewsArticleSection = Vs_Entry & {
  __typename?: 'vs_EgNewsArticleSection'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgNewsArticleSectionLinkingCollections>
  richContent?: Maybe<Vs_EgNewsArticleSectionRichContent>
  sidebarItemsCollection?: Maybe<Vs_EgNewsArticleSectionSidebarItemsCollection>
  sys: Vs_Sys
}

export type Vs_EgNewsArticleSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsArticleSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgNewsArticleSectionRichContentArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsArticleSectionSidebarItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticleSectionCollection = {
  __typename?: 'vs_EgNewsArticleSectionCollection'
  items: Array<Maybe<Vs_EgNewsArticleSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgNewsArticleSectionLinkingCollections = {
  __typename?: 'vs_EgNewsArticleSectionLinkingCollections'
  egNewsArticleContentCollection?: Maybe<Vs_EgNewsArticleContentCollection>
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgNewsArticleSectionLinkingCollectionsEgNewsArticleContentCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticleSectionLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticleSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsArticleSectionRichContent = {
  __typename?: 'vs_EgNewsArticleSectionRichContent'
  links: Vs_EgNewsArticleSectionRichContentLinks
}

export type Vs_EgNewsArticleSectionRichContentAssets = {
  __typename?: 'vs_EgNewsArticleSectionRichContentAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgNewsArticleSectionRichContentEntries = {
  __typename?: 'vs_EgNewsArticleSectionRichContentEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgNewsArticleSectionRichContentLinks = {
  __typename?: 'vs_EgNewsArticleSectionRichContentLinks'
  assets: Vs_EgNewsArticleSectionRichContentAssets
  entries: Vs_EgNewsArticleSectionRichContentEntries
}

export type Vs_EgNewsArticleSectionSidebarItemsCollection = {
  __typename?: 'vs_EgNewsArticleSectionSidebarItemsCollection'
  items: Array<Maybe<Vs_EgNewsArticleSectionSidebarItemsItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgNewsArticleSectionSidebarItemsItem = Vs_EgNewsSidebarItem | Vs_EgNewsSubscription

export type Vs_EgNewsSidebarItem = Vs_Entry & {
  __typename?: 'vs_EgNewsSidebarItem'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgNewsSidebarItemLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgNewsSidebarItemDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsSidebarItemEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsSidebarItemLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgNewsSidebarItemTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsSidebarItemLinkingCollections = {
  __typename?: 'vs_EgNewsSidebarItemLinkingCollections'
  egNewsArticleSectionCollection?: Maybe<Vs_EgNewsArticleSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgNewsSidebarItemLinkingCollectionsEgNewsArticleSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsSidebarItemLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsSubscription = Vs_Entry & {
  __typename?: 'vs_EgNewsSubscription'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  inputLabel?: Maybe<Scalars['String']>
  inputSubmitSuccessMsg?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgNewsSubscriptionLinkingCollections>
  submitButtonLabel?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgNewsSubscriptionDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsSubscriptionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsSubscriptionInputLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsSubscriptionInputSubmitSuccessMsgArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsSubscriptionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgNewsSubscriptionSubmitButtonLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsSubscriptionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsSubscriptionLinkingCollections = {
  __typename?: 'vs_EgNewsSubscriptionLinkingCollections'
  egNewsArticleSectionCollection?: Maybe<Vs_EgNewsArticleSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgNewsSubscriptionLinkingCollectionsEgNewsArticleSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsSubscriptionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNewsletter = Vs_Entry & {
  __typename?: 'vs_EgNewsletter'
  contentfulMetadata: Vs_ContentfulMetadata
  emailFieldError?: Maybe<Scalars['String']>
  emailFieldLabel?: Maybe<Scalars['String']>
  emailFieldPlaceholder?: Maybe<Scalars['String']>
  emailFieldSubmissionError?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  heading?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgNewsletterLinkingCollections>
  subHeading?: Maybe<Scalars['String']>
  successMessage?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgNewsletterEmailFieldErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsletterEmailFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsletterEmailFieldPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsletterEmailFieldSubmissionErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsletterEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsletterHeadingArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsletterLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgNewsletterSubHeadingArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsletterSuccessMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNewsletterLinkingCollections = {
  __typename?: 'vs_EgNewsletterLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgNewsletterLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgNotificationEvent = Vs_Entry & {
  __typename?: 'vs_EgNotificationEvent'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  fleetOsNotification?: Maybe<Vs_EgFleetOsNotification>
  linkedFrom?: Maybe<Vs_EgNotificationEventLinkingCollections>
  push?: Maybe<Scalars['String']>
  slug?: Maybe<Scalars['String']>
  sms?: Maybe<Scalars['String']>
  source?: Maybe<Scalars['String']>
  subject?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgNotificationEventEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNotificationEventFleetOsNotificationArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgNotificationEventLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgNotificationEventPushArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNotificationEventSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNotificationEventSmsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNotificationEventSourceArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNotificationEventSubjectArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgNotificationEventCollection = {
  __typename?: 'vs_EgNotificationEventCollection'
  items: Array<Maybe<Vs_EgNotificationEvent>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgNotificationEventLinkingCollections = {
  __typename?: 'vs_EgNotificationEventLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgNotificationEventLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgOverlay = Vs_Entry & {
  __typename?: 'vs_EgOverlay'
  closeText?: Maybe<Scalars['String']>
  collection?: Maybe<Vs_EgMediaCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  downloadText?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgOverlayLinkingCollections>
  overlayBody?: Maybe<Vs_EgOverlayOverlayBody>
  overlayMedia?: Maybe<Vs_EgMedia>
  stylePack?: Maybe<Vs_EgStylePack>
  sys: Vs_Sys
}

export type Vs_EgOverlayCloseTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgOverlayCollectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgOverlayDownloadTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgOverlayEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgOverlayLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgOverlayOverlayBodyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgOverlayOverlayMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgOverlayStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgOverlayCollection = {
  __typename?: 'vs_EgOverlayCollection'
  items: Array<Maybe<Vs_EgOverlay>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgOverlayCta = Vs_Entry & {
  __typename?: 'vs_EgOverlayCta'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgOverlayCtaLinkingCollections>
  overlay?: Maybe<Vs_EgOverlay>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgOverlayCtaEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgOverlayCtaLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgOverlayCtaOverlayArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgOverlayCtaSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgOverlayCtaTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgOverlayCtaCollection = {
  __typename?: 'vs_EgOverlayCtaCollection'
  items: Array<Maybe<Vs_EgOverlayCta>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgOverlayCtaLinkingCollections = {
  __typename?: 'vs_EgOverlayCtaLinkingCollections'
  egContentBlockCollection?: Maybe<Vs_EgContentBlockCollection>
  egHeroCollection?: Maybe<Vs_EgHeroCollection>
  egMediaBlockCollection?: Maybe<Vs_EgMediaBlockCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgOverlayCtaLinkingCollectionsEgContentBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgOverlayCtaLinkingCollectionsEgHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgOverlayCtaLinkingCollectionsEgMediaBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgOverlayCtaLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgOverlayLinkingCollections = {
  __typename?: 'vs_EgOverlayLinkingCollections'
  egOverlayCtaCollection?: Maybe<Vs_EgOverlayCtaCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgOverlayLinkingCollectionsEgOverlayCtaCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgOverlayLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgOverlayOverlayBody = {
  __typename?: 'vs_EgOverlayOverlayBody'
  links: Vs_EgOverlayOverlayBodyLinks
}

export type Vs_EgOverlayOverlayBodyAssets = {
  __typename?: 'vs_EgOverlayOverlayBodyAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgOverlayOverlayBodyEntries = {
  __typename?: 'vs_EgOverlayOverlayBodyEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgOverlayOverlayBodyLinks = {
  __typename?: 'vs_EgOverlayOverlayBodyLinks'
  assets: Vs_EgOverlayOverlayBodyAssets
  entries: Vs_EgOverlayOverlayBodyEntries
}

export type Vs_EgPage = Vs_Entry & {
  __typename?: 'vs_EgPage'
  contentfulMetadata: Vs_ContentfulMetadata
  disclaimer?: Maybe<Vs_EgDisclaimers>
  egPageChildrenCollection?: Maybe<Vs_EgPageEgPageChildrenCollection>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgPageLinkingCollections>
  sectionsCollection?: Maybe<Vs_EgPageSectionsCollection>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  stylePack?: Maybe<Vs_EgStylePack>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgPageDisclaimerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgPageEgPageChildrenCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgPageSectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgPageStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgPageCollection = {
  __typename?: 'vs_EgPageCollection'
  items: Array<Maybe<Vs_EgPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgPageEgPageChildrenCollection = {
  __typename?: 'vs_EgPageEgPageChildrenCollection'
  items: Array<Maybe<Vs_EgPageEgPageChildrenItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgPageEgPageChildrenItem = Vs_EgNewsArticlePage | Vs_EgPage

export type Vs_EgPageLinkingCollections = {
  __typename?: 'vs_EgPageLinkingCollections'
  egPageCollection?: Maybe<Vs_EgPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgPageLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgPageSectionsCollection = {
  __typename?: 'vs_EgPageSectionsCollection'
  items: Array<Maybe<Vs_EgPageSectionsItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgPageSectionsItem =
  | Vs_EgCarouselSection
  | Vs_EgColumnSection
  | Vs_EgHero
  | Vs_EgHighlightSpecSection
  | Vs_EgHighlightedText
  | Vs_EgImageCopySection
  | Vs_EgMapBlock
  | Vs_EgMedia
  | Vs_EgMediaCollection
  | Vs_EgNewsArticleContent
  | Vs_EgStickyNav
  | Vs_EgStoryBlockImageStack
  | Vs_EgTitleIntroSection

export type Vs_EgPanel = Vs_Entry & {
  __typename?: 'vs_EgPanel'
  configuratorLink?: Maybe<Vs_EgLink>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  exploreLink?: Maybe<Vs_EgLink>
  linkedFrom?: Maybe<Vs_EgPanelLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgPanelConfiguratorLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgPanelEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgPanelExploreLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgPanelLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgPanelMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgPanelTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgPanelCollection = {
  __typename?: 'vs_EgPanelCollection'
  items: Array<Maybe<Vs_EgPanel>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgPanelLinkingCollections = {
  __typename?: 'vs_EgPanelLinkingCollections'
  egProductSectionCollection?: Maybe<Vs_EgProductSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgPanelLinkingCollectionsEgProductSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgPanelLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductBuildBanner = Vs_Entry & {
  __typename?: 'vs_EgProductBuildBanner'
  contentfulMetadata: Vs_ContentfulMetadata
  ctaButton?: Maybe<Vs_EgLink>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgProductBuildBannerLinkingCollections>
  media?: Maybe<Vs_Media>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgProductBuildBannerCtaButtonArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductBuildBannerEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductBuildBannerLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductBuildBannerMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductBuildBannerSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductBuildBannerTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductBuildBannerCollection = {
  __typename?: 'vs_EgProductBuildBannerCollection'
  items: Array<Maybe<Vs_EgProductBuildBanner>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductBuildBannerLinkingCollections = {
  __typename?: 'vs_EgProductBuildBannerLinkingCollections'
  egProductPageCollection?: Maybe<Vs_EgProductPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductBuildBannerLinkingCollectionsEgProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductBuildBannerLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductFeature = Vs_Entry & {
  __typename?: 'vs_EgProductFeature'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  label?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgProductFeatureLinkingCollections>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_EgProductFeatureEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductFeatureLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductFeatureLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductFeatureValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductFeatureLinkingCollections = {
  __typename?: 'vs_EgProductFeatureLinkingCollections'
  egProductFeaturesCollection?: Maybe<Vs_EgProductFeaturesCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductFeatureLinkingCollectionsEgProductFeaturesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductFeatureLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductFeatures = Vs_Entry & {
  __typename?: 'vs_EgProductFeatures'
  contentfulMetadata: Vs_ContentfulMetadata
  disclaimer?: Maybe<Vs_EgDisclaimers>
  entryTitle?: Maybe<Scalars['String']>
  featuresCollection?: Maybe<Vs_EgProductFeaturesFeaturesCollection>
  linkedFrom?: Maybe<Vs_EgProductFeaturesLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgProductFeaturesDisclaimerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductFeaturesEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductFeaturesFeaturesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductFeaturesLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductFeaturesTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductFeaturesCollection = {
  __typename?: 'vs_EgProductFeaturesCollection'
  items: Array<Maybe<Vs_EgProductFeatures>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductFeaturesFeaturesCollection = {
  __typename?: 'vs_EgProductFeaturesFeaturesCollection'
  items: Array<Maybe<Vs_EgProductFeature>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductFeaturesLinkingCollections = {
  __typename?: 'vs_EgProductFeaturesLinkingCollections'
  egProductPageCollection?: Maybe<Vs_EgProductPageCollection>
  egProductPageSectionCollection?: Maybe<Vs_EgProductPageSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductFeaturesLinkingCollectionsEgProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductFeaturesLinkingCollectionsEgProductPageSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductFeaturesLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductHero = Vs_Entry & {
  __typename?: 'vs_EgProductHero'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgProductHeroLinkingCollections>
  media?: Maybe<Vs_Asset>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgProductHeroEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductHeroLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductHeroMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductHeroTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductHeroCollection = {
  __typename?: 'vs_EgProductHeroCollection'
  items: Array<Maybe<Vs_EgProductHero>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductHeroLinkingCollections = {
  __typename?: 'vs_EgProductHeroLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductHeroLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductInterest = Vs_Entry & {
  __typename?: 'vs_EgProductInterest'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_EgProductInterestLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgProductInterestLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductInterestSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductInterestTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductInterestLinkingCollections = {
  __typename?: 'vs_EgProductInterestLinkingCollections'
  egLeadCaptureFormCollection?: Maybe<Vs_EgLeadCaptureFormCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductInterestLinkingCollectionsEgLeadCaptureFormCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductInterestLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductPage = Vs_Entry & {
  __typename?: 'vs_EgProductPage'
  contentfulMetadata: Vs_ContentfulMetadata
  disclaimers?: Maybe<Vs_EgDisclaimers>
  entryTitle?: Maybe<Scalars['String']>
  hero?: Maybe<Vs_EgHero>
  linkedFrom?: Maybe<Vs_EgProductPageLinkingCollections>
  navigation?: Maybe<Vs_EgStickyNav>
  productBuildBanner?: Maybe<Vs_EgProductBuildBanner>
  productFeaturesCollection?: Maybe<Vs_EgProductPageProductFeaturesCollection>
  quote?: Maybe<Vs_EgHighlightedText>
  sectionsCollection?: Maybe<Vs_EgProductPageSectionsCollection>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  specsSection?: Maybe<Vs_EgProductSpecsSection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  trimsSection?: Maybe<Vs_EgTrimsSection>
}

export type Vs_EgProductPageDisclaimersArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductPageHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductPageNavigationArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageProductBuildBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageProductFeaturesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductPageQuoteArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageSectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductPageSpecsSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductPageTrimsSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageCollection = {
  __typename?: 'vs_EgProductPageCollection'
  items: Array<Maybe<Vs_EgProductPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductPageLinkingCollections = {
  __typename?: 'vs_EgProductPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductPageProductFeaturesCollection = {
  __typename?: 'vs_EgProductPageProductFeaturesCollection'
  items: Array<Maybe<Vs_EgProductFeatures>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductPageSection = Vs_Entry & {
  __typename?: 'vs_EgProductPageSection'
  anchorTag?: Maybe<Scalars['String']>
  carousel?: Maybe<Vs_EgCarousel>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  featuresSection?: Maybe<Vs_EgProductFeatures>
  linkedFrom?: Maybe<Vs_EgProductPageSectionLinkingCollections>
  story?: Maybe<Vs_EgEditorialStorySection>
  sys: Vs_Sys
  text?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
}

export type Vs_EgProductPageSectionAnchorTagArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductPageSectionCarouselArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductPageSectionFeaturesSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductPageSectionStoryArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductPageSectionTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductPageSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductPageSectionCollection = {
  __typename?: 'vs_EgProductPageSectionCollection'
  items: Array<Maybe<Vs_EgProductPageSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductPageSectionLinkingCollections = {
  __typename?: 'vs_EgProductPageSectionLinkingCollections'
  egProductPageCollection?: Maybe<Vs_EgProductPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductPageSectionLinkingCollectionsEgProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductPageSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductPageSectionsCollection = {
  __typename?: 'vs_EgProductPageSectionsCollection'
  items: Array<Maybe<Vs_EgProductPageSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductSection = Vs_Entry & {
  __typename?: 'vs_EgProductSection'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgProductSectionLinkingCollections>
  productPanelsCollection?: Maybe<Vs_EgProductSectionProductPanelsCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgProductSectionDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductSectionProductPanelsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSectionCollection = {
  __typename?: 'vs_EgProductSectionCollection'
  items: Array<Maybe<Vs_EgProductSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductSectionLinkingCollections = {
  __typename?: 'vs_EgProductSectionLinkingCollections'
  egHomePageCollection?: Maybe<Vs_EgHomePageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductSectionLinkingCollectionsEgHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSectionProductPanelsCollection = {
  __typename?: 'vs_EgProductSectionProductPanelsCollection'
  items: Array<Maybe<Vs_EgPanel>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductSpecItem = Vs_Entry & {
  __typename?: 'vs_EgProductSpecItem'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  label?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgProductSpecItemLinkingCollections>
  note?: Maybe<Scalars['String']>
  sys: Vs_Sys
  tag?: Maybe<Scalars['String']>
  value?: Maybe<Scalars['String']>
}

export type Vs_EgProductSpecItemEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSpecItemLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSpecItemLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductSpecItemNoteArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSpecItemTagArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSpecItemValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSpecItemLinkingCollections = {
  __typename?: 'vs_EgProductSpecItemLinkingCollections'
  egProductSpecsPanelCollection?: Maybe<Vs_EgProductSpecsPanelCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductSpecItemLinkingCollectionsEgProductSpecsPanelCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSpecItemLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSpecsPanel = Vs_Entry & {
  __typename?: 'vs_EgProductSpecsPanel'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgProductSpecsPanelLinkingCollections>
  media?: Maybe<Vs_Asset>
  specsItemsCollection?: Maybe<Vs_EgProductSpecsPanelSpecsItemsCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgProductSpecsPanelEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSpecsPanelLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductSpecsPanelMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductSpecsPanelSpecsItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSpecsPanelTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSpecsPanelCollection = {
  __typename?: 'vs_EgProductSpecsPanelCollection'
  items: Array<Maybe<Vs_EgProductSpecsPanel>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductSpecsPanelLinkingCollections = {
  __typename?: 'vs_EgProductSpecsPanelLinkingCollections'
  egProductSpecsSectionCollection?: Maybe<Vs_EgProductSpecsSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductSpecsPanelLinkingCollectionsEgProductSpecsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSpecsPanelLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSpecsPanelSpecsItemsCollection = {
  __typename?: 'vs_EgProductSpecsPanelSpecsItemsCollection'
  items: Array<Maybe<Vs_EgProductSpecItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductSpecsSection = Vs_Entry & {
  __typename?: 'vs_EgProductSpecsSection'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgProductSpecsSectionLinkingCollections>
  specsPanelsCollection?: Maybe<Vs_EgProductSpecsSectionSpecsPanelsCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgProductSpecsSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSpecsSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductSpecsSectionSpecsPanelsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSpecsSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductSpecsSectionCollection = {
  __typename?: 'vs_EgProductSpecsSectionCollection'
  items: Array<Maybe<Vs_EgProductSpecsSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductSpecsSectionLinkingCollections = {
  __typename?: 'vs_EgProductSpecsSectionLinkingCollections'
  egProductPageCollection?: Maybe<Vs_EgProductPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductSpecsSectionLinkingCollectionsEgProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSpecsSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductSpecsSectionSpecsPanelsCollection = {
  __typename?: 'vs_EgProductSpecsSectionSpecsPanelsCollection'
  items: Array<Maybe<Vs_EgProductSpecsPanel>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductStoryHero = Vs_Entry & {
  __typename?: 'vs_EgProductStoryHero'
  background?: Maybe<Vs_Media>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgProductStoryHeroLinkingCollections>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgProductStoryHeroBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgProductStoryHeroEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductStoryHeroLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgProductStoryHeroSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductStoryHeroTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgProductStoryHeroCollection = {
  __typename?: 'vs_EgProductStoryHeroCollection'
  items: Array<Maybe<Vs_EgProductStoryHero>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgProductStoryHeroLinkingCollections = {
  __typename?: 'vs_EgProductStoryHeroLinkingCollections'
  egEditorialStorySectionCollection?: Maybe<Vs_EgEditorialStorySectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgProductStoryHeroLinkingCollectionsEgEditorialStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgProductStoryHeroLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgRefineMenu = Vs_Entry & {
  __typename?: 'vs_EgRefineMenu'
  collectionsContainerCollection?: Maybe<Vs_EgRefineMenuCollectionsContainerCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  label?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgRefineMenuLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgRefineMenuCollectionsContainerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgRefineMenuEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgRefineMenuLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgRefineMenuLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgRefineMenuCollection = {
  __typename?: 'vs_EgRefineMenuCollection'
  items: Array<Maybe<Vs_EgRefineMenu>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgRefineMenuCollectionsContainerCollection = {
  __typename?: 'vs_EgRefineMenuCollectionsContainerCollection'
  items: Array<Maybe<Vs_EgCollectionsContainer>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgRefineMenuLinkingCollections = {
  __typename?: 'vs_EgRefineMenuLinkingCollections'
  egStoreCollectionPageCollection?: Maybe<Vs_EgStoreCollectionPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgRefineMenuLinkingCollectionsEgStoreCollectionPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgRefineMenuLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgRpvAccordionBlock = Vs_Entry & {
  __typename?: 'vs_EgRpvAccordionBlock'
  accordionBlocksCollection?: Maybe<Vs_EgRpvAccordionBlockAccordionBlocksCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  image?: Maybe<Vs_Media>
  linkedFrom?: Maybe<Vs_EgRpvAccordionBlockLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgRpvAccordionBlockAccordionBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgRpvAccordionBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgRpvAccordionBlockImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgRpvAccordionBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgRpvAccordionBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgRpvAccordionBlockAccordionBlocksCollection = {
  __typename?: 'vs_EgRpvAccordionBlockAccordionBlocksCollection'
  items: Array<Maybe<Vs_EgAccordionGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgRpvAccordionBlockCollection = {
  __typename?: 'vs_EgRpvAccordionBlockCollection'
  items: Array<Maybe<Vs_EgRpvAccordionBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgRpvAccordionBlockLinkingCollections = {
  __typename?: 'vs_EgRpvAccordionBlockLinkingCollections'
  egEditorialStorySectionCollection?: Maybe<Vs_EgEditorialStorySectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgRpvAccordionBlockLinkingCollectionsEgEditorialStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgRpvAccordionBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgRpvPage = Vs_Entry & {
  __typename?: 'vs_EgRpvPage'
  contentfulMetadata: Vs_ContentfulMetadata
  editorialStorySection?: Maybe<Vs_EgEditorialStorySection>
  editorialText?: Maybe<Vs_EgEditorialText>
  entryTitle?: Maybe<Scalars['String']>
  hero?: Maybe<Vs_Heroes>
  highlightedText?: Maybe<Vs_EgHighlightedText>
  highlightedTextSection?: Maybe<Vs_HighlightedTextSection>
  linkedFrom?: Maybe<Vs_EgRpvPageLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  videoSection?: Maybe<Vs_VideoSection>
}

export type Vs_EgRpvPageEditorialStorySectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgRpvPageEditorialTextArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgRpvPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgRpvPageHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgRpvPageHighlightedTextArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgRpvPageHighlightedTextSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgRpvPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgRpvPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgRpvPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgRpvPageVideoSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgRpvPageCollection = {
  __typename?: 'vs_EgRpvPageCollection'
  items: Array<Maybe<Vs_EgRpvPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgRpvPageLinkingCollections = {
  __typename?: 'vs_EgRpvPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgRpvPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgRpvStoryHero = Vs_Entry & {
  __typename?: 'vs_EgRpvStoryHero'
  amazonLogo?: Maybe<Vs_Asset>
  background?: Maybe<Vs_Media>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgRpvStoryHeroLinkingCollections>
  rivianLogo?: Maybe<Vs_Asset>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgRpvStoryHeroAmazonLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgRpvStoryHeroBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgRpvStoryHeroEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgRpvStoryHeroLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgRpvStoryHeroRivianLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgRpvStoryHeroTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgRpvStoryHeroCollection = {
  __typename?: 'vs_EgRpvStoryHeroCollection'
  items: Array<Maybe<Vs_EgRpvStoryHero>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgRpvStoryHeroLinkingCollections = {
  __typename?: 'vs_EgRpvStoryHeroLinkingCollections'
  egEditorialStorySectionCollection?: Maybe<Vs_EgEditorialStorySectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgRpvStoryHeroLinkingCollectionsEgEditorialStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgRpvStoryHeroLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadata = Vs_Entry & {
  __typename?: 'vs_EgSharingMetadata'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgSharingMetadataLinkingCollections>
  sharingDescription?: Maybe<Scalars['String']>
  sharingImage?: Maybe<Vs_Asset>
  sharingTitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgSharingMetadataEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSharingMetadataLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgSharingMetadataSharingDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSharingMetadataSharingImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgSharingMetadataSharingTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSharingMetadataCollection = {
  __typename?: 'vs_EgSharingMetadataCollection'
  items: Array<Maybe<Vs_EgSharingMetadata>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSharingMetadataLinkingCollections = {
  __typename?: 'vs_EgSharingMetadataLinkingCollections'
  aboutPageCollection?: Maybe<Vs_AboutPageCollection>
  basePageCollection?: Maybe<Vs_BasePageCollection>
  careersPageCollection?: Maybe<Vs_CareersPageCollection>
  egCareersPageCollection?: Maybe<Vs_EgCareersPageCollection>
  egDocsPageCollection?: Maybe<Vs_EgDocsPageCollection>
  egErrorPageCollection?: Maybe<Vs_EgErrorPageCollection>
  egHomePageCollection?: Maybe<Vs_EgHomePageCollection>
  egLeadCapturePageCollection?: Maybe<Vs_EgLeadCapturePageCollection>
  egLegalPageCollection?: Maybe<Vs_EgLegalPageCollection>
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  egProductPageCollection?: Maybe<Vs_EgProductPageCollection>
  egStoreCollectionPageCollection?: Maybe<Vs_EgStoreCollectionPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  errorPageCollection?: Maybe<Vs_ErrorPageCollection>
  faqPageCollection?: Maybe<Vs_FaqPageCollection>
  homePageCollection?: Maybe<Vs_HomePageCollection>
  preorderPageCollection?: Maybe<Vs_PreorderPageCollection>
  productPageCollection?: Maybe<Vs_ProductPageCollection>
  technologyPageCollection?: Maybe<Vs_TechnologyPageCollection>
}

export type Vs_EgSharingMetadataLinkingCollectionsAboutPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsBasePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEgCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEgDocsPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEgErrorPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEgHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEgLeadCapturePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEgLegalPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEgProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEgStoreCollectionPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsErrorPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsFaqPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsPreorderPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSharingMetadataLinkingCollectionsTechnologyPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgShellInternalLink = Vs_Entry & {
  __typename?: 'vs_EgShellInternalLink'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkPath?: Maybe<Vs_EgString>
  linkTitle?: Maybe<Vs_EgString>
  linkedFrom?: Maybe<Vs_EgShellInternalLinkLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgShellInternalLinkEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgShellInternalLinkLinkPathArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgShellInternalLinkLinkTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgShellInternalLinkLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgShellInternalLinkCollection = {
  __typename?: 'vs_EgShellInternalLinkCollection'
  items: Array<Maybe<Vs_EgShellInternalLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgShellInternalLinkLinkingCollections = {
  __typename?: 'vs_EgShellInternalLinkLinkingCollections'
  egAccountHomeContentBlockCollection?: Maybe<Vs_EgAccountHomeContentBlockCollection>
  egAccountMediaSectionCollection?: Maybe<Vs_EgAccountMediaSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgShellInternalLinkLinkingCollectionsEgAccountHomeContentBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgShellInternalLinkLinkingCollectionsEgAccountMediaSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgShellInternalLinkLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSku = Vs_Entry & {
  __typename?: 'vs_EgSku'
  carouselAssetsCollection?: Maybe<Vs_EgSkuCarouselAssetsCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  dimensionValuesCollection?: Maybe<Vs_EgSkuDimensionValuesCollection>
  entryTitle?: Maybe<Scalars['String']>
  gridAssets?: Maybe<Vs_EgStoreGridAsset>
  gridHoverAssets?: Maybe<Vs_EgStoreGridAsset>
  id?: Maybe<Scalars['String']>
  isVisible?: Maybe<Scalars['Boolean']>
  linkedFrom?: Maybe<Vs_EgSkuLinkingCollections>
  productDetailAssetsCollection?: Maybe<Vs_EgSkuProductDetailAssetsCollection>
  sys: Vs_Sys
}

export type Vs_EgSkuCarouselAssetsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSkuDimensionValuesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSkuEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSkuGridAssetsArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgSkuGridHoverAssetsArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgSkuIdArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSkuIsVisibleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSkuLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgSkuProductDetailAssetsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSkuCarouselAssetsCollection = {
  __typename?: 'vs_EgSkuCarouselAssetsCollection'
  items: Array<Maybe<Vs_EgMedia>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSkuCollection = {
  __typename?: 'vs_EgSkuCollection'
  items: Array<Maybe<Vs_EgSku>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSkuDimensionValuesCollection = {
  __typename?: 'vs_EgSkuDimensionValuesCollection'
  items: Array<Maybe<Vs_EgDimensionValue>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSkuLinkingCollections = {
  __typename?: 'vs_EgSkuLinkingCollections'
  egHighlightItemCollection?: Maybe<Vs_EgHighlightItemCollection>
  egStoreProductCollection?: Maybe<Vs_EgStoreProductCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgSkuLinkingCollectionsEgHighlightItemCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSkuLinkingCollectionsEgStoreProductCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSkuLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSkuProductDetailAssetsCollection = {
  __typename?: 'vs_EgSkuProductDetailAssetsCollection'
  items: Array<Maybe<Vs_EgMedia>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSpecChart = Vs_Entry & {
  __typename?: 'vs_EgSpecChart'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgSpecChartLinkingCollections>
  multimediaCollection?: Maybe<Vs_EgMultimediaCollection>
  sys: Vs_Sys
}

export type Vs_EgSpecChartEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSpecChartLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgSpecChartMultimediaCollectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgSpecChartCollection = {
  __typename?: 'vs_EgSpecChartCollection'
  items: Array<Maybe<Vs_EgSpecChart>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSpecChartLinkingCollections = {
  __typename?: 'vs_EgSpecChartLinkingCollections'
  egSpecsSectionCollection?: Maybe<Vs_EgSpecsSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgSpecChartLinkingCollectionsEgSpecsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSpecChartLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSpecFrame = Vs_Entry & {
  __typename?: 'vs_EgSpecFrame'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgSpecFrameLinkingCollections>
  multitextItem?: Maybe<Vs_EgMultitextItem>
  sys: Vs_Sys
}

export type Vs_EgSpecFrameEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSpecFrameLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgSpecFrameMultitextItemArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgSpecFrameCollection = {
  __typename?: 'vs_EgSpecFrameCollection'
  items: Array<Maybe<Vs_EgSpecFrame>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSpecFrameLinkingCollections = {
  __typename?: 'vs_EgSpecFrameLinkingCollections'
  egSpecsSectionCollection?: Maybe<Vs_EgSpecsSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgSpecFrameLinkingCollectionsEgSpecsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSpecFrameLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSpecMap = Vs_Entry & {
  __typename?: 'vs_EgSpecMap'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  image?: Maybe<Vs_EgMedia>
  linkedFrom?: Maybe<Vs_EgSpecMapLinkingCollections>
  multimediaCollection?: Maybe<Vs_EgMultimediaCollection>
  multitextItem?: Maybe<Vs_EgMultitextItem>
  sys: Vs_Sys
}

export type Vs_EgSpecMapEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSpecMapImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgSpecMapLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgSpecMapMultimediaCollectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgSpecMapMultitextItemArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgSpecMapCollection = {
  __typename?: 'vs_EgSpecMapCollection'
  items: Array<Maybe<Vs_EgSpecMap>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSpecMapLinkingCollections = {
  __typename?: 'vs_EgSpecMapLinkingCollections'
  egSpecsSectionCollection?: Maybe<Vs_EgSpecsSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgSpecMapLinkingCollectionsEgSpecsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSpecMapLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSpecsSection = Vs_Entry & {
  __typename?: 'vs_EgSpecsSection'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  image?: Maybe<Vs_EgMedia>
  linkedFrom?: Maybe<Vs_EgSpecsSectionLinkingCollections>
  specColumnACollection?: Maybe<Vs_EgSpecsSectionSpecColumnACollection>
  specColumnBCollection?: Maybe<Vs_EgSpecsSectionSpecColumnBCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgSpecsSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSpecsSectionImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgSpecsSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgSpecsSectionSpecColumnACollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSpecsSectionSpecColumnBCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSpecsSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgSpecsSectionCollection = {
  __typename?: 'vs_EgSpecsSectionCollection'
  items: Array<Maybe<Vs_EgSpecsSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSpecsSectionLinkingCollections = {
  __typename?: 'vs_EgSpecsSectionLinkingCollections'
  egStoreProductDetailPageCollection?: Maybe<Vs_EgStoreProductDetailPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgSpecsSectionLinkingCollectionsEgStoreProductDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSpecsSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgSpecsSectionSpecColumnACollection = {
  __typename?: 'vs_EgSpecsSectionSpecColumnACollection'
  items: Array<Maybe<Vs_EgSpecsSectionSpecColumnAItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSpecsSectionSpecColumnAItem = Vs_EgSpecChart | Vs_EgSpecFrame | Vs_EgSpecMap

export type Vs_EgSpecsSectionSpecColumnBCollection = {
  __typename?: 'vs_EgSpecsSectionSpecColumnBCollection'
  items: Array<Maybe<Vs_EgSpecsSectionSpecColumnBItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgSpecsSectionSpecColumnBItem = Vs_EgSpecChart | Vs_EgSpecFrame | Vs_EgSpecMap

export type Vs_EgStickyNav = Vs_Entry & {
  __typename?: 'vs_EgStickyNav'
  contentfulMetadata: Vs_ContentfulMetadata
  dropdown?: Maybe<Vs_EgStickyNavDropdown>
  entryTitle?: Maybe<Scalars['String']>
  externalLink?: Maybe<Vs_EgLink>
  linkedFrom?: Maybe<Vs_EgStickyNavLinkingCollections>
  linksCollection?: Maybe<Vs_EgStickyNavLinksCollection>
  optionalLink?: Maybe<Vs_EgLink>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgStickyNavDropdownArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStickyNavEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStickyNavExternalLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStickyNavLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStickyNavLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStickyNavOptionalLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStickyNavTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStickyNavCollection = {
  __typename?: 'vs_EgStickyNavCollection'
  items: Array<Maybe<Vs_EgStickyNav>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStickyNavDropdown = Vs_Entry & {
  __typename?: 'vs_EgStickyNavDropdown'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgStickyNavDropdownLinkingCollections>
  linksCollection?: Maybe<Vs_EgStickyNavDropdownLinksCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgStickyNavDropdownEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStickyNavDropdownLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStickyNavDropdownLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStickyNavDropdownTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStickyNavDropdownCollection = {
  __typename?: 'vs_EgStickyNavDropdownCollection'
  items: Array<Maybe<Vs_EgStickyNavDropdown>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStickyNavDropdownLinkingCollections = {
  __typename?: 'vs_EgStickyNavDropdownLinkingCollections'
  egStickyNavCollection?: Maybe<Vs_EgStickyNavCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStickyNavDropdownLinkingCollectionsEgStickyNavCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStickyNavDropdownLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStickyNavDropdownLinksCollection = {
  __typename?: 'vs_EgStickyNavDropdownLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStickyNavLinkingCollections = {
  __typename?: 'vs_EgStickyNavLinkingCollections'
  egCareersPageCollection?: Maybe<Vs_EgCareersPageCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  egProductPageCollection?: Maybe<Vs_EgProductPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStickyNavLinkingCollectionsEgCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStickyNavLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStickyNavLinkingCollectionsEgProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStickyNavLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStickyNavLinksCollection = {
  __typename?: 'vs_EgStickyNavLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreCollectionPage = Vs_Entry & {
  __typename?: 'vs_EgStoreCollectionPage'
  collectionPageTag?: Maybe<Vs_EgTag>
  contentfulMetadata: Vs_ContentfulMetadata
  curatedHighlightItemsCollection?: Maybe<Vs_EgStoreCollectionPageCuratedHighlightItemsCollection>
  entryTitle?: Maybe<Scalars['String']>
  isVisible?: Maybe<Scalars['Boolean']>
  linkedFrom?: Maybe<Vs_EgStoreCollectionPageLinkingCollections>
  refineMenu?: Maybe<Vs_EgRefineMenu>
  relatedLabel?: Maybe<Scalars['String']>
  relatedTag?: Maybe<Vs_EgTag>
  rootPageTag?: Maybe<Vs_EgTag>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  sys: Vs_Sys
}

export type Vs_EgStoreCollectionPageCollectionPageTagArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreCollectionPageCuratedHighlightItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreCollectionPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreCollectionPageIsVisibleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreCollectionPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStoreCollectionPageRefineMenuArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreCollectionPageRelatedLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreCollectionPageRelatedTagArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreCollectionPageRootPageTagArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreCollectionPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreCollectionPageCollection = {
  __typename?: 'vs_EgStoreCollectionPageCollection'
  items: Array<Maybe<Vs_EgStoreCollectionPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreCollectionPageCuratedHighlightItemsCollection = {
  __typename?: 'vs_EgStoreCollectionPageCuratedHighlightItemsCollection'
  items: Array<Maybe<Vs_EgHighlightItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreCollectionPageLinkingCollections = {
  __typename?: 'vs_EgStoreCollectionPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStoreCollectionPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreGridAsset = Vs_Entry & {
  __typename?: 'vs_EgStoreGridAsset'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  landscape?: Maybe<Vs_EgMedia>
  linkedFrom?: Maybe<Vs_EgStoreGridAssetLinkingCollections>
  portraitDesktop?: Maybe<Vs_EgMedia>
  portraitMobile?: Maybe<Vs_EgMedia>
  sys: Vs_Sys
}

export type Vs_EgStoreGridAssetEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreGridAssetLandscapeArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreGridAssetLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStoreGridAssetPortraitDesktopArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreGridAssetPortraitMobileArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreGridAssetCollection = {
  __typename?: 'vs_EgStoreGridAssetCollection'
  items: Array<Maybe<Vs_EgStoreGridAsset>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreGridAssetLinkingCollections = {
  __typename?: 'vs_EgStoreGridAssetLinkingCollections'
  egSkuCollection?: Maybe<Vs_EgSkuCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStoreGridAssetLinkingCollectionsEgSkuCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreGridAssetLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProduct = Vs_Entry & {
  __typename?: 'vs_EgStoreProduct'
  contentfulMetadata: Vs_ContentfulMetadata
  definitionItem?: Maybe<Vs_EgDefinitionItem>
  description?: Maybe<Vs_EgStoreProductDescription>
  dimensionsCollection?: Maybe<Vs_EgStoreProductDimensionsCollection>
  entryTitle?: Maybe<Scalars['String']>
  id?: Maybe<Scalars['String']>
  isSignatureItem?: Maybe<Scalars['Boolean']>
  isVisible?: Maybe<Scalars['Boolean']>
  linkedFrom?: Maybe<Vs_EgStoreProductLinkingCollections>
  sharedProductDetailAssetsCollection?: Maybe<Vs_EgStoreProductSharedProductDetailAssetsCollection>
  skusCollection?: Maybe<Vs_EgStoreProductSkusCollection>
  sys: Vs_Sys
  tagsCollection?: Maybe<Vs_EgStoreProductTagsCollection>
}

export type Vs_EgStoreProductDefinitionItemArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreProductDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductDimensionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProductEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductIdArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductIsSignatureItemArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductIsVisibleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStoreProductSharedProductDetailAssetsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProductSkusCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProductTagsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProductCollection = {
  __typename?: 'vs_EgStoreProductCollection'
  items: Array<Maybe<Vs_EgStoreProduct>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreProductDescription = {
  __typename?: 'vs_EgStoreProductDescription'
  links: Vs_EgStoreProductDescriptionLinks
}

export type Vs_EgStoreProductDescriptionAssets = {
  __typename?: 'vs_EgStoreProductDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgStoreProductDescriptionEntries = {
  __typename?: 'vs_EgStoreProductDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgStoreProductDescriptionLinks = {
  __typename?: 'vs_EgStoreProductDescriptionLinks'
  assets: Vs_EgStoreProductDescriptionAssets
  entries: Vs_EgStoreProductDescriptionEntries
}

export type Vs_EgStoreProductDetailPage = Vs_Entry & {
  __typename?: 'vs_EgStoreProductDetailPage'
  compatabilityCollection?: Maybe<Vs_EgStoreProductDetailPageCompatabilityCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  ctaBackground?: Maybe<Vs_EgMedia>
  dictionaries?: Maybe<Vs_EgStringListCollection>
  entryTitle?: Maybe<Scalars['String']>
  installationHelp?: Maybe<Vs_EgLink>
  linkedFrom?: Maybe<Vs_EgStoreProductDetailPageLinkingCollections>
  relatedTag?: Maybe<Vs_EgTag>
  returnTag?: Maybe<Vs_EgTag>
  scrollToTopLabel?: Maybe<Scalars['String']>
  sectionsCollection?: Maybe<Vs_EgStoreProductDetailPageSectionsCollection>
  seeAllLabel?: Maybe<Scalars['String']>
  selectLabel?: Maybe<Scalars['String']>
  shippingLabel?: Maybe<Scalars['String']>
  storeProduct?: Maybe<Vs_EgStoreProduct>
  sys: Vs_Sys
  unavailableLabel?: Maybe<Scalars['String']>
}

export type Vs_EgStoreProductDetailPageCompatabilityCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProductDetailPageCtaBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreProductDetailPageDictionariesArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreProductDetailPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductDetailPageInstallationHelpArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreProductDetailPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStoreProductDetailPageRelatedTagArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreProductDetailPageReturnTagArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreProductDetailPageScrollToTopLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductDetailPageSectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProductDetailPageSeeAllLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductDetailPageSelectLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductDetailPageShippingLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductDetailPageStoreProductArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoreProductDetailPageUnavailableLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoreProductDetailPageCollection = {
  __typename?: 'vs_EgStoreProductDetailPageCollection'
  items: Array<Maybe<Vs_EgStoreProductDetailPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreProductDetailPageCompatabilityCollection = {
  __typename?: 'vs_EgStoreProductDetailPageCompatabilityCollection'
  items: Array<Maybe<Vs_EgMultitextItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreProductDetailPageLinkingCollections = {
  __typename?: 'vs_EgStoreProductDetailPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStoreProductDetailPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProductDetailPageSectionsCollection = {
  __typename?: 'vs_EgStoreProductDetailPageSectionsCollection'
  items: Array<Maybe<Vs_EgStoreProductDetailPageSectionsItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreProductDetailPageSectionsItem =
  | Vs_EgFeaturesSection
  | Vs_EgSpecsSection
  | Vs_EgTitleIntroSection
  | Vs_EgVideo

export type Vs_EgStoreProductDimensionsCollection = {
  __typename?: 'vs_EgStoreProductDimensionsCollection'
  items: Array<Maybe<Vs_EgDimension>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreProductLinkingCollections = {
  __typename?: 'vs_EgStoreProductLinkingCollections'
  egHighlightItemCollection?: Maybe<Vs_EgHighlightItemCollection>
  egStoreProductDetailPageCollection?: Maybe<Vs_EgStoreProductDetailPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStoreProductLinkingCollectionsEgHighlightItemCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProductLinkingCollectionsEgStoreProductDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProductLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoreProductSharedProductDetailAssetsCollection = {
  __typename?: 'vs_EgStoreProductSharedProductDetailAssetsCollection'
  items: Array<Maybe<Vs_EgMedia>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreProductSkusCollection = {
  __typename?: 'vs_EgStoreProductSkusCollection'
  items: Array<Maybe<Vs_EgSku>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoreProductTagsCollection = {
  __typename?: 'vs_EgStoreProductTagsCollection'
  items: Array<Maybe<Vs_EgTag>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoryBlockImageStack = Vs_Entry & {
  __typename?: 'vs_EgStoryBlockImageStack'
  backgroundColor?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  imageLayout?: Maybe<Array<Maybe<Scalars['String']>>>
  largeImage?: Maybe<Vs_Asset>
  largeImagePosition?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgStoryBlockImageStackLinkingCollections>
  smallImage?: Maybe<Vs_Asset>
  smallImagePosition?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgStoryBlockImageStackBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockImageStackEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockImageStackImageLayoutArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockImageStackLargeImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoryBlockImageStackLargeImagePositionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockImageStackLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStoryBlockImageStackSmallImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoryBlockImageStackSmallImagePositionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockImageStackTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockImageStackCollection = {
  __typename?: 'vs_EgStoryBlockImageStackCollection'
  items: Array<Maybe<Vs_EgStoryBlockImageStack>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoryBlockImageStackLinkingCollections = {
  __typename?: 'vs_EgStoryBlockImageStackLinkingCollections'
  egCareersPeopleSectionCollection?: Maybe<Vs_EgCareersPeopleSectionCollection>
  egEditorialStorySectionCollection?: Maybe<Vs_EgEditorialStorySectionCollection>
  egLocationBlockCollection?: Maybe<Vs_EgLocationBlockCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStoryBlockImageStackLinkingCollectionsEgCareersPeopleSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryBlockImageStackLinkingCollectionsEgEditorialStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryBlockImageStackLinkingCollectionsEgLocationBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryBlockImageStackLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryBlockImageStackLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryBlockQuote = Vs_Entry & {
  __typename?: 'vs_EgStoryBlockQuote'
  author?: Maybe<Scalars['String']>
  authorTitle?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgStoryBlockQuoteLinkingCollections>
  quoteAlignment?: Maybe<Scalars['String']>
  quoteBody?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgStoryBlockQuoteAuthorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockQuoteAuthorTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockQuoteEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockQuoteLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStoryBlockQuoteQuoteAlignmentArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockQuoteQuoteBodyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockQuoteTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockQuoteLinkingCollections = {
  __typename?: 'vs_EgStoryBlockQuoteLinkingCollections'
  egCareersPeopleSectionCollection?: Maybe<Vs_EgCareersPeopleSectionCollection>
  egEditorialStorySectionCollection?: Maybe<Vs_EgEditorialStorySectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStoryBlockQuoteLinkingCollectionsEgCareersPeopleSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryBlockQuoteLinkingCollectionsEgEditorialStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryBlockQuoteLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryBlockText = Vs_Entry & {
  __typename?: 'vs_EgStoryBlockText'
  bodyCopy?: Maybe<Vs_EgStoryBlockTextBodyCopy>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgStoryBlockTextLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgStoryBlockTextBodyCopyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockTextEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockTextLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStoryBlockTextTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryBlockTextBodyCopy = {
  __typename?: 'vs_EgStoryBlockTextBodyCopy'
  links: Vs_EgStoryBlockTextBodyCopyLinks
}

export type Vs_EgStoryBlockTextBodyCopyAssets = {
  __typename?: 'vs_EgStoryBlockTextBodyCopyAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgStoryBlockTextBodyCopyEntries = {
  __typename?: 'vs_EgStoryBlockTextBodyCopyEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgStoryBlockTextBodyCopyLinks = {
  __typename?: 'vs_EgStoryBlockTextBodyCopyLinks'
  assets: Vs_EgStoryBlockTextBodyCopyAssets
  entries: Vs_EgStoryBlockTextBodyCopyEntries
}

export type Vs_EgStoryBlockTextLinkingCollections = {
  __typename?: 'vs_EgStoryBlockTextLinkingCollections'
  egCareersPeopleSectionCollection?: Maybe<Vs_EgCareersPeopleSectionCollection>
  egEditorialStorySectionCollection?: Maybe<Vs_EgEditorialStorySectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStoryBlockTextLinkingCollectionsEgCareersPeopleSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryBlockTextLinkingCollectionsEgEditorialStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryBlockTextLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStorySection = Vs_Entry & {
  __typename?: 'vs_EgStorySection'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgStorySectionLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  storyTilesCollection?: Maybe<Vs_EgStorySectionStoryTilesCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  topLevelCta?: Maybe<Vs_EgLink>
}

export type Vs_EgStorySectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStorySectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStorySectionMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStorySectionStoryTilesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStorySectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStorySectionTopLevelCtaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStorySectionCollection = {
  __typename?: 'vs_EgStorySectionCollection'
  items: Array<Maybe<Vs_EgStorySection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStorySectionLinkingCollections = {
  __typename?: 'vs_EgStorySectionLinkingCollections'
  egAccountHomepageCollection?: Maybe<Vs_EgAccountHomepageCollection>
  egHomePageCollection?: Maybe<Vs_EgHomePageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStorySectionLinkingCollectionsEgAccountHomepageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStorySectionLinkingCollectionsEgHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStorySectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStorySectionStoryTilesCollection = {
  __typename?: 'vs_EgStorySectionStoryTilesCollection'
  items: Array<Maybe<Vs_EgStoryTile>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoryTile = Vs_Entry & {
  __typename?: 'vs_EgStoryTile'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgStoryTileLinkingCollections>
  media?: Maybe<Vs_EgMedia>
  storyLink?: Maybe<Vs_EgLink>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgStoryTileDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryTileEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryTileLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStoryTileMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoryTileStoryLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStoryTileTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStoryTileCollection = {
  __typename?: 'vs_EgStoryTileCollection'
  items: Array<Maybe<Vs_EgStoryTile>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStoryTileLinkingCollections = {
  __typename?: 'vs_EgStoryTileLinkingCollections'
  egStorySectionCollection?: Maybe<Vs_EgStorySectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStoryTileLinkingCollectionsEgStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStoryTileLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgString = Vs_Entry & {
  __typename?: 'vs_EgString'
  contentfulMetadata: Vs_ContentfulMetadata
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgStringLinkingCollections>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_EgStringKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStringLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStringValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStringLinkingCollections = {
  __typename?: 'vs_EgStringLinkingCollections'
  egAccountHomeContentBlockCollection?: Maybe<Vs_EgAccountHomeContentBlockCollection>
  egAccountHomeHeroCollection?: Maybe<Vs_EgAccountHomeHeroCollection>
  egActivityCollection?: Maybe<Vs_EgActivityCollection>
  egAppointmentDetailPageCollection?: Maybe<Vs_EgAppointmentDetailPageCollection>
  egAppointmentSchedulerPageCollection?: Maybe<Vs_EgAppointmentSchedulerPageCollection>
  egInvitationPageCollection?: Maybe<Vs_EgInvitationPageCollection>
  egLeadFormCollection?: Maybe<Vs_EgLeadFormCollection>
  egMediaBlockCollection?: Maybe<Vs_EgMediaBlockCollection>
  egMediaCollectionCollection?: Maybe<Vs_EgMediaCollectionCollection>
  egShellInternalLinkCollection?: Maybe<Vs_EgShellInternalLinkCollection>
  egStringListCollection?: Maybe<Vs_EgStringListCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStringLinkingCollectionsEgAccountHomeContentBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEgAccountHomeHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEgActivityCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEgAppointmentDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEgAppointmentSchedulerPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEgInvitationPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEgLeadFormCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEgMediaBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEgMediaCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEgShellInternalLinkCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEgStringListCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringList = Vs_Entry & {
  __typename?: 'vs_EgStringList'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgStringListLinkingCollections>
  slug?: Maybe<Scalars['String']>
  stringsCollection?: Maybe<Vs_EgStringListStringsCollection>
  sys: Vs_Sys
}

export type Vs_EgStringListEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStringListLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStringListSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStringListStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringListCollection = Vs_Entry & {
  __typename?: 'vs_EgStringListCollection'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgStringListCollectionLinkingCollections>
  listsCollection?: Maybe<Vs_EgStringListCollectionListsCollection>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgStringListCollectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStringListCollectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStringListCollectionListsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringListCollectionSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStringListCollectionCollection = {
  __typename?: 'vs_EgStringListCollectionCollection'
  items: Array<Maybe<Vs_EgStringListCollection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStringListCollectionLinkingCollections = {
  __typename?: 'vs_EgStringListCollectionLinkingCollections'
  egLeadCapturePageCollection?: Maybe<Vs_EgLeadCapturePageCollection>
  egStoreProductDetailPageCollection?: Maybe<Vs_EgStoreProductDetailPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStringListCollectionLinkingCollectionsEgLeadCapturePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringListCollectionLinkingCollectionsEgStoreProductDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringListCollectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringListCollectionListsCollection = {
  __typename?: 'vs_EgStringListCollectionListsCollection'
  items: Array<Maybe<Vs_EgStringList>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStringListLinkingCollections = {
  __typename?: 'vs_EgStringListLinkingCollections'
  egAppointmentDetailPageCollection?: Maybe<Vs_EgAppointmentDetailPageCollection>
  egLeadFormCollection?: Maybe<Vs_EgLeadFormCollection>
  egStringListCollectionCollection?: Maybe<Vs_EgStringListCollectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStringListLinkingCollectionsEgAppointmentDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringListLinkingCollectionsEgLeadFormCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringListLinkingCollectionsEgStringListCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringListLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStringListStringsCollection = {
  __typename?: 'vs_EgStringListStringsCollection'
  items: Array<Maybe<Vs_EgString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStylePack = Vs_Entry & {
  __typename?: 'vs_EgStylePack'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgStylePackLinkingCollections>
  preview?: Maybe<Vs_Asset>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EgStylePackDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStylePackEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStylePackLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgStylePackPreviewArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgStylePackSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgStylePackCollection = {
  __typename?: 'vs_EgStylePackCollection'
  items: Array<Maybe<Vs_EgStylePack>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgStylePackLinkingCollections = {
  __typename?: 'vs_EgStylePackLinkingCollections'
  egColumnSectionCollection?: Maybe<Vs_EgColumnSectionCollection>
  egContentBlockCollection?: Maybe<Vs_EgContentBlockCollection>
  egDocsPageCollection?: Maybe<Vs_EgDocsPageCollection>
  egDocumentsCollectionCollection?: Maybe<Vs_EgDocumentsCollectionCollection>
  egHeroCollection?: Maybe<Vs_EgHeroCollection>
  egHighlightedTextCollection?: Maybe<Vs_EgHighlightedTextCollection>
  egLinkCollection?: Maybe<Vs_EgLinkCollection>
  egMediaBlockCollection?: Maybe<Vs_EgMediaBlockCollection>
  egMediaCollectionCollection?: Maybe<Vs_EgMediaCollectionCollection>
  egMediaMultitextItemCollection?: Maybe<Vs_EgMediaMultitextItemCollection>
  egMultimediaCollectionCollection?: Maybe<Vs_EgMultimediaCollectionCollection>
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egOverlayCollection?: Maybe<Vs_EgOverlayCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  egTitleIntroSectionCollection?: Maybe<Vs_EgTitleIntroSectionCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgStylePackLinkingCollectionsEgColumnSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgContentBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgDocsPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgDocumentsCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgHighlightedTextCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgLinkCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgMediaBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgMediaCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgMediaMultitextItemCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgMultimediaCollectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgOverlayCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEgTitleIntroSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgStylePackLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTab = Vs_Entry & {
  __typename?: 'vs_EgTab'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgTabLinkingCollections>
  sys: Vs_Sys
  tabContent?: Maybe<Vs_EgMedia>
  tabLabelImage?: Maybe<Vs_EgMedia>
  tabLabelText?: Maybe<Scalars['String']>
}

export type Vs_EgTabEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTabLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgTabTabContentArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTabTabLabelImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTabTabLabelTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTabCollection = {
  __typename?: 'vs_EgTabCollection'
  items: Array<Maybe<Vs_EgTab>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgTabComponent = Vs_Entry & {
  __typename?: 'vs_EgTabComponent'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgTabComponentLinkingCollections>
  shouldLoop?: Maybe<Scalars['Boolean']>
  sys: Vs_Sys
  tabsCollection?: Maybe<Vs_EgTabComponentTabsCollection>
}

export type Vs_EgTabComponentEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTabComponentLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgTabComponentShouldLoopArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTabComponentTabsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTabComponentCollection = {
  __typename?: 'vs_EgTabComponentCollection'
  items: Array<Maybe<Vs_EgTabComponent>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgTabComponentLinkingCollections = {
  __typename?: 'vs_EgTabComponentLinkingCollections'
  egCarouselSlideCollection?: Maybe<Vs_EgCarouselSlideCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgTabComponentLinkingCollectionsEgCarouselSlideCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTabComponentLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTabComponentTabsCollection = {
  __typename?: 'vs_EgTabComponentTabsCollection'
  items: Array<Maybe<Vs_EgTab>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgTabLinkingCollections = {
  __typename?: 'vs_EgTabLinkingCollections'
  egTabComponentCollection?: Maybe<Vs_EgTabComponentCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgTabLinkingCollectionsEgTabComponentCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTabLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTag = Vs_Entry & {
  __typename?: 'vs_EgTag'
  contentfulMetadata: Vs_ContentfulMetadata
  definitionItem?: Maybe<Vs_EgDefinitionItem>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgTagLinkingCollections>
  sys: Vs_Sys
  type?: Maybe<Scalars['String']>
}

export type Vs_EgTagDefinitionItemArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTagEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTagLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgTagTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTagCollection = {
  __typename?: 'vs_EgTagCollection'
  items: Array<Maybe<Vs_EgTag>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgTagLinkingCollections = {
  __typename?: 'vs_EgTagLinkingCollections'
  egCollectionsContainerCollection?: Maybe<Vs_EgCollectionsContainerCollection>
  egStoreCollectionPageCollection?: Maybe<Vs_EgStoreCollectionPageCollection>
  egStoreProductCollection?: Maybe<Vs_EgStoreProductCollection>
  egStoreProductDetailPageCollection?: Maybe<Vs_EgStoreProductDetailPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgTagLinkingCollectionsEgCollectionsContainerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTagLinkingCollectionsEgStoreCollectionPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTagLinkingCollectionsEgStoreProductCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTagLinkingCollectionsEgStoreProductDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTagLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTextBlock = Vs_Entry & {
  __typename?: 'vs_EgTextBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  cta?: Maybe<Vs_EgLink>
  description?: Maybe<Vs_EgTextBlockDescription>
  entryTitle?: Maybe<Scalars['String']>
  icon?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_EgTextBlockLinkingCollections>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgTextBlockCtaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTextBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTextBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTextBlockIconArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTextBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgTextBlockSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTextBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTextBlockCollection = {
  __typename?: 'vs_EgTextBlockCollection'
  items: Array<Maybe<Vs_EgTextBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgTextBlockDescription = {
  __typename?: 'vs_EgTextBlockDescription'
  links: Vs_EgTextBlockDescriptionLinks
}

export type Vs_EgTextBlockDescriptionAssets = {
  __typename?: 'vs_EgTextBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgTextBlockDescriptionEntries = {
  __typename?: 'vs_EgTextBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgTextBlockDescriptionLinks = {
  __typename?: 'vs_EgTextBlockDescriptionLinks'
  assets: Vs_EgTextBlockDescriptionAssets
  entries: Vs_EgTextBlockDescriptionEntries
}

export type Vs_EgTextBlockLinkingCollections = {
  __typename?: 'vs_EgTextBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgTextBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTextWithDetailsSection = Vs_Entry & {
  __typename?: 'vs_EgTextWithDetailsSection'
  contentfulMetadata: Vs_ContentfulMetadata
  detailBlock?: Maybe<Vs_EgDetail>
  detailBlockTitle?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  highlightedText?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgTextWithDetailsSectionLinkingCollections>
  sys: Vs_Sys
}

export type Vs_EgTextWithDetailsSectionDetailBlockArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTextWithDetailsSectionDetailBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTextWithDetailsSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTextWithDetailsSectionHighlightedTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTextWithDetailsSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgTextWithDetailsSectionCollection = {
  __typename?: 'vs_EgTextWithDetailsSectionCollection'
  items: Array<Maybe<Vs_EgTextWithDetailsSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgTextWithDetailsSectionLinkingCollections = {
  __typename?: 'vs_EgTextWithDetailsSectionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgTextWithDetailsSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTitleIntroSection = Vs_Entry & {
  __typename?: 'vs_EgTitleIntroSection'
  anchorTag?: Maybe<Scalars['String']>
  backgroundColor?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  cta?: Maybe<Vs_EgLink>
  displayType?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgTitleIntroSectionLinkingCollections>
  stylePack?: Maybe<Vs_EgStylePack>
  subtitle?: Maybe<Vs_EgTitleIntroSectionSubtitle>
  sys: Vs_Sys
  title?: Maybe<Vs_EgTitleIntroSectionTitle>
}

export type Vs_EgTitleIntroSectionAnchorTagArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTitleIntroSectionBackgroundColorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTitleIntroSectionCtaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTitleIntroSectionDisplayTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTitleIntroSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTitleIntroSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgTitleIntroSectionStylePackArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTitleIntroSectionSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTitleIntroSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTitleIntroSectionCollection = {
  __typename?: 'vs_EgTitleIntroSectionCollection'
  items: Array<Maybe<Vs_EgTitleIntroSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgTitleIntroSectionLinkingCollections = {
  __typename?: 'vs_EgTitleIntroSectionLinkingCollections'
  egDocsPageCollection?: Maybe<Vs_EgDocsPageCollection>
  egNewsArticlePageCollection?: Maybe<Vs_EgNewsArticlePageCollection>
  egPageCollection?: Maybe<Vs_EgPageCollection>
  egStoreProductDetailPageCollection?: Maybe<Vs_EgStoreProductDetailPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgTitleIntroSectionLinkingCollectionsEgDocsPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTitleIntroSectionLinkingCollectionsEgNewsArticlePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTitleIntroSectionLinkingCollectionsEgPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTitleIntroSectionLinkingCollectionsEgStoreProductDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTitleIntroSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTitleIntroSectionSubtitle = {
  __typename?: 'vs_EgTitleIntroSectionSubtitle'
  links: Vs_EgTitleIntroSectionSubtitleLinks
}

export type Vs_EgTitleIntroSectionSubtitleAssets = {
  __typename?: 'vs_EgTitleIntroSectionSubtitleAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgTitleIntroSectionSubtitleEntries = {
  __typename?: 'vs_EgTitleIntroSectionSubtitleEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgTitleIntroSectionSubtitleLinks = {
  __typename?: 'vs_EgTitleIntroSectionSubtitleLinks'
  assets: Vs_EgTitleIntroSectionSubtitleAssets
  entries: Vs_EgTitleIntroSectionSubtitleEntries
}

export type Vs_EgTitleIntroSectionTitle = {
  __typename?: 'vs_EgTitleIntroSectionTitle'
  links: Vs_EgTitleIntroSectionTitleLinks
}

export type Vs_EgTitleIntroSectionTitleAssets = {
  __typename?: 'vs_EgTitleIntroSectionTitleAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgTitleIntroSectionTitleEntries = {
  __typename?: 'vs_EgTitleIntroSectionTitleEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgTitleIntroSectionTitleLinks = {
  __typename?: 'vs_EgTitleIntroSectionTitleLinks'
  assets: Vs_EgTitleIntroSectionTitleAssets
  entries: Vs_EgTitleIntroSectionTitleEntries
}

export type Vs_EgTooltip = Vs_Entry & {
  __typename?: 'vs_EgTooltip'
  closeText?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgTooltipLinkingCollections>
  richDescription?: Maybe<Vs_EgTooltipRichDescription>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgTooltipCloseTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTooltipEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTooltipLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgTooltipRichDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTooltipTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTooltipLinkingCollections = {
  __typename?: 'vs_EgTooltipLinkingCollections'
  egHighlightSpecItemCollection?: Maybe<Vs_EgHighlightSpecItemCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgTooltipLinkingCollectionsEgHighlightSpecItemCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTooltipLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTooltipRichDescription = {
  __typename?: 'vs_EgTooltipRichDescription'
  links: Vs_EgTooltipRichDescriptionLinks
}

export type Vs_EgTooltipRichDescriptionAssets = {
  __typename?: 'vs_EgTooltipRichDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_EgTooltipRichDescriptionEntries = {
  __typename?: 'vs_EgTooltipRichDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_EgTooltipRichDescriptionLinks = {
  __typename?: 'vs_EgTooltipRichDescriptionLinks'
  assets: Vs_EgTooltipRichDescriptionAssets
  entries: Vs_EgTooltipRichDescriptionEntries
}

export type Vs_EgTrimsSection = Vs_Entry & {
  __typename?: 'vs_EgTrimsSection'
  adventurePackageImage?: Maybe<Vs_Asset>
  compareTrimsModalLabel?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  deliveryDateAdventurePackage?: Maybe<Scalars['String']>
  deliveryDateExplorePackage?: Maybe<Scalars['String']>
  deliveryDateLaunchEdition?: Maybe<Scalars['String']>
  deliveryLabel?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  explorePackageImage?: Maybe<Vs_Asset>
  includesLabel?: Maybe<Scalars['String']>
  launchEditionImage?: Maybe<Vs_Asset>
  launchEditionModalLabel?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgTrimsSectionLinkingCollections>
  sectionTitle?: Maybe<Scalars['String']>
  startingAtLabel?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_EgTrimsSectionAdventurePackageImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTrimsSectionCompareTrimsModalLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionDeliveryDateAdventurePackageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionDeliveryDateExplorePackageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionDeliveryDateLaunchEditionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionDeliveryLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionExplorePackageImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTrimsSectionIncludesLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionLaunchEditionImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgTrimsSectionLaunchEditionModalLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgTrimsSectionSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionStartingAtLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgTrimsSectionCollection = {
  __typename?: 'vs_EgTrimsSectionCollection'
  items: Array<Maybe<Vs_EgTrimsSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgTrimsSectionLinkingCollections = {
  __typename?: 'vs_EgTrimsSectionLinkingCollections'
  egProductPageCollection?: Maybe<Vs_EgProductPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EgTrimsSectionLinkingCollectionsEgProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgTrimsSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgVideo = Vs_Entry & {
  __typename?: 'vs_EgVideo'
  autoplay?: Maybe<Scalars['Boolean']>
  contentfulMetadata: Vs_ContentfulMetadata
  coverImage?: Maybe<Vs_Asset>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EgVideoLinkingCollections>
  loop?: Maybe<Scalars['Boolean']>
  mediaFile?: Maybe<Vs_Asset>
  mobileMediaFile?: Maybe<Vs_Asset>
  playButtonText?: Maybe<Scalars['String']>
  subtitle?: Maybe<Scalars['String']>
  supportMessage?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  videoCaptions?: Maybe<Vs_Asset>
  videoLink?: Maybe<Scalars['String']>
}

export type Vs_EgVideoAutoplayArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgVideoCoverImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgVideoEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgVideoLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EgVideoLoopArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgVideoMediaFileArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgVideoMobileMediaFileArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgVideoPlayButtonTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgVideoSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgVideoSupportMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgVideoTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgVideoVideoCaptionsArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_EgVideoVideoLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EgVideoCollection = {
  __typename?: 'vs_EgVideoCollection'
  items: Array<Maybe<Vs_EgVideo>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EgVideoLinkingCollections = {
  __typename?: 'vs_EgVideoLinkingCollections'
  egAccountHomeVideoSectionCollection?: Maybe<Vs_EgAccountHomeVideoSectionCollection>
  egCarouselSlideCollection?: Maybe<Vs_EgCarouselSlideCollection>
  egEditorialStorySectionCollection?: Maybe<Vs_EgEditorialStorySectionCollection>
  egMediaCollection?: Maybe<Vs_EgMediaCollection>
  egStoreProductDetailPageCollection?: Maybe<Vs_EgStoreProductDetailPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  productPageCollection?: Maybe<Vs_ProductPageCollection>
  sectionCollection?: Maybe<Vs_SectionCollection>
  thankYouPageCollection?: Maybe<Vs_ThankYouPageCollection>
}

export type Vs_EgVideoLinkingCollectionsEgAccountHomeVideoSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgVideoLinkingCollectionsEgCarouselSlideCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgVideoLinkingCollectionsEgEditorialStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgVideoLinkingCollectionsEgMediaCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgVideoLinkingCollectionsEgStoreProductDetailPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgVideoLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgVideoLinkingCollectionsProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgVideoLinkingCollectionsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EgVideoLinkingCollectionsThankYouPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EmailFooter = Vs_Entry & {
  __typename?: 'vs_EmailFooter'
  contentfulMetadata: Vs_ContentfulMetadata
  copyright?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  legalAddress?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_EmailFooterLinkingCollections>
  privacyPolicyLabel?: Maybe<Scalars['String']>
  privacyPolicyLink?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_EmailFooterCopyrightArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EmailFooterEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EmailFooterLegalAddressArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EmailFooterLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EmailFooterPrivacyPolicyLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EmailFooterPrivacyPolicyLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EmailFooterLinkingCollections = {
  __typename?: 'vs_EmailFooterLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  preOrderCancellationEmailCollection?: Maybe<Vs_PreOrderCancellationEmailCollection>
}

export type Vs_EmailFooterLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EmailFooterLinkingCollectionsPreOrderCancellationEmailCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Entry = {
  contentfulMetadata: Vs_ContentfulMetadata
  sys: Vs_Sys
}

export type Vs_EntryCollection = {
  __typename?: 'vs_EntryCollection'
  items: Array<Maybe<Vs_Entry>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_EntryMigrationVersion = Vs_Entry & {
  __typename?: 'vs_EntryMigrationVersion'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_EntryMigrationVersionLinkingCollections>
  sys: Vs_Sys
  teamName?: Maybe<Scalars['String']>
  teamPrefix?: Maybe<Scalars['String']>
  version?: Maybe<Scalars['String']>
}

export type Vs_EntryMigrationVersionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EntryMigrationVersionTeamNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EntryMigrationVersionTeamPrefixArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EntryMigrationVersionVersionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EntryMigrationVersionLinkingCollections = {
  __typename?: 'vs_EntryMigrationVersionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EntryMigrationVersionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_EntryMigrationsRanLog = Vs_Entry & {
  __typename?: 'vs_EntryMigrationsRanLog'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_EntryMigrationsRanLogLinkingCollections>
  name?: Maybe<Scalars['String']>
  sys: Vs_Sys
  teamName?: Maybe<Scalars['String']>
  teamPrefix?: Maybe<Scalars['String']>
  version?: Maybe<Scalars['String']>
}

export type Vs_EntryMigrationsRanLogLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_EntryMigrationsRanLogNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EntryMigrationsRanLogRanAtArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EntryMigrationsRanLogTeamNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EntryMigrationsRanLogTeamPrefixArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EntryMigrationsRanLogVersionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_EntryMigrationsRanLogLinkingCollections = {
  __typename?: 'vs_EntryMigrationsRanLogLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_EntryMigrationsRanLogLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ErrorPage = Vs_Entry & {
  __typename?: 'vs_ErrorPage'
  actionLink?: Maybe<Vs_EgLink>
  background?: Maybe<Vs_Media>
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_ErrorPageLinkingCollections>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_ErrorPageActionLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ErrorPageBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ErrorPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ErrorPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ErrorPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ErrorPageSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ErrorPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ErrorPageCollection = {
  __typename?: 'vs_ErrorPageCollection'
  items: Array<Maybe<Vs_ErrorPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ErrorPageLinkingCollections = {
  __typename?: 'vs_ErrorPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_ErrorPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FaqPage = Vs_Entry & {
  __typename?: 'vs_FaqPage'
  banner?: Maybe<Vs_Banner>
  contactLabel?: Maybe<Scalars['String']>
  contactLink?: Maybe<Vs_EgLink>
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_FaqPageLinkingCollections>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  tabSectionsCollection?: Maybe<Vs_FaqPageTabSectionsCollection>
  title?: Maybe<Scalars['String']>
}

export type Vs_FaqPageBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_FaqPageContactLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FaqPageContactLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_FaqPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FaqPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_FaqPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FaqPageTabSectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FaqPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FaqPageCollection = {
  __typename?: 'vs_FaqPageCollection'
  items: Array<Maybe<Vs_FaqPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FaqPageLinkingCollections = {
  __typename?: 'vs_FaqPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_FaqPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FaqPageTabSectionsCollection = {
  __typename?: 'vs_FaqPageTabSectionsCollection'
  items: Array<Maybe<Vs_TabSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_Feature = Vs_Entry & {
  __typename?: 'vs_Feature'
  contentfulMetadata: Vs_ContentfulMetadata
  icon?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_FeatureLinkingCollections>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_FeatureIconArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_FeatureLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FeatureSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FeatureTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FeatureBanner = Vs_Entry & {
  __typename?: 'vs_FeatureBanner'
  background?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  ctaLink?: Maybe<Vs_EgLink>
  linkedFrom?: Maybe<Vs_FeatureBannerLinkingCollections>
  modalLinkText?: Maybe<Scalars['String']>
  modalText?: Maybe<Vs_FeatureBannerModalText>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_FeatureBannerBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_FeatureBannerCtaLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_FeatureBannerLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FeatureBannerModalLinkTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FeatureBannerModalTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FeatureBannerSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FeatureBannerTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FeatureBannerCollection = {
  __typename?: 'vs_FeatureBannerCollection'
  items: Array<Maybe<Vs_FeatureBanner>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FeatureBannerLinkingCollections = {
  __typename?: 'vs_FeatureBannerLinkingCollections'
  aboutPageCollection?: Maybe<Vs_AboutPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  productPageCollection?: Maybe<Vs_ProductPageCollection>
}

export type Vs_FeatureBannerLinkingCollectionsAboutPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FeatureBannerLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FeatureBannerLinkingCollectionsProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FeatureBannerModalText = {
  __typename?: 'vs_FeatureBannerModalText'
  links: Vs_FeatureBannerModalTextLinks
}

export type Vs_FeatureBannerModalTextAssets = {
  __typename?: 'vs_FeatureBannerModalTextAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_FeatureBannerModalTextEntries = {
  __typename?: 'vs_FeatureBannerModalTextEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_FeatureBannerModalTextLinks = {
  __typename?: 'vs_FeatureBannerModalTextLinks'
  assets: Vs_FeatureBannerModalTextAssets
  entries: Vs_FeatureBannerModalTextEntries
}

export type Vs_FeatureCollection = {
  __typename?: 'vs_FeatureCollection'
  items: Array<Maybe<Vs_Feature>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FeatureLinkingCollections = {
  __typename?: 'vs_FeatureLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  featuresSectionCollection?: Maybe<Vs_FeaturesSectionCollection>
}

export type Vs_FeatureLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FeatureLinkingCollectionsFeaturesSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FeaturesSection = Vs_Entry & {
  __typename?: 'vs_FeaturesSection'
  background?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  featuresCollection?: Maybe<Vs_FeaturesSectionFeaturesCollection>
  linkedFrom?: Maybe<Vs_FeaturesSectionLinkingCollections>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_FeaturesSectionBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_FeaturesSectionFeaturesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FeaturesSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FeaturesSectionSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FeaturesSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FeaturesSectionCollection = {
  __typename?: 'vs_FeaturesSectionCollection'
  items: Array<Maybe<Vs_FeaturesSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FeaturesSectionFeaturesCollection = {
  __typename?: 'vs_FeaturesSectionFeaturesCollection'
  items: Array<Maybe<Vs_Feature>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FeaturesSectionLinkingCollections = {
  __typename?: 'vs_FeaturesSectionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  productPageCollection?: Maybe<Vs_ProductPageCollection>
}

export type Vs_FeaturesSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FeaturesSectionLinkingCollectionsProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FlUiElement = Vs_Entry & {
  __typename?: 'vs_FlUiElement'
  asset?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_FlUiElementLinkingCollections>
  longTextValue?: Maybe<Scalars['String']>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_FlUiElementAssetArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_FlUiElementKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FlUiElementLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FlUiElementLongTextValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FlUiElementValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FlUiElementCollection = {
  __typename?: 'vs_FlUiElementCollection'
  items: Array<Maybe<Vs_FlUiElement>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FlUiElementFilter = {
  AND?: InputMaybe<Array<InputMaybe<Vs_FlUiElementFilter>>>
  OR?: InputMaybe<Array<InputMaybe<Vs_FlUiElementFilter>>>
  asset_exists?: InputMaybe<Scalars['Boolean']>
  contentfulMetadata?: InputMaybe<Vs_ContentfulMetadataFilter>
  key?: InputMaybe<Scalars['String']>
  key_contains?: InputMaybe<Scalars['String']>
  key_exists?: InputMaybe<Scalars['Boolean']>
  key_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  key_not?: InputMaybe<Scalars['String']>
  key_not_contains?: InputMaybe<Scalars['String']>
  key_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  longTextValue?: InputMaybe<Scalars['String']>
  longTextValue_contains?: InputMaybe<Scalars['String']>
  longTextValue_exists?: InputMaybe<Scalars['Boolean']>
  longTextValue_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  longTextValue_not?: InputMaybe<Scalars['String']>
  longTextValue_not_contains?: InputMaybe<Scalars['String']>
  longTextValue_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  sys?: InputMaybe<Vs_SysFilter>
  value?: InputMaybe<Scalars['String']>
  value_contains?: InputMaybe<Scalars['String']>
  value_exists?: InputMaybe<Scalars['Boolean']>
  value_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  value_not?: InputMaybe<Scalars['String']>
  value_not_contains?: InputMaybe<Scalars['String']>
  value_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FlUiElementLinkingCollections = {
  __typename?: 'vs_FlUiElementLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  flUiElementsGroupCollection?: Maybe<Vs_FlUiElementsGroupCollection>
}

export type Vs_FlUiElementLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FlUiElementLinkingCollectionsFlUiElementsGroupCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export enum Vs_FlUiElementOrder {
  KeyAsc = 'key_ASC',
  KeyDesc = 'key_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  ValueAsc = 'value_ASC',
  ValueDesc = 'value_DESC'
}

export type Vs_FlUiElementsGroup = Vs_Entry & {
  __typename?: 'vs_FlUiElementsGroup'
  contentfulMetadata: Vs_ContentfulMetadata
  elementsCollection?: Maybe<Vs_FlUiElementsGroupElementsCollection>
  linkedFrom?: Maybe<Vs_FlUiElementsGroupLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_FlUiElementsGroupElementsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FlUiElementsGroupLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FlUiElementsGroupSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FlUiElementsGroupTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FlUiElementsGroupCollection = {
  __typename?: 'vs_FlUiElementsGroupCollection'
  items: Array<Maybe<Vs_FlUiElementsGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FlUiElementsGroupElementsCollection = {
  __typename?: 'vs_FlUiElementsGroupElementsCollection'
  items: Array<Maybe<Vs_FlUiElement>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FlUiElementsGroupFilter = {
  AND?: InputMaybe<Array<InputMaybe<Vs_FlUiElementsGroupFilter>>>
  OR?: InputMaybe<Array<InputMaybe<Vs_FlUiElementsGroupFilter>>>
  contentfulMetadata?: InputMaybe<Vs_ContentfulMetadataFilter>
  elementsCollection_exists?: InputMaybe<Scalars['Boolean']>
  slug?: InputMaybe<Scalars['String']>
  slug_contains?: InputMaybe<Scalars['String']>
  slug_exists?: InputMaybe<Scalars['Boolean']>
  slug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  slug_not?: InputMaybe<Scalars['String']>
  slug_not_contains?: InputMaybe<Scalars['String']>
  slug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  sys?: InputMaybe<Vs_SysFilter>
  title?: InputMaybe<Scalars['String']>
  title_contains?: InputMaybe<Scalars['String']>
  title_exists?: InputMaybe<Scalars['Boolean']>
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  title_not?: InputMaybe<Scalars['String']>
  title_not_contains?: InputMaybe<Scalars['String']>
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FlUiElementsGroupLinkingCollections = {
  __typename?: 'vs_FlUiElementsGroupLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  flUiStringsCollection?: Maybe<Vs_FlUiStringsCollection>
}

export type Vs_FlUiElementsGroupLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FlUiElementsGroupLinkingCollectionsFlUiStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export enum Vs_FlUiElementsGroupOrder {
  SlugAsc = 'slug_ASC',
  SlugDesc = 'slug_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type Vs_FlUiStrings = Vs_Entry & {
  __typename?: 'vs_FlUiStrings'
  contentfulMetadata: Vs_ContentfulMetadata
  elementGroupsCollection?: Maybe<Vs_FlUiStringsElementGroupsCollection>
  linkedFrom?: Maybe<Vs_FlUiStringsLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_FlUiStringsElementGroupsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FlUiStringsLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FlUiStringsSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FlUiStringsCollection = {
  __typename?: 'vs_FlUiStringsCollection'
  items: Array<Maybe<Vs_FlUiStrings>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FlUiStringsElementGroupsCollection = {
  __typename?: 'vs_FlUiStringsElementGroupsCollection'
  items: Array<Maybe<Vs_FlUiElementsGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FlUiStringsFilter = {
  AND?: InputMaybe<Array<InputMaybe<Vs_FlUiStringsFilter>>>
  OR?: InputMaybe<Array<InputMaybe<Vs_FlUiStringsFilter>>>
  contentfulMetadata?: InputMaybe<Vs_ContentfulMetadataFilter>
  elementGroupsCollection_exists?: InputMaybe<Scalars['Boolean']>
  slug?: InputMaybe<Scalars['String']>
  slug_contains?: InputMaybe<Scalars['String']>
  slug_exists?: InputMaybe<Scalars['Boolean']>
  slug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  slug_not?: InputMaybe<Scalars['String']>
  slug_not_contains?: InputMaybe<Scalars['String']>
  slug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  sys?: InputMaybe<Vs_SysFilter>
}

export type Vs_FlUiStringsLinkingCollections = {
  __typename?: 'vs_FlUiStringsLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_FlUiStringsLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export enum Vs_FlUiStringsOrder {
  SlugAsc = 'slug_ASC',
  SlugDesc = 'slug_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC'
}

export type Vs_FleetPage = Vs_Entry & {
  __typename?: 'vs_FleetPage'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  itemsCollection?: Maybe<Vs_FleetPageItemsCollection>
  linkedFrom?: Maybe<Vs_FleetPageLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_FleetPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FleetPageItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FleetPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FleetPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FleetPageCollection = {
  __typename?: 'vs_FleetPageCollection'
  items: Array<Maybe<Vs_FleetPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FleetPageItemsCollection = {
  __typename?: 'vs_FleetPageItemsCollection'
  items: Array<Maybe<Vs_FleetString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FleetPageLinkingCollections = {
  __typename?: 'vs_FleetPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  fleetProjectCollection?: Maybe<Vs_FleetProjectCollection>
}

export type Vs_FleetPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FleetPageLinkingCollectionsFleetProjectCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FleetProject = Vs_Entry & {
  __typename?: 'vs_FleetProject'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  itemsCollection?: Maybe<Vs_FleetProjectItemsCollection>
  linkedFrom?: Maybe<Vs_FleetProjectLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_FleetProjectEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FleetProjectItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FleetProjectLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FleetProjectSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FleetProjectCollection = {
  __typename?: 'vs_FleetProjectCollection'
  items: Array<Maybe<Vs_FleetProject>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FleetProjectItemsCollection = {
  __typename?: 'vs_FleetProjectItemsCollection'
  items: Array<Maybe<Vs_FleetPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FleetProjectLinkingCollections = {
  __typename?: 'vs_FleetProjectLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_FleetProjectLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FleetString = Vs_Entry & {
  __typename?: 'vs_FleetString'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_FleetStringLinkingCollections>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_FleetStringEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FleetStringKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FleetStringLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FleetStringValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FleetStringLinkingCollections = {
  __typename?: 'vs_FleetStringLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  fleetPageCollection?: Maybe<Vs_FleetPageCollection>
}

export type Vs_FleetStringLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FleetStringLinkingCollectionsFleetPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Footer = Vs_Entry & {
  __typename?: 'vs_Footer'
  blocksCollection?: Maybe<Vs_FooterBlocksCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  copyright?: Maybe<Scalars['String']>
  footerLogo?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_FooterLinkingCollections>
  mobileLinksCollection?: Maybe<Vs_FooterMobileLinksCollection>
  social?: Maybe<Vs_Social>
  sys: Vs_Sys
}

export type Vs_FooterBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FooterCopyrightArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FooterFooterLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_FooterLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FooterMobileLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FooterSocialArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_FooterBlock = Vs_Entry & {
  __typename?: 'vs_FooterBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_FooterBlockLinkingCollections>
  listCollection?: Maybe<Vs_FooterBlockListCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_FooterBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_FooterBlockListCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FooterBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_FooterBlockCollection = {
  __typename?: 'vs_FooterBlockCollection'
  items: Array<Maybe<Vs_FooterBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FooterBlockLinkingCollections = {
  __typename?: 'vs_FooterBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  footerCollection?: Maybe<Vs_FooterCollection>
}

export type Vs_FooterBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FooterBlockLinkingCollectionsFooterCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FooterBlockListCollection = {
  __typename?: 'vs_FooterBlockListCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FooterBlocksCollection = {
  __typename?: 'vs_FooterBlocksCollection'
  items: Array<Maybe<Vs_FooterBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FooterCollection = {
  __typename?: 'vs_FooterCollection'
  items: Array<Maybe<Vs_Footer>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_FooterLinkingCollections = {
  __typename?: 'vs_FooterLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_FooterLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_FooterMobileLinksCollection = {
  __typename?: 'vs_FooterMobileLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_Header = Vs_Entry & {
  __typename?: 'vs_Header'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_HeaderLinkingCollections>
  linksCollection?: Maybe<Vs_HeaderLinksCollection>
  logo?: Maybe<Vs_Asset>
  logoDark?: Maybe<Vs_Asset>
  sys: Vs_Sys
}

export type Vs_HeaderEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HeaderLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_HeaderLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HeaderLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HeaderLogoDarkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HeaderCollection = {
  __typename?: 'vs_HeaderCollection'
  items: Array<Maybe<Vs_Header>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_HeaderLinkingCollections = {
  __typename?: 'vs_HeaderLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_HeaderLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HeaderLinksCollection = {
  __typename?: 'vs_HeaderLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_Heroes = Vs_Entry & {
  __typename?: 'vs_Heroes'
  actionLink?: Maybe<Vs_EgLink>
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_HeroesLinkingCollections>
  media?: Maybe<Vs_Media>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_HeroesActionLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HeroesLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_HeroesMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HeroesSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HeroesTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HeroesCollection = {
  __typename?: 'vs_HeroesCollection'
  items: Array<Maybe<Vs_Heroes>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_HeroesLinkingCollections = {
  __typename?: 'vs_HeroesLinkingCollections'
  aboutPageCollection?: Maybe<Vs_AboutPageCollection>
  egRpvPageCollection?: Maybe<Vs_EgRpvPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  homePageCollection?: Maybe<Vs_HomePageCollection>
  pagesCollection?: Maybe<Vs_PagesCollection>
  productPageCollection?: Maybe<Vs_ProductPageCollection>
  rivianIdHomePageCollection?: Maybe<Vs_RivianIdHomePageCollection>
  technologyPageCollection?: Maybe<Vs_TechnologyPageCollection>
}

export type Vs_HeroesLinkingCollectionsAboutPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HeroesLinkingCollectionsEgRpvPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HeroesLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HeroesLinkingCollectionsHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HeroesLinkingCollectionsPagesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HeroesLinkingCollectionsProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HeroesLinkingCollectionsRivianIdHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HeroesLinkingCollectionsTechnologyPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Highlight = Vs_Entry & {
  __typename?: 'vs_Highlight'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_HighlightLinkingCollections>
  slug?: Maybe<Scalars['String']>
  subTitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_HighlightHighlightItemsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_HighlightSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightSubTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightBlock = Vs_Entry & {
  __typename?: 'vs_HighlightBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_HighlightBlockLinkingCollections>
  media?: Maybe<Vs_Media>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  type?: Maybe<Scalars['String']>
}

export type Vs_HighlightBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_HighlightBlockMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HighlightBlockSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightBlockTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightBlockCollection = {
  __typename?: 'vs_HighlightBlockCollection'
  items: Array<Maybe<Vs_HighlightBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_HighlightBlockLinkingCollections = {
  __typename?: 'vs_HighlightBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  highlightSectionCollection?: Maybe<Vs_HighlightSectionCollection>
}

export type Vs_HighlightBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HighlightBlockLinkingCollectionsHighlightSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HighlightLinkingCollections = {
  __typename?: 'vs_HighlightLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_HighlightLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HighlightSection = Vs_Entry & {
  __typename?: 'vs_HighlightSection'
  alignment?: Maybe<Scalars['String']>
  blocksCollection?: Maybe<Vs_HighlightSectionBlocksCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  ctaText?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_HighlightSectionLinkingCollections>
  media?: Maybe<Vs_Media>
  panelBackground?: Maybe<Vs_Asset>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_HighlightSectionAlignmentArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightSectionBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HighlightSectionCtaTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_HighlightSectionMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HighlightSectionPanelBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HighlightSectionSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightSectionBlocksCollection = {
  __typename?: 'vs_HighlightSectionBlocksCollection'
  items: Array<Maybe<Vs_HighlightBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_HighlightSectionCollection = {
  __typename?: 'vs_HighlightSectionCollection'
  items: Array<Maybe<Vs_HighlightSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_HighlightSectionLinkingCollections = {
  __typename?: 'vs_HighlightSectionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  productPageCollection?: Maybe<Vs_ProductPageCollection>
  technologyPageCollection?: Maybe<Vs_TechnologyPageCollection>
}

export type Vs_HighlightSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HighlightSectionLinkingCollectionsProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HighlightSectionLinkingCollectionsTechnologyPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HighlightedTextSection = Vs_Entry & {
  __typename?: 'vs_HighlightedTextSection'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_HighlightedTextSectionLinkingCollections>
  subtitleText?: Maybe<Scalars['String']>
  sys: Vs_Sys
  titleText?: Maybe<Scalars['String']>
}

export type Vs_HighlightedTextSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_HighlightedTextSectionSubtitleTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightedTextSectionTitleTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HighlightedTextSectionLinkingCollections = {
  __typename?: 'vs_HighlightedTextSectionLinkingCollections'
  egRpvPageCollection?: Maybe<Vs_EgRpvPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_HighlightedTextSectionLinkingCollectionsEgRpvPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HighlightedTextSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HomePage = Vs_Entry & {
  __typename?: 'vs_HomePage'
  contentfulMetadata: Vs_ContentfulMetadata
  hero?: Maybe<Vs_Heroes>
  linkedFrom?: Maybe<Vs_HomePageLinkingCollections>
  ogType?: Maybe<Scalars['String']>
  productPanelsCollection?: Maybe<Vs_HomePageProductPanelsCollection>
  quoteSection?: Maybe<Vs_QuoteSection>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  socialBanner?: Maybe<Vs_Banner>
  storySection?: Maybe<Vs_StorySection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  videoSection?: Maybe<Vs_VideoSection>
}

export type Vs_HomePageHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HomePageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_HomePageOgTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HomePageProductPanelsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HomePageQuoteSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HomePageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HomePageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HomePageSocialBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HomePageStorySectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HomePageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_HomePageVideoSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_HomePageCollection = {
  __typename?: 'vs_HomePageCollection'
  items: Array<Maybe<Vs_HomePage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_HomePageLinkingCollections = {
  __typename?: 'vs_HomePageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_HomePageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_HomePageProductPanelsCollection = {
  __typename?: 'vs_HomePageProductPanelsCollection'
  items: Array<Maybe<Vs_Panel>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export enum Vs_ImageFormat {
  Jpg = 'JPG',
  JpgProgressive = 'JPG_PROGRESSIVE',
  Png = 'PNG',
  Png8 = 'PNG8',
  Webp = 'WEBP'
}

export enum Vs_ImageResizeFocus {
  Bottom = 'BOTTOM',
  BottomLeft = 'BOTTOM_LEFT',
  BottomRight = 'BOTTOM_RIGHT',
  Center = 'CENTER',
  Face = 'FACE',
  Faces = 'FACES',
  Left = 'LEFT',
  Right = 'RIGHT',
  Top = 'TOP',
  TopLeft = 'TOP_LEFT',
  TopRight = 'TOP_RIGHT'
}

export enum Vs_ImageResizeStrategy {
  Crop = 'CROP',
  Fill = 'FILL',
  Fit = 'FIT',
  Pad = 'PAD',
  Scale = 'SCALE',
  Thumb = 'THUMB'
}

export type Vs_ImageTransformOptions = {
  cornerRadius?: InputMaybe<Scalars['Int']>
  format?: InputMaybe<Vs_ImageFormat>
  resizeFocus?: InputMaybe<Vs_ImageResizeFocus>
  resizeStrategy?: InputMaybe<Vs_ImageResizeStrategy>
}

export type Vs_InstagramPost = Vs_Entry & {
  __typename?: 'vs_InstagramPost'
  caption?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  instagramId?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_InstagramPostLinkingCollections>
  mediaType?: Maybe<Scalars['String']>
  mediaUrl?: Maybe<Scalars['String']>
  permalink?: Maybe<Scalars['String']>
  sys: Vs_Sys
  thumbnailUrl?: Maybe<Scalars['String']>
  username?: Maybe<Scalars['String']>
}

export type Vs_InstagramPostCaptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_InstagramPostInstagramIdArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_InstagramPostLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_InstagramPostMediaTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_InstagramPostMediaUrlArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_InstagramPostPermalinkArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_InstagramPostThumbnailUrlArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_InstagramPostTimestampArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_InstagramPostUsernameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_InstagramPostLinkingCollections = {
  __typename?: 'vs_InstagramPostLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_InstagramPostLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Items = Vs_Entry & {
  __typename?: 'vs_Items'
  cfItemType?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  itemsCollection?: Maybe<Vs_ItemsItemsCollection>
  linkTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_ItemsLinkingCollections>
  media?: Maybe<Vs_Media>
  slug?: Maybe<Scalars['String']>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  text?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
  url?: Maybe<Scalars['String']>
}

export type Vs_ItemsCfItemTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ItemsItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ItemsLinkTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ItemsLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ItemsMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ItemsSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ItemsSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ItemsTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ItemsTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ItemsUrlArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ItemsCollection = {
  __typename?: 'vs_ItemsCollection'
  items: Array<Maybe<Vs_Items>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ItemsItemsCollection = {
  __typename?: 'vs_ItemsItemsCollection'
  items: Array<Maybe<Vs_Items>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ItemsLinkingCollections = {
  __typename?: 'vs_ItemsLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  itemsCollection?: Maybe<Vs_ItemsCollection>
  sectionCollection?: Maybe<Vs_SectionCollection>
}

export type Vs_ItemsLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ItemsLinkingCollectionsItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ItemsLinkingCollectionsSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Link = Vs_Entry & {
  __typename?: 'vs_Link'
  contentfulMetadata: Vs_ContentfulMetadata
  icon?: Maybe<Vs_Asset>
  linkHref?: Maybe<Scalars['String']>
  linkTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_LinkLinkingCollections>
  sys: Vs_Sys
  target?: Maybe<Scalars['Boolean']>
}

export type Vs_LinkIconArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_LinkLinkHrefArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_LinkLinkTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_LinkLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_LinkTargetArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_LinkCollection = {
  __typename?: 'vs_LinkCollection'
  items: Array<Maybe<Vs_Link>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_LinkLinkingCollections = {
  __typename?: 'vs_LinkLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_LinkLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Location = {
  __typename?: 'vs_Location'
  lat?: Maybe<Scalars['Float']>
  lon?: Maybe<Scalars['Float']>
}

export type Vs_LocationsSection = Vs_Entry & {
  __typename?: 'vs_LocationsSection'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_LocationsSectionLinkingCollections>
  locationsCollection?: Maybe<Vs_LocationsSectionLocationsCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_LocationsSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_LocationsSectionLocationsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_LocationsSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_LocationsSectionCollection = {
  __typename?: 'vs_LocationsSectionCollection'
  items: Array<Maybe<Vs_LocationsSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_LocationsSectionLinkingCollections = {
  __typename?: 'vs_LocationsSectionLinkingCollections'
  aboutPageCollection?: Maybe<Vs_AboutPageCollection>
  careersPageCollection?: Maybe<Vs_CareersPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_LocationsSectionLinkingCollectionsAboutPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_LocationsSectionLinkingCollectionsCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_LocationsSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_LocationsSectionLocationsCollection = {
  __typename?: 'vs_LocationsSectionLocationsCollection'
  items: Array<Maybe<Vs_ContentTypeLocation>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_MarkdownContentType = Vs_Entry & {
  __typename?: 'vs_MarkdownContentType'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_MarkdownContentTypeLinkingCollections>
  longText?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_MarkdownContentTypeLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_MarkdownContentTypeLongTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MarkdownContentTypeLinkingCollections = {
  __typename?: 'vs_MarkdownContentTypeLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_MarkdownContentTypeLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Media = Vs_Entry & {
  __typename?: 'vs_Media'
  contentfulMetadata: Vs_ContentfulMetadata
  desktopImage?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_MediaLinkingCollections>
  mobileImage?: Maybe<Vs_Asset>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  video?: Maybe<Vs_Asset>
}

export type Vs_MediaDesktopImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_MediaLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_MediaMobileImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_MediaTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MediaVideoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_MediaCollection = {
  __typename?: 'vs_MediaCollection'
  items: Array<Maybe<Vs_Media>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_MediaLinkingCollections = {
  __typename?: 'vs_MediaLinkingCollections'
  bannerCollection?: Maybe<Vs_BannerCollection>
  egCarouselSlideCollection?: Maybe<Vs_EgCarouselSlideCollection>
  egEditorialStorySectionCollection?: Maybe<Vs_EgEditorialStorySectionCollection>
  egErrorPageCollection?: Maybe<Vs_EgErrorPageCollection>
  egProductBuildBannerCollection?: Maybe<Vs_EgProductBuildBannerCollection>
  egProductStoryHeroCollection?: Maybe<Vs_EgProductStoryHeroCollection>
  egRpvAccordionBlockCollection?: Maybe<Vs_EgRpvAccordionBlockCollection>
  egRpvStoryHeroCollection?: Maybe<Vs_EgRpvStoryHeroCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  errorPageCollection?: Maybe<Vs_ErrorPageCollection>
  heroesCollection?: Maybe<Vs_HeroesCollection>
  highlightBlockCollection?: Maybe<Vs_HighlightBlockCollection>
  highlightSectionCollection?: Maybe<Vs_HighlightSectionCollection>
  itemsCollection?: Maybe<Vs_ItemsCollection>
  panelCollection?: Maybe<Vs_PanelCollection>
  slideGalleryCollection?: Maybe<Vs_SlideGalleryCollection>
  storyCollection?: Maybe<Vs_StoryCollection>
  storySectionCollection?: Maybe<Vs_StorySectionCollection>
  thankYouPageCollection?: Maybe<Vs_ThankYouPageCollection>
}

export type Vs_MediaLinkingCollectionsBannerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsEgCarouselSlideCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsEgEditorialStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsEgErrorPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsEgProductBuildBannerCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsEgProductStoryHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsEgRpvAccordionBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsEgRpvStoryHeroCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsErrorPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsHeroesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsHighlightBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsHighlightSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsPanelCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsSlideGalleryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsStoryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsStorySectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MediaLinkingCollectionsThankYouPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MigrationVersion = Vs_Entry & {
  __typename?: 'vs_MigrationVersion'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_MigrationVersionLinkingCollections>
  sys: Vs_Sys
  teamName?: Maybe<Scalars['String']>
  teamPrefix?: Maybe<Scalars['String']>
  version?: Maybe<Scalars['String']>
}

export type Vs_MigrationVersionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_MigrationVersionTeamNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MigrationVersionTeamPrefixArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MigrationVersionVersionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MigrationVersionLinkingCollections = {
  __typename?: 'vs_MigrationVersionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_MigrationVersionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MigrationsRan = Vs_Entry & {
  __typename?: 'vs_MigrationsRan'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_MigrationsRanLinkingCollections>
  name?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_MigrationsRanLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_MigrationsRanNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MigrationsRanLinkingCollections = {
  __typename?: 'vs_MigrationsRanLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_MigrationsRanLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_MigrationsRanLog = Vs_Entry & {
  __typename?: 'vs_MigrationsRanLog'
  contentfulMetadata: Vs_ContentfulMetadata
  gitlabPipelineUrl?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_MigrationsRanLogLinkingCollections>
  name?: Maybe<Scalars['String']>
  sys: Vs_Sys
  teamName?: Maybe<Scalars['String']>
  teamPrefix?: Maybe<Scalars['String']>
  version?: Maybe<Scalars['String']>
}

export type Vs_MigrationsRanLogGitlabPipelineUrlArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MigrationsRanLogLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_MigrationsRanLogNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MigrationsRanLogRanAtArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MigrationsRanLogTeamNameArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MigrationsRanLogTeamPrefixArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MigrationsRanLogVersionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_MigrationsRanLogLinkingCollections = {
  __typename?: 'vs_MigrationsRanLogLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_MigrationsRanLogLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Newsletter = Vs_Entry & {
  __typename?: 'vs_Newsletter'
  contentfulMetadata: Vs_ContentfulMetadata
  emailFieldError?: Maybe<Scalars['String']>
  emailFieldLabel?: Maybe<Scalars['String']>
  emailFieldPlaceholder?: Maybe<Scalars['String']>
  emailFieldSubmissionError?: Maybe<Scalars['String']>
  heading?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_NewsletterLinkingCollections>
  subHeading?: Maybe<Scalars['String']>
  successMessage?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_NewsletterEmailFieldErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterEmailFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterEmailFieldPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterEmailFieldSubmissionErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterHeadingArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_NewsletterSubHeadingArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterSuccessMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterCtaSection = Vs_Entry & {
  __typename?: 'vs_NewsletterCtaSection'
  contentfulMetadata: Vs_ContentfulMetadata
  emailFieldErrorEmpty?: Maybe<Scalars['String']>
  emailFieldLabel?: Maybe<Scalars['String']>
  emailFieldPlaceholder?: Maybe<Scalars['String']>
  heading?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_NewsletterCtaSectionLinkingCollections>
  subHeading?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_NewsletterCtaSectionEmailFieldErrorEmptyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterCtaSectionEmailFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterCtaSectionEmailFieldPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterCtaSectionHeadingArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterCtaSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_NewsletterCtaSectionSubHeadingArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NewsletterCtaSectionLinkingCollections = {
  __typename?: 'vs_NewsletterCtaSectionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  pagesCollection?: Maybe<Vs_PagesCollection>
}

export type Vs_NewsletterCtaSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_NewsletterCtaSectionLinkingCollectionsPagesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_NewsletterLinkingCollections = {
  __typename?: 'vs_NewsletterLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_NewsletterLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_NtfyMedia = Vs_Entry & {
  __typename?: 'vs_NtfyMedia'
  alt?: Maybe<Scalars['String']>
  asset?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_NtfyMediaLinkingCollections>
  sys: Vs_Sys
}

export type Vs_NtfyMediaAltArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NtfyMediaAssetArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_NtfyMediaEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NtfyMediaLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_NtfyMediaCollection = {
  __typename?: 'vs_NtfyMediaCollection'
  items: Array<Maybe<Vs_NtfyMedia>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_NtfyMediaLinkingCollections = {
  __typename?: 'vs_NtfyMediaLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  ntfyTemplateCollection?: Maybe<Vs_NtfyTemplateCollection>
}

export type Vs_NtfyMediaLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_NtfyMediaLinkingCollectionsNtfyTemplateCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_NtfyString = Vs_Entry & {
  __typename?: 'vs_NtfyString'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_NtfyStringLinkingCollections>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_NtfyStringEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NtfyStringKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NtfyStringLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_NtfyStringValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NtfyStringLinkingCollections = {
  __typename?: 'vs_NtfyStringLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  ntfyTemplateCollection?: Maybe<Vs_NtfyTemplateCollection>
}

export type Vs_NtfyStringLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_NtfyStringLinkingCollectionsNtfyTemplateCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_NtfyTemplate = Vs_Entry & {
  __typename?: 'vs_NtfyTemplate'
  contentfulMetadata: Vs_ContentfulMetadata
  emailImagesCollection?: Maybe<Vs_NtfyTemplateEmailImagesCollection>
  emailStringsCollection?: Maybe<Vs_NtfyTemplateEmailStringsCollection>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_NtfyTemplateLinkingCollections>
  push?: Maybe<Scalars['String']>
  slug?: Maybe<Scalars['String']>
  sms?: Maybe<Scalars['String']>
  source?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_NtfyTemplateEmailImagesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_NtfyTemplateEmailStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_NtfyTemplateEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NtfyTemplateLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_NtfyTemplatePushArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NtfyTemplateSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NtfyTemplateSmsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NtfyTemplateSourceArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_NtfyTemplateCollection = {
  __typename?: 'vs_NtfyTemplateCollection'
  items: Array<Maybe<Vs_NtfyTemplate>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_NtfyTemplateEmailImagesCollection = {
  __typename?: 'vs_NtfyTemplateEmailImagesCollection'
  items: Array<Maybe<Vs_NtfyMedia>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_NtfyTemplateEmailStringsCollection = {
  __typename?: 'vs_NtfyTemplateEmailStringsCollection'
  items: Array<Maybe<Vs_NtfyString>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_NtfyTemplateLinkingCollections = {
  __typename?: 'vs_NtfyTemplateLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_NtfyTemplateLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderAccountExploreSection = Vs_Entry & {
  __typename?: 'vs_OrderAccountExploreSection'
  cardsCollection?: Maybe<Vs_OrderAccountExploreSectionCardsCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderAccountExploreSectionLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderAccountExploreSectionCardsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderAccountExploreSectionDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderAccountExploreSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderAccountExploreSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderAccountExploreSectionCardsCollection = {
  __typename?: 'vs_OrderAccountExploreSectionCardsCollection'
  items: Array<Maybe<Vs_OrderAccountPageCard>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderAccountExploreSectionCollection = {
  __typename?: 'vs_OrderAccountExploreSectionCollection'
  items: Array<Maybe<Vs_OrderAccountExploreSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderAccountExploreSectionLinkingCollections = {
  __typename?: 'vs_OrderAccountExploreSectionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderAccountPageCollection?: Maybe<Vs_OrderAccountPageCollection>
}

export type Vs_OrderAccountExploreSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderAccountExploreSectionLinkingCollectionsOrderAccountPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderAccountPage = Vs_Entry & {
  __typename?: 'vs_OrderAccountPage'
  configurationSection?: Maybe<Vs_OrderAccountPageSection>
  contentfulMetadata: Vs_ContentfulMetadata
  exploreSection?: Maybe<Vs_OrderAccountExploreSection>
  gearSection?: Maybe<Vs_OrderAccountPageSection>
  linkedFrom?: Maybe<Vs_OrderAccountPageLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  videoSectionsCollection?: Maybe<Vs_OrderAccountPageVideoSectionsCollection>
}

export type Vs_OrderAccountPageConfigurationSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderAccountPageExploreSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderAccountPageGearSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderAccountPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderAccountPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderAccountPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderAccountPageVideoSectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderAccountPageCard = Vs_Entry & {
  __typename?: 'vs_OrderAccountPageCard'
  asset?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  ctaLink?: Maybe<Vs_OrderLink>
  linkedFrom?: Maybe<Vs_OrderAccountPageCardLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderAccountPageCardAssetArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderAccountPageCardCtaLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderAccountPageCardLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderAccountPageCardTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderAccountPageCardCollection = {
  __typename?: 'vs_OrderAccountPageCardCollection'
  items: Array<Maybe<Vs_OrderAccountPageCard>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderAccountPageCardLinkingCollections = {
  __typename?: 'vs_OrderAccountPageCardLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderAccountExploreSectionCollection?: Maybe<Vs_OrderAccountExploreSectionCollection>
}

export type Vs_OrderAccountPageCardLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderAccountPageCardLinkingCollectionsOrderAccountExploreSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderAccountPageCollection = {
  __typename?: 'vs_OrderAccountPageCollection'
  items: Array<Maybe<Vs_OrderAccountPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderAccountPageLinkingCollections = {
  __typename?: 'vs_OrderAccountPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_OrderAccountPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderAccountPageSection = Vs_Entry & {
  __typename?: 'vs_OrderAccountPageSection'
  asset?: Maybe<Vs_Asset>
  background?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  ctaLink?: Maybe<Vs_OrderLink>
  description?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderAccountPageSectionLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderAccountPageSectionAssetArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderAccountPageSectionBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderAccountPageSectionCtaLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderAccountPageSectionDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderAccountPageSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderAccountPageSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderAccountPageSectionCollection = {
  __typename?: 'vs_OrderAccountPageSectionCollection'
  items: Array<Maybe<Vs_OrderAccountPageSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderAccountPageSectionLinkingCollections = {
  __typename?: 'vs_OrderAccountPageSectionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderAccountPageCollection?: Maybe<Vs_OrderAccountPageCollection>
}

export type Vs_OrderAccountPageSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderAccountPageSectionLinkingCollectionsOrderAccountPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderAccountPageVideoSectionsCollection = {
  __typename?: 'vs_OrderAccountPageVideoSectionsCollection'
  items: Array<Maybe<Vs_OrderVideo>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderApplication = Vs_Entry & {
  __typename?: 'vs_OrderApplication'
  contentfulMetadata: Vs_ContentfulMetadata
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderApplicationLinkingCollections>
  sys: Vs_Sys
  valueCollection?: Maybe<Vs_OrderApplicationValueCollection>
}

export type Vs_OrderApplicationKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderApplicationLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderApplicationValueCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderApplicationLinkingCollections = {
  __typename?: 'vs_OrderApplicationLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_OrderApplicationLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderApplicationValueCollection = {
  __typename?: 'vs_OrderApplicationValueCollection'
  items: Array<Maybe<Vs_Entry>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessoryCardBlock = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessoryCardBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_OrderConfigAccessoryCardBlockDescription>
  entryTitle?: Maybe<Scalars['String']>
  linkRef?: Maybe<Scalars['String']>
  linkText?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessoryCardBlockLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryCardBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryCardBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryCardBlockLinkRefArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryCardBlockLinkTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryCardBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessoryCardBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryCardBlockDescription = {
  __typename?: 'vs_OrderConfigAccessoryCardBlockDescription'
  links: Vs_OrderConfigAccessoryCardBlockDescriptionLinks
}

export type Vs_OrderConfigAccessoryCardBlockDescriptionAssets = {
  __typename?: 'vs_OrderConfigAccessoryCardBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_OrderConfigAccessoryCardBlockDescriptionEntries = {
  __typename?: 'vs_OrderConfigAccessoryCardBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_OrderConfigAccessoryCardBlockDescriptionLinks = {
  __typename?: 'vs_OrderConfigAccessoryCardBlockDescriptionLinks'
  assets: Vs_OrderConfigAccessoryCardBlockDescriptionAssets
  entries: Vs_OrderConfigAccessoryCardBlockDescriptionEntries
}

export type Vs_OrderConfigAccessoryCardBlockLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessoryCardBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryPageCollection?: Maybe<Vs_OrderConfigAccessoryPageCollection>
}

export type Vs_OrderConfigAccessoryCardBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryCardBlockLinkingCollectionsOrderConfigAccessoryPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryHeadingBlock = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessoryHeadingBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessoryHeadingBlockLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryHeadingBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryHeadingBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessoryHeadingBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryHeadingBlockLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessoryHeadingBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryPageCollection?: Maybe<Vs_OrderConfigAccessoryPageCollection>
}

export type Vs_OrderConfigAccessoryHeadingBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryHeadingBlockLinkingCollectionsOrderConfigAccessoryPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryHeroBlock = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessoryHeroBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_OrderConfigAccessoryHeroBlockDescription>
  entryTitle?: Maybe<Scalars['String']>
  image?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_OrderConfigAccessoryHeroBlockLinkingCollections>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryHeroBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryHeroBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryHeroBlockImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderConfigAccessoryHeroBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessoryHeroBlockSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryHeroBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryHeroBlockCollection = {
  __typename?: 'vs_OrderConfigAccessoryHeroBlockCollection'
  items: Array<Maybe<Vs_OrderConfigAccessoryHeroBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessoryHeroBlockDescription = {
  __typename?: 'vs_OrderConfigAccessoryHeroBlockDescription'
  links: Vs_OrderConfigAccessoryHeroBlockDescriptionLinks
}

export type Vs_OrderConfigAccessoryHeroBlockDescriptionAssets = {
  __typename?: 'vs_OrderConfigAccessoryHeroBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_OrderConfigAccessoryHeroBlockDescriptionEntries = {
  __typename?: 'vs_OrderConfigAccessoryHeroBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_OrderConfigAccessoryHeroBlockDescriptionLinks = {
  __typename?: 'vs_OrderConfigAccessoryHeroBlockDescriptionLinks'
  assets: Vs_OrderConfigAccessoryHeroBlockDescriptionAssets
  entries: Vs_OrderConfigAccessoryHeroBlockDescriptionEntries
}

export type Vs_OrderConfigAccessoryHeroBlockLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessoryHeroBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryPageCollection?: Maybe<Vs_OrderConfigAccessoryPageCollection>
}

export type Vs_OrderConfigAccessoryHeroBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryHeroBlockLinkingCollectionsOrderConfigAccessoryPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryImageBlock = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessoryImageBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_OrderConfigAccessoryImageBlockDescription>
  entryTitle?: Maybe<Scalars['String']>
  imagesCollection?: Maybe<Vs_AssetCollection>
  linkedFrom?: Maybe<Vs_OrderConfigAccessoryImageBlockLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryImageBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryImageBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryImageBlockImagesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryImageBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessoryImageBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryImageBlockCollection = {
  __typename?: 'vs_OrderConfigAccessoryImageBlockCollection'
  items: Array<Maybe<Vs_OrderConfigAccessoryImageBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessoryImageBlockDescription = {
  __typename?: 'vs_OrderConfigAccessoryImageBlockDescription'
  links: Vs_OrderConfigAccessoryImageBlockDescriptionLinks
}

export type Vs_OrderConfigAccessoryImageBlockDescriptionAssets = {
  __typename?: 'vs_OrderConfigAccessoryImageBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_OrderConfigAccessoryImageBlockDescriptionEntries = {
  __typename?: 'vs_OrderConfigAccessoryImageBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_OrderConfigAccessoryImageBlockDescriptionLinks = {
  __typename?: 'vs_OrderConfigAccessoryImageBlockDescriptionLinks'
  assets: Vs_OrderConfigAccessoryImageBlockDescriptionAssets
  entries: Vs_OrderConfigAccessoryImageBlockDescriptionEntries
}

export type Vs_OrderConfigAccessoryImageBlockLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessoryImageBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryPageCollection?: Maybe<Vs_OrderConfigAccessoryPageCollection>
}

export type Vs_OrderConfigAccessoryImageBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryImageBlockLinkingCollectionsOrderConfigAccessoryPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryListBlock = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessoryListBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessoryListBlockLinkingCollections>
  listsCollection?: Maybe<Vs_OrderConfigAccessoryListBlockListsCollection>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryListBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryListBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessoryListBlockListsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryListBlockSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryListBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryListBlockCollection = {
  __typename?: 'vs_OrderConfigAccessoryListBlockCollection'
  items: Array<Maybe<Vs_OrderConfigAccessoryListBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessoryListBlockLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessoryListBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryPageCollection?: Maybe<Vs_OrderConfigAccessoryPageCollection>
}

export type Vs_OrderConfigAccessoryListBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryListBlockLinkingCollectionsOrderConfigAccessoryPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryListBlockListsCollection = {
  __typename?: 'vs_OrderConfigAccessoryListBlockListsCollection'
  items: Array<Maybe<Vs_OrderConfigAccessoryListEntry>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessoryListEntry = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessoryListEntry'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessoryListEntryLinkingCollections>
  list?: Maybe<Array<Maybe<Scalars['String']>>>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryListEntryEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryListEntryLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessoryListEntryListArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryListEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryListEntryLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessoryListEntryLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryListBlockCollection?: Maybe<Vs_OrderConfigAccessoryListBlockCollection>
}

export type Vs_OrderConfigAccessoryListEntryLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryListEntryLinkingCollectionsOrderConfigAccessoryListBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryPage = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessoryPage'
  blocksCollection?: Maybe<Vs_OrderConfigAccessoryPageBlocksCollection>
  compatibleVehicles?: Maybe<Array<Maybe<Scalars['String']>>>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessoryPageLinkingCollections>
  skus?: Maybe<Array<Maybe<Scalars['String']>>>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryPageBlocksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryPageCompatibleVehiclesArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryPageKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessoryPageSkusArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryPageBlocksCollection = {
  __typename?: 'vs_OrderConfigAccessoryPageBlocksCollection'
  items: Array<Maybe<Vs_OrderConfigAccessoryPageBlocksItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessoryPageBlocksItem =
  | Vs_OrderConfigAccessoryCardBlock
  | Vs_OrderConfigAccessoryHeadingBlock
  | Vs_OrderConfigAccessoryHeroBlock
  | Vs_OrderConfigAccessoryImageBlock
  | Vs_OrderConfigAccessoryListBlock
  | Vs_OrderConfigAccessoryQuestionsBlock
  | Vs_OrderConfigAccessorySpecsBlock
  | Vs_OrderConfigAccessorySubscribeBlock
  | Vs_OrderConfigAccessoryTextBlock

export type Vs_OrderConfigAccessoryPageCollection = {
  __typename?: 'vs_OrderConfigAccessoryPageCollection'
  items: Array<Maybe<Vs_OrderConfigAccessoryPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessoryPageLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessoryPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_OrderConfigAccessoryPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryQuestionEntry = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessoryQuestionEntry'
  answer?: Maybe<Vs_OrderConfigAccessoryQuestionEntryAnswer>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessoryQuestionEntryLinkingCollections>
  question?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_OrderConfigAccessoryQuestionEntryAnswerArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryQuestionEntryEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryQuestionEntryLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessoryQuestionEntryQuestionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryQuestionEntryAnswer = {
  __typename?: 'vs_OrderConfigAccessoryQuestionEntryAnswer'
  links: Vs_OrderConfigAccessoryQuestionEntryAnswerLinks
}

export type Vs_OrderConfigAccessoryQuestionEntryAnswerAssets = {
  __typename?: 'vs_OrderConfigAccessoryQuestionEntryAnswerAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_OrderConfigAccessoryQuestionEntryAnswerEntries = {
  __typename?: 'vs_OrderConfigAccessoryQuestionEntryAnswerEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_OrderConfigAccessoryQuestionEntryAnswerLinks = {
  __typename?: 'vs_OrderConfigAccessoryQuestionEntryAnswerLinks'
  assets: Vs_OrderConfigAccessoryQuestionEntryAnswerAssets
  entries: Vs_OrderConfigAccessoryQuestionEntryAnswerEntries
}

export type Vs_OrderConfigAccessoryQuestionEntryLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessoryQuestionEntryLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryQuestionsBlockCollection?: Maybe<Vs_OrderConfigAccessoryQuestionsBlockCollection>
}

export type Vs_OrderConfigAccessoryQuestionEntryLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryQuestionEntryLinkingCollectionsOrderConfigAccessoryQuestionsBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryQuestionsBlock = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessoryQuestionsBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessoryQuestionsBlockLinkingCollections>
  questionListCollection?: Maybe<Vs_OrderConfigAccessoryQuestionsBlockQuestionListCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryQuestionsBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryQuestionsBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessoryQuestionsBlockQuestionListCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryQuestionsBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryQuestionsBlockCollection = {
  __typename?: 'vs_OrderConfigAccessoryQuestionsBlockCollection'
  items: Array<Maybe<Vs_OrderConfigAccessoryQuestionsBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessoryQuestionsBlockLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessoryQuestionsBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryPageCollection?: Maybe<Vs_OrderConfigAccessoryPageCollection>
}

export type Vs_OrderConfigAccessoryQuestionsBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryQuestionsBlockLinkingCollectionsOrderConfigAccessoryPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryQuestionsBlockQuestionListCollection = {
  __typename?: 'vs_OrderConfigAccessoryQuestionsBlockQuestionListCollection'
  items: Array<Maybe<Vs_OrderConfigAccessoryQuestionEntry>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessorySpecEntry = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessorySpecEntry'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_OrderConfigAccessorySpecEntryDescription>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessorySpecEntryLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySpecEntryDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySpecEntryEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySpecEntryLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessorySpecEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySpecEntryDescription = {
  __typename?: 'vs_OrderConfigAccessorySpecEntryDescription'
  links: Vs_OrderConfigAccessorySpecEntryDescriptionLinks
}

export type Vs_OrderConfigAccessorySpecEntryDescriptionAssets = {
  __typename?: 'vs_OrderConfigAccessorySpecEntryDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_OrderConfigAccessorySpecEntryDescriptionEntries = {
  __typename?: 'vs_OrderConfigAccessorySpecEntryDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_OrderConfigAccessorySpecEntryDescriptionLinks = {
  __typename?: 'vs_OrderConfigAccessorySpecEntryDescriptionLinks'
  assets: Vs_OrderConfigAccessorySpecEntryDescriptionAssets
  entries: Vs_OrderConfigAccessorySpecEntryDescriptionEntries
}

export type Vs_OrderConfigAccessorySpecEntryLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessorySpecEntryLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessorySpecsBlockCollection?: Maybe<Vs_OrderConfigAccessorySpecsBlockCollection>
}

export type Vs_OrderConfigAccessorySpecEntryLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessorySpecEntryLinkingCollectionsOrderConfigAccessorySpecsBlockCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessorySpecsBlock = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessorySpecsBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessorySpecsBlockLinkingCollections>
  specListCollection?: Maybe<Vs_OrderConfigAccessorySpecsBlockSpecListCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySpecsBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySpecsBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessorySpecsBlockSpecListCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessorySpecsBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySpecsBlockCollection = {
  __typename?: 'vs_OrderConfigAccessorySpecsBlockCollection'
  items: Array<Maybe<Vs_OrderConfigAccessorySpecsBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessorySpecsBlockLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessorySpecsBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryPageCollection?: Maybe<Vs_OrderConfigAccessoryPageCollection>
}

export type Vs_OrderConfigAccessorySpecsBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessorySpecsBlockLinkingCollectionsOrderConfigAccessoryPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessorySpecsBlockSpecListCollection = {
  __typename?: 'vs_OrderConfigAccessorySpecsBlockSpecListCollection'
  items: Array<Maybe<Vs_OrderConfigAccessorySpecEntry>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderConfigAccessorySubscribeBlock = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessorySubscribeBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_OrderConfigAccessorySubscribeBlockDescription>
  entryTitle?: Maybe<Scalars['String']>
  inputInvalidEmailMsg?: Maybe<Scalars['String']>
  inputLabel?: Maybe<Scalars['String']>
  inputSubmitErrorMsg?: Maybe<Scalars['String']>
  inputSubmitSuccessMsg?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessorySubscribeBlockLinkingCollections>
  subjects?: Maybe<Array<Maybe<Scalars['String']>>>
  submitButtonLabel?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySubscribeBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySubscribeBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySubscribeBlockInputInvalidEmailMsgArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySubscribeBlockInputLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySubscribeBlockInputSubmitErrorMsgArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySubscribeBlockInputSubmitSuccessMsgArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySubscribeBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessorySubscribeBlockSubjectsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySubscribeBlockSubmitButtonLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySubscribeBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessorySubscribeBlockDescription = {
  __typename?: 'vs_OrderConfigAccessorySubscribeBlockDescription'
  links: Vs_OrderConfigAccessorySubscribeBlockDescriptionLinks
}

export type Vs_OrderConfigAccessorySubscribeBlockDescriptionAssets = {
  __typename?: 'vs_OrderConfigAccessorySubscribeBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_OrderConfigAccessorySubscribeBlockDescriptionEntries = {
  __typename?: 'vs_OrderConfigAccessorySubscribeBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_OrderConfigAccessorySubscribeBlockDescriptionLinks = {
  __typename?: 'vs_OrderConfigAccessorySubscribeBlockDescriptionLinks'
  assets: Vs_OrderConfigAccessorySubscribeBlockDescriptionAssets
  entries: Vs_OrderConfigAccessorySubscribeBlockDescriptionEntries
}

export type Vs_OrderConfigAccessorySubscribeBlockLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessorySubscribeBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryPageCollection?: Maybe<Vs_OrderConfigAccessoryPageCollection>
}

export type Vs_OrderConfigAccessorySubscribeBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessorySubscribeBlockLinkingCollectionsOrderConfigAccessoryPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryTextBlock = Vs_Entry & {
  __typename?: 'vs_OrderConfigAccessoryTextBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_OrderConfigAccessoryTextBlockDescription>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderConfigAccessoryTextBlockLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryTextBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryTextBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryTextBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderConfigAccessoryTextBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderConfigAccessoryTextBlockDescription = {
  __typename?: 'vs_OrderConfigAccessoryTextBlockDescription'
  links: Vs_OrderConfigAccessoryTextBlockDescriptionLinks
}

export type Vs_OrderConfigAccessoryTextBlockDescriptionAssets = {
  __typename?: 'vs_OrderConfigAccessoryTextBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_OrderConfigAccessoryTextBlockDescriptionEntries = {
  __typename?: 'vs_OrderConfigAccessoryTextBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_OrderConfigAccessoryTextBlockDescriptionLinks = {
  __typename?: 'vs_OrderConfigAccessoryTextBlockDescriptionLinks'
  assets: Vs_OrderConfigAccessoryTextBlockDescriptionAssets
  entries: Vs_OrderConfigAccessoryTextBlockDescriptionEntries
}

export type Vs_OrderConfigAccessoryTextBlockLinkingCollections = {
  __typename?: 'vs_OrderConfigAccessoryTextBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderConfigAccessoryPageCollection?: Maybe<Vs_OrderConfigAccessoryPageCollection>
}

export type Vs_OrderConfigAccessoryTextBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderConfigAccessoryTextBlockLinkingCollectionsOrderConfigAccessoryPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderLink = Vs_Entry & {
  __typename?: 'vs_OrderLink'
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  icon?: Maybe<Vs_Asset>
  linkHref?: Maybe<Scalars['String']>
  linkTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderLinkLinkingCollections>
  sys: Vs_Sys
  target?: Maybe<Scalars['Boolean']>
}

export type Vs_OrderLinkEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderLinkIconArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderLinkLinkHrefArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderLinkLinkTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderLinkLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderLinkTargetArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderLinkCollection = {
  __typename?: 'vs_OrderLinkCollection'
  items: Array<Maybe<Vs_OrderLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderLinkLinkingCollections = {
  __typename?: 'vs_OrderLinkLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderAccountPageCardCollection?: Maybe<Vs_OrderAccountPageCardCollection>
  orderAccountPageSectionCollection?: Maybe<Vs_OrderAccountPageSectionCollection>
}

export type Vs_OrderLinkLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderLinkLinkingCollectionsOrderAccountPageCardCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderLinkLinkingCollectionsOrderAccountPageSectionCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderMedia = Vs_Entry & {
  __typename?: 'vs_OrderMedia'
  contentfulMetadata: Vs_ContentfulMetadata
  desktopImage?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_OrderMediaLinkingCollections>
  mobileImage?: Maybe<Vs_Asset>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  video?: Maybe<Vs_Asset>
}

export type Vs_OrderMediaDesktopImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderMediaLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderMediaMobileImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderMediaTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderMediaVideoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderMediaCollection = {
  __typename?: 'vs_OrderMediaCollection'
  items: Array<Maybe<Vs_OrderMedia>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderMediaLinkingCollections = {
  __typename?: 'vs_OrderMediaLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderThankYouPageCollection?: Maybe<Vs_OrderThankYouPageCollection>
}

export type Vs_OrderMediaLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderMediaLinkingCollectionsOrderThankYouPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderTextBlock = Vs_Entry & {
  __typename?: 'vs_OrderTextBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_OrderTextBlockDescription>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderTextBlockLinkingCollections>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderTextBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderTextBlockEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderTextBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderTextBlockSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderTextBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderTextBlockDescription = {
  __typename?: 'vs_OrderTextBlockDescription'
  links: Vs_OrderTextBlockDescriptionLinks
}

export type Vs_OrderTextBlockDescriptionAssets = {
  __typename?: 'vs_OrderTextBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_OrderTextBlockDescriptionEntries = {
  __typename?: 'vs_OrderTextBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_OrderTextBlockDescriptionLinks = {
  __typename?: 'vs_OrderTextBlockDescriptionLinks'
  assets: Vs_OrderTextBlockDescriptionAssets
  entries: Vs_OrderTextBlockDescriptionEntries
}

export type Vs_OrderTextBlockLinkingCollections = {
  __typename?: 'vs_OrderTextBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderThankYouPageCollection?: Maybe<Vs_OrderThankYouPageCollection>
}

export type Vs_OrderTextBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderTextBlockLinkingCollectionsOrderThankYouPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderThankYouPage = Vs_Entry & {
  __typename?: 'vs_OrderThankYouPage'
  alternativeEmailLabel?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderThankYouPageLinkingCollections>
  media?: Maybe<Vs_OrderMedia>
  r1SMedia?: Maybe<Vs_OrderMedia>
  r1TMedia?: Maybe<Vs_OrderMedia>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  thankYouLabel?: Maybe<Scalars['String']>
  thankYouNotesCollection?: Maybe<Vs_OrderThankYouPageThankYouNotesCollection>
  title?: Maybe<Scalars['String']>
  video?: Maybe<Vs_OrderVideo>
}

export type Vs_OrderThankYouPageAlternativeEmailLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderThankYouPageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderThankYouPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderThankYouPageMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderThankYouPageR1SMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderThankYouPageR1TMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderThankYouPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderThankYouPageThankYouLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderThankYouPageThankYouNotesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderThankYouPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderThankYouPageVideoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderThankYouPageCollection = {
  __typename?: 'vs_OrderThankYouPageCollection'
  items: Array<Maybe<Vs_OrderThankYouPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderThankYouPageLinkingCollections = {
  __typename?: 'vs_OrderThankYouPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_OrderThankYouPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderThankYouPageThankYouNotesCollection = {
  __typename?: 'vs_OrderThankYouPageThankYouNotesCollection'
  items: Array<Maybe<Vs_OrderTextBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderUiElement = Vs_Entry & {
  __typename?: 'vs_OrderUiElement'
  asset?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderUiElementLinkingCollections>
  longTextValue?: Maybe<Scalars['String']>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_OrderUiElementAssetArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderUiElementKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderUiElementLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderUiElementLongTextValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderUiElementValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderUiElementCollection = {
  __typename?: 'vs_OrderUiElementCollection'
  items: Array<Maybe<Vs_OrderUiElement>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderUiElementLinkingCollections = {
  __typename?: 'vs_OrderUiElementLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderUiElementsGroupCollection?: Maybe<Vs_OrderUiElementsGroupCollection>
}

export type Vs_OrderUiElementLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderUiElementLinkingCollectionsOrderUiElementsGroupCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderUiElementsGroup = Vs_Entry & {
  __typename?: 'vs_OrderUiElementsGroup'
  contentfulMetadata: Vs_ContentfulMetadata
  elementsCollection?: Maybe<Vs_OrderUiElementsGroupElementsCollection>
  linkedFrom?: Maybe<Vs_OrderUiElementsGroupLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_OrderUiElementsGroupElementsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderUiElementsGroupLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderUiElementsGroupSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderUiElementsGroupTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderUiElementsGroupCollection = {
  __typename?: 'vs_OrderUiElementsGroupCollection'
  items: Array<Maybe<Vs_OrderUiElementsGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderUiElementsGroupElementsCollection = {
  __typename?: 'vs_OrderUiElementsGroupElementsCollection'
  items: Array<Maybe<Vs_OrderUiElement>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderUiElementsGroupLinkingCollections = {
  __typename?: 'vs_OrderUiElementsGroupLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderUiStringsCollection?: Maybe<Vs_OrderUiStringsCollection>
}

export type Vs_OrderUiElementsGroupLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderUiElementsGroupLinkingCollectionsOrderUiStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderUiStrings = Vs_Entry & {
  __typename?: 'vs_OrderUiStrings'
  contentfulMetadata: Vs_ContentfulMetadata
  elementGroupsCollection?: Maybe<Vs_OrderUiStringsElementGroupsCollection>
  linkedFrom?: Maybe<Vs_OrderUiStringsLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_OrderUiStringsElementGroupsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderUiStringsLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderUiStringsSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderUiStringsCollection = {
  __typename?: 'vs_OrderUiStringsCollection'
  items: Array<Maybe<Vs_OrderUiStrings>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderUiStringsElementGroupsCollection = {
  __typename?: 'vs_OrderUiStringsElementGroupsCollection'
  items: Array<Maybe<Vs_OrderUiElementsGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderUiStringsLinkingCollections = {
  __typename?: 'vs_OrderUiStringsLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_OrderUiStringsLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderVideo = Vs_Entry & {
  __typename?: 'vs_OrderVideo'
  autoplay?: Maybe<Scalars['Boolean']>
  contentfulMetadata: Vs_ContentfulMetadata
  coverImage?: Maybe<Vs_Asset>
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_OrderVideoLinkingCollections>
  loop?: Maybe<Scalars['Boolean']>
  mediaFile?: Maybe<Vs_Asset>
  mobileMediaFile?: Maybe<Vs_Asset>
  subtitle?: Maybe<Scalars['String']>
  supportMessage?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  videoLink?: Maybe<Scalars['String']>
}

export type Vs_OrderVideoAutoplayArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderVideoCoverImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderVideoEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderVideoLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_OrderVideoLoopArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderVideoMediaFileArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderVideoMobileMediaFileArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_OrderVideoSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderVideoSupportMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderVideoTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderVideoVideoLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_OrderVideoCollection = {
  __typename?: 'vs_OrderVideoCollection'
  items: Array<Maybe<Vs_OrderVideo>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_OrderVideoLinkingCollections = {
  __typename?: 'vs_OrderVideoLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  orderAccountPageCollection?: Maybe<Vs_OrderAccountPageCollection>
  orderThankYouPageCollection?: Maybe<Vs_OrderThankYouPageCollection>
}

export type Vs_OrderVideoLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderVideoLinkingCollectionsOrderAccountPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_OrderVideoLinkingCollectionsOrderThankYouPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Page = Vs_Entry & {
  __typename?: 'vs_Page'
  contentCollection?: Maybe<Vs_PageContentCollection>
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  keywords?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_PageLinkingCollections>
  ogImage?: Maybe<Vs_Asset>
  ogType?: Maybe<Scalars['String']>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_PageContentCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_PageDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PageEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PageKeywordsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_PageOgImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PageOgTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PageCollection = {
  __typename?: 'vs_PageCollection'
  items: Array<Maybe<Vs_Page>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_PageContentCollection = {
  __typename?: 'vs_PageContentCollection'
  items: Array<Maybe<Vs_Entry>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_PageLinkingCollections = {
  __typename?: 'vs_PageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_PageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Pages = Vs_Entry & {
  __typename?: 'vs_Pages'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  gallery?: Maybe<Vs_SlideGallery>
  hero?: Maybe<Vs_Heroes>
  keywords?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_PagesLinkingCollections>
  metaData?: Maybe<Vs_Entry>
  newsletterSection?: Maybe<Vs_NewsletterCtaSection>
  ogImage?: Maybe<Vs_Asset>
  ogType?: Maybe<Scalars['String']>
  sectionsCollection?: Maybe<Vs_PagesSectionsCollection>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_PagesDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PagesEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PagesGalleryArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PagesHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PagesKeywordsArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PagesLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_PagesMetaDataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PagesNewsletterSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PagesOgImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PagesOgTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PagesSectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_PagesSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PagesTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PagesCollection = {
  __typename?: 'vs_PagesCollection'
  items: Array<Maybe<Vs_Pages>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_PagesLinkingCollections = {
  __typename?: 'vs_PagesLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_PagesLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_PagesSectionsCollection = {
  __typename?: 'vs_PagesSectionsCollection'
  items: Array<Maybe<Vs_Section>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_Panel = Vs_Entry & {
  __typename?: 'vs_Panel'
  contentfulMetadata: Vs_ContentfulMetadata
  exploreLink?: Maybe<Vs_EgLink>
  linkedFrom?: Maybe<Vs_PanelLinkingCollections>
  media?: Maybe<Vs_Media>
  preorderLink?: Maybe<Vs_EgLink>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_PanelExploreLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PanelLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_PanelMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PanelPreorderLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PanelTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PanelCollection = {
  __typename?: 'vs_PanelCollection'
  items: Array<Maybe<Vs_Panel>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_PanelLinkingCollections = {
  __typename?: 'vs_PanelLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  homePageCollection?: Maybe<Vs_HomePageCollection>
  preorderPageCollection?: Maybe<Vs_PreorderPageCollection>
}

export type Vs_PanelLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_PanelLinkingCollectionsHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_PanelLinkingCollectionsPreorderPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_PreOrderCancellationEmail = Vs_Entry & {
  __typename?: 'vs_PreOrderCancellationEmail'
  bodyCopy?: Maybe<Vs_PreOrderCancellationEmailBodyCopy>
  contentfulMetadata: Vs_ContentfulMetadata
  footer?: Maybe<Vs_EmailFooter>
  linkedFrom?: Maybe<Vs_PreOrderCancellationEmailLinkingCollections>
  rivianLogo?: Maybe<Vs_Asset>
  subjectLine?: Maybe<Scalars['String']>
  sys: Vs_Sys
  templateCode?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
}

export type Vs_PreOrderCancellationEmailBodyCopyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PreOrderCancellationEmailFooterArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderCancellationEmailLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_PreOrderCancellationEmailRivianLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderCancellationEmailSubjectLineArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PreOrderCancellationEmailTemplateCodeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PreOrderCancellationEmailTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PreOrderCancellationEmailBodyCopy = {
  __typename?: 'vs_PreOrderCancellationEmailBodyCopy'
  links: Vs_PreOrderCancellationEmailBodyCopyLinks
}

export type Vs_PreOrderCancellationEmailBodyCopyAssets = {
  __typename?: 'vs_PreOrderCancellationEmailBodyCopyAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_PreOrderCancellationEmailBodyCopyEntries = {
  __typename?: 'vs_PreOrderCancellationEmailBodyCopyEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_PreOrderCancellationEmailBodyCopyLinks = {
  __typename?: 'vs_PreOrderCancellationEmailBodyCopyLinks'
  assets: Vs_PreOrderCancellationEmailBodyCopyAssets
  entries: Vs_PreOrderCancellationEmailBodyCopyEntries
}

export type Vs_PreOrderCancellationEmailCollection = {
  __typename?: 'vs_PreOrderCancellationEmailCollection'
  items: Array<Maybe<Vs_PreOrderCancellationEmail>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_PreOrderCancellationEmailLinkingCollections = {
  __typename?: 'vs_PreOrderCancellationEmailLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_PreOrderCancellationEmailLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_PreOrderConfirmationEmail = Vs_Entry & {
  __typename?: 'vs_PreOrderConfirmationEmail'
  ccAmex?: Maybe<Vs_Asset>
  ccDiners?: Maybe<Vs_Asset>
  ccDiscover?: Maybe<Vs_Asset>
  ccJcb?: Maybe<Vs_Asset>
  ccMastercard?: Maybe<Vs_Asset>
  ccUnionpay?: Maybe<Vs_Asset>
  ccVisa?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  facebookLogo?: Maybe<Vs_Asset>
  instagramLogo?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_PreOrderConfirmationEmailLinkingCollections>
  linkedinLogo?: Maybe<Vs_Asset>
  modelR1S?: Maybe<Vs_Asset>
  modelR1T?: Maybe<Vs_Asset>
  poster?: Maybe<Vs_Asset>
  rivianLogo?: Maybe<Vs_Asset>
  sys: Vs_Sys
  templateCode?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
  twitterLogo?: Maybe<Vs_Asset>
  youtubeLogo?: Maybe<Vs_Asset>
}

export type Vs_PreOrderConfirmationEmailCcAmexArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailCcDinersArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailCcDiscoverArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailCcJcbArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailCcMastercardArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailCcUnionpayArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailCcVisaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailFacebookLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailInstagramLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_PreOrderConfirmationEmailLinkedinLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailModelR1SArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailModelR1TArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailPosterArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailRivianLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailTemplateCodeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PreOrderConfirmationEmailTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PreOrderConfirmationEmailTwitterLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailYoutubeLogoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreOrderConfirmationEmailCollection = {
  __typename?: 'vs_PreOrderConfirmationEmailCollection'
  items: Array<Maybe<Vs_PreOrderConfirmationEmail>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_PreOrderConfirmationEmailLinkingCollections = {
  __typename?: 'vs_PreOrderConfirmationEmailLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_PreOrderConfirmationEmailLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_PreorderPage = Vs_Entry & {
  __typename?: 'vs_PreorderPage'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_PreorderPageLinkingCollections>
  panelsCollection?: Maybe<Vs_PreorderPagePanelsCollection>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_PreorderPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_PreorderPagePanelsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_PreorderPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_PreorderPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PreorderPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_PreorderPageCollection = {
  __typename?: 'vs_PreorderPageCollection'
  items: Array<Maybe<Vs_PreorderPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_PreorderPageLinkingCollections = {
  __typename?: 'vs_PreorderPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_PreorderPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_PreorderPagePanelsCollection = {
  __typename?: 'vs_PreorderPagePanelsCollection'
  items: Array<Maybe<Vs_Panel>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ProductPage = Vs_Entry & {
  __typename?: 'vs_ProductPage'
  contentfulMetadata: Vs_ContentfulMetadata
  featuresSection?: Maybe<Vs_FeaturesSection>
  gallery?: Maybe<Vs_SlideGallery>
  hero?: Maybe<Vs_Heroes>
  highlightsCollection?: Maybe<Vs_ProductPageHighlightsCollection>
  linkedFrom?: Maybe<Vs_ProductPageLinkingCollections>
  preorder?: Maybe<Vs_FeatureBanner>
  quote?: Maybe<Vs_FeatureBanner>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  specifications?: Maybe<Vs_Specifications>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  videoSection?: Maybe<Vs_EgVideo>
}

export type Vs_ProductPageFeaturesSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ProductPageGalleryArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ProductPageHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ProductPageHighlightsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ProductPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ProductPagePreorderArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ProductPageQuoteArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ProductPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ProductPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ProductPageSpecificationsArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ProductPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ProductPageVideoSectionArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ProductPageCollection = {
  __typename?: 'vs_ProductPageCollection'
  items: Array<Maybe<Vs_ProductPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ProductPageHighlightsCollection = {
  __typename?: 'vs_ProductPageHighlightsCollection'
  items: Array<Maybe<Vs_HighlightSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ProductPageLinkingCollections = {
  __typename?: 'vs_ProductPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_ProductPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Quote = Vs_Entry & {
  __typename?: 'vs_Quote'
  background?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_QuoteLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_QuoteBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_QuoteLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_QuoteTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_QuoteCollection = {
  __typename?: 'vs_QuoteCollection'
  items: Array<Maybe<Vs_Quote>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_QuoteLinkingCollections = {
  __typename?: 'vs_QuoteLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_QuoteLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_QuoteSection = Vs_Entry & {
  __typename?: 'vs_QuoteSection'
  background?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_QuoteSectionLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_QuoteSectionBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_QuoteSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_QuoteSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_QuoteSectionCollection = {
  __typename?: 'vs_QuoteSectionCollection'
  items: Array<Maybe<Vs_QuoteSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_QuoteSectionLinkingCollections = {
  __typename?: 'vs_QuoteSectionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  homePageCollection?: Maybe<Vs_HomePageCollection>
}

export type Vs_QuoteSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_QuoteSectionLinkingCollectionsHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ReferenceType = Vs_Entry & {
  __typename?: 'vs_ReferenceType'
  contentfulMetadata: Vs_ContentfulMetadata
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_ReferenceTypeLinkingCollections>
  sys: Vs_Sys
  valueCollection?: Maybe<Vs_ReferenceTypeValueCollection>
}

export type Vs_ReferenceTypeKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ReferenceTypeLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ReferenceTypeValueCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ReferenceTypeLinkingCollections = {
  __typename?: 'vs_ReferenceTypeLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_ReferenceTypeLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ReferenceTypeValueCollection = {
  __typename?: 'vs_ReferenceTypeValueCollection'
  items: Array<Maybe<Vs_Entry>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ResponsiveImage = Vs_Entry & {
  __typename?: 'vs_ResponsiveImage'
  contentfulMetadata: Vs_ContentfulMetadata
  image?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_ResponsiveImageLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_ResponsiveImageFocalPointArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ResponsiveImageImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ResponsiveImageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ResponsiveImageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ResponsiveImageCollection = {
  __typename?: 'vs_ResponsiveImageCollection'
  items: Array<Maybe<Vs_ResponsiveImage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ResponsiveImageLinkingCollections = {
  __typename?: 'vs_ResponsiveImageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_ResponsiveImageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_RivianIdHomePage = Vs_Entry & {
  __typename?: 'vs_RivianIdHomePage'
  banner?: Maybe<Vs_Banner>
  contentfulMetadata: Vs_ContentfulMetadata
  forgotPasswordLinkText?: Maybe<Scalars['String']>
  hero?: Maybe<Vs_Heroes>
  linkedFrom?: Maybe<Vs_RivianIdHomePageLinkingCollections>
  loginFormError?: Maybe<Scalars['String']>
  passwordEmptyError?: Maybe<Scalars['String']>
  passwordFieldLabel?: Maybe<Scalars['String']>
  serviceUnavailableErrorMessage?: Maybe<Scalars['String']>
  signInButtonText?: Maybe<Scalars['String']>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  usernameEmptyError?: Maybe<Scalars['String']>
  usernameFieldLabel?: Maybe<Scalars['String']>
  usernamePlaceholderText?: Maybe<Scalars['String']>
}

export type Vs_RivianIdHomePageBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_RivianIdHomePageForgotPasswordLinkTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePageHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_RivianIdHomePageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_RivianIdHomePageLoginFormErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePagePasswordEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePagePasswordFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePageServiceUnavailableErrorMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePageSignInButtonTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePageUsernameEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePageUsernameFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePageUsernamePlaceholderTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdHomePageCollection = {
  __typename?: 'vs_RivianIdHomePageCollection'
  items: Array<Maybe<Vs_RivianIdHomePage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_RivianIdHomePageLinkingCollections = {
  __typename?: 'vs_RivianIdHomePageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_RivianIdHomePageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_RivianIdProfilePage = Vs_Entry & {
  __typename?: 'vs_RivianIdProfilePage'
  banner?: Maybe<Vs_Banner>
  cityLabel?: Maybe<Scalars['String']>
  cityPlaceholder?: Maybe<Scalars['String']>
  companyLabel?: Maybe<Scalars['String']>
  companyPlaceholder?: Maybe<Scalars['String']>
  confirmPasswordLabel?: Maybe<Scalars['String']>
  confirmPasswordPlaceholder?: Maybe<Scalars['String']>
  confirmPinLabel?: Maybe<Scalars['String']>
  confirmPinPlaceholder?: Maybe<Scalars['String']>
  contentfulMetadata: Vs_ContentfulMetadata
  emailLabel?: Maybe<Scalars['String']>
  emailPlaceholder?: Maybe<Scalars['String']>
  firstNameLabel?: Maybe<Scalars['String']>
  firstNamePlaceholder?: Maybe<Scalars['String']>
  lastNameLabel?: Maybe<Scalars['String']>
  lastNamePlaceholder?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_RivianIdProfilePageLinkingCollections>
  matchingPasswordError?: Maybe<Scalars['String']>
  matchingPinError?: Maybe<Scalars['String']>
  newPasswordLabel?: Maybe<Scalars['String']>
  newPasswordPlaceholder?: Maybe<Scalars['String']>
  newPinLabel?: Maybe<Scalars['String']>
  newPinPlaceholder?: Maybe<Scalars['String']>
  oldPasswordLabel?: Maybe<Scalars['String']>
  oldPasswordPlaceholder?: Maybe<Scalars['String']>
  oldPinLabel?: Maybe<Scalars['String']>
  oldPinPlaceholder?: Maybe<Scalars['String']>
  passwordCaseError?: Maybe<Scalars['String']>
  passwordDigitError?: Maybe<Scalars['String']>
  passwordLabel?: Maybe<Scalars['String']>
  passwordLengthError?: Maybe<Scalars['String']>
  pinLabel?: Maybe<Scalars['String']>
  pinLengthError?: Maybe<Scalars['String']>
  postalCodeLabel?: Maybe<Scalars['String']>
  postalCodePlaceholder?: Maybe<Scalars['String']>
  saveButtonText?: Maybe<Scalars['String']>
  slug?: Maybe<Scalars['String']>
  stateLabel?: Maybe<Scalars['String']>
  statePlaceholder?: Maybe<Scalars['String']>
  street1Label?: Maybe<Scalars['String']>
  street1Placeholder?: Maybe<Scalars['String']>
  street2Label?: Maybe<Scalars['String']>
  street2Placeholder?: Maybe<Scalars['String']>
  successMessage?: Maybe<Scalars['String']>
  sys: Vs_Sys
  tabSectionsCollection?: Maybe<Vs_RivianIdProfilePageTabSectionsCollection>
  title?: Maybe<Scalars['String']>
  titleLabel?: Maybe<Scalars['String']>
  titlePlaceholder?: Maybe<Scalars['String']>
  updateErrorMessage?: Maybe<Scalars['String']>
  updateSuccessMessage?: Maybe<Scalars['String']>
  usernameLabel?: Maybe<Scalars['String']>
  usernamePlaceholder?: Maybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_RivianIdProfilePageCityLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageCityPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageCompanyLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageCompanyPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageConfirmPasswordLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageConfirmPasswordPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageConfirmPinLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageConfirmPinPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageEmailLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageEmailPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageFirstNameLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageFirstNamePlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageLastNameLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageLastNamePlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_RivianIdProfilePageMatchingPasswordErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageMatchingPinErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageNewPasswordLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageNewPasswordPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageNewPinLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageNewPinPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageOldPasswordLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageOldPasswordPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageOldPinLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageOldPinPlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePagePasswordCaseErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePagePasswordDigitErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePagePasswordLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePagePasswordLengthErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePagePinLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePagePinLengthErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePagePostalCodeLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePagePostalCodePlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageSaveButtonTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageStateLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageStatePlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageStreet1LabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageStreet1PlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageStreet2LabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageStreet2PlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageSuccessMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageTabSectionsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_RivianIdProfilePageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageTitleLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageTitlePlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageUpdateErrorMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageUpdateSuccessMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageUsernameLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageUsernamePlaceholderArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdProfilePageCollection = {
  __typename?: 'vs_RivianIdProfilePageCollection'
  items: Array<Maybe<Vs_RivianIdProfilePage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_RivianIdProfilePageLinkingCollections = {
  __typename?: 'vs_RivianIdProfilePageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_RivianIdProfilePageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_RivianIdProfilePageTabSectionsCollection = {
  __typename?: 'vs_RivianIdProfilePageTabSectionsCollection'
  items: Array<Maybe<Vs_TabSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_RivianIdPwResetPage = Vs_Entry & {
  __typename?: 'vs_RivianIdPwResetPage'
  banner?: Maybe<Vs_Banner>
  contentfulMetadata: Vs_ContentfulMetadata
  emailEmptyError?: Maybe<Scalars['String']>
  emailFieldLabel?: Maybe<Scalars['String']>
  emailPlaceholderText?: Maybe<Scalars['String']>
  emailSentSuccess?: Maybe<Scalars['String']>
  emailSentSuccessTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_RivianIdPwResetPageLinkingCollections>
  newPasswordEmptyError?: Maybe<Scalars['String']>
  newPasswordFieldLabel?: Maybe<Scalars['String']>
  pwResetSubmitButton?: Maybe<Scalars['String']>
  resetCodeEmptyError?: Maybe<Scalars['String']>
  resetCodeFieldLabel?: Maybe<Scalars['String']>
  resetPasswordSubmitError?: Maybe<Scalars['String']>
  resetSubtitle?: Maybe<Scalars['String']>
  resetSuccess?: Maybe<Scalars['String']>
  resetSuccessTitle?: Maybe<Scalars['String']>
  resetTitle?: Maybe<Scalars['String']>
  sendEmailError?: Maybe<Scalars['String']>
  sendResetEmailButtonText?: Maybe<Scalars['String']>
  subTitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_RivianIdPwResetPageEmailEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageEmailFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageEmailPlaceholderTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageEmailSentSuccessArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageEmailSentSuccessTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_RivianIdPwResetPageNewPasswordEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageNewPasswordFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPagePwResetSubmitButtonArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageResetCodeEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageResetCodeFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageResetPasswordSubmitErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageResetSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageResetSuccessArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageResetSuccessTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageResetTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageSendEmailErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageSendResetEmailButtonTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageSubTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdPwResetPageCollection = {
  __typename?: 'vs_RivianIdPwResetPageCollection'
  items: Array<Maybe<Vs_RivianIdPwResetPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_RivianIdPwResetPageLinkingCollections = {
  __typename?: 'vs_RivianIdPwResetPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_RivianIdPwResetPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_RivianIdRegistrationPage = Vs_Entry & {
  __typename?: 'vs_RivianIdRegistrationPage'
  banner?: Maybe<Vs_Banner>
  contentfulMetadata: Vs_ContentfulMetadata
  disclaimer?: Maybe<Vs_RivianIdRegistrationPageDisclaimer>
  emailEmptyError?: Maybe<Scalars['String']>
  emailFieldLabel?: Maybe<Scalars['String']>
  emailPlaceholderText?: Maybe<Scalars['String']>
  firstNameEmptyError?: Maybe<Scalars['String']>
  firstNameFieldLabel?: Maybe<Scalars['String']>
  firstNamePlaceholderText?: Maybe<Scalars['String']>
  invalidCodeErrorMessage?: Maybe<Scalars['String']>
  invalidCodeErrorMessageBody?: Maybe<Scalars['String']>
  lastNameEmptyError?: Maybe<Scalars['String']>
  lastNameFieldLabel?: Maybe<Scalars['String']>
  lastNamePlaceholderText?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_RivianIdRegistrationPageLinkingCollections>
  passwordEmptyError?: Maybe<Scalars['String']>
  passwordFieldLabel?: Maybe<Scalars['String']>
  pinEmptyError?: Maybe<Scalars['String']>
  pinFieldLabel?: Maybe<Scalars['String']>
  registrationButtonText?: Maybe<Scalars['String']>
  registrationFormError?: Maybe<Scalars['String']>
  registrationSuccess?: Maybe<Scalars['String']>
  registrationSuccessTitle?: Maybe<Scalars['String']>
  serviceUnavailableErrorMessage?: Maybe<Scalars['String']>
  subTitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  usernameEmptyError?: Maybe<Scalars['String']>
  usernameFieldLabel?: Maybe<Scalars['String']>
  usernamePlaceholderText?: Maybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_RivianIdRegistrationPageDisclaimerArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageEmailEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageEmailFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageEmailPlaceholderTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageFirstNameEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageFirstNameFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageFirstNamePlaceholderTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageInvalidCodeErrorMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageInvalidCodeErrorMessageBodyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageLastNameEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageLastNameFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageLastNamePlaceholderTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_RivianIdRegistrationPagePasswordEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPagePasswordFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPagePinEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPagePinFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageRegistrationButtonTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageRegistrationFormErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageRegistrationSuccessArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageRegistrationSuccessTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageServiceUnavailableErrorMessageArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageSubTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageUsernameEmptyErrorArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageUsernameFieldLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageUsernamePlaceholderTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_RivianIdRegistrationPageCollection = {
  __typename?: 'vs_RivianIdRegistrationPageCollection'
  items: Array<Maybe<Vs_RivianIdRegistrationPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_RivianIdRegistrationPageDisclaimer = {
  __typename?: 'vs_RivianIdRegistrationPageDisclaimer'
  links: Vs_RivianIdRegistrationPageDisclaimerLinks
}

export type Vs_RivianIdRegistrationPageDisclaimerAssets = {
  __typename?: 'vs_RivianIdRegistrationPageDisclaimerAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_RivianIdRegistrationPageDisclaimerEntries = {
  __typename?: 'vs_RivianIdRegistrationPageDisclaimerEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_RivianIdRegistrationPageDisclaimerLinks = {
  __typename?: 'vs_RivianIdRegistrationPageDisclaimerLinks'
  assets: Vs_RivianIdRegistrationPageDisclaimerAssets
  entries: Vs_RivianIdRegistrationPageDisclaimerEntries
}

export type Vs_RivianIdRegistrationPageLinkingCollections = {
  __typename?: 'vs_RivianIdRegistrationPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_RivianIdRegistrationPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Section = Vs_Entry & {
  __typename?: 'vs_Section'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  entryTitle?: Maybe<Scalars['String']>
  itemsCollection?: Maybe<Vs_SectionItemsCollection>
  linkedFrom?: Maybe<Vs_SectionLinkingCollections>
  sectionHeading?: Maybe<Scalars['String']>
  sectionType?: Maybe<Scalars['String']>
  subHeading?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_SectionDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SectionEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SectionItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_SectionSectionHeadingArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SectionSectionTypeArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SectionSubHeadingArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SectionCollection = {
  __typename?: 'vs_SectionCollection'
  items: Array<Maybe<Vs_Section>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SectionItemsCollection = {
  __typename?: 'vs_SectionItemsCollection'
  items: Array<Maybe<Vs_SectionItemsItem>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SectionItemsItem = Vs_EgVideo | Vs_Items

export type Vs_SectionLinkingCollections = {
  __typename?: 'vs_SectionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  pagesCollection?: Maybe<Vs_PagesCollection>
}

export type Vs_SectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SectionLinkingCollectionsPagesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SharingMetadata = Vs_Entry & {
  __typename?: 'vs_SharingMetadata'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_SharingMetadataLinkingCollections>
  sharingDescription?: Maybe<Scalars['String']>
  sharingImage?: Maybe<Vs_Asset>
  sharingTitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_SharingMetadataLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_SharingMetadataSharingDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SharingMetadataSharingImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_SharingMetadataSharingTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SharingMetadataCollection = {
  __typename?: 'vs_SharingMetadataCollection'
  items: Array<Maybe<Vs_SharingMetadata>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SharingMetadataLinkingCollections = {
  __typename?: 'vs_SharingMetadataLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_SharingMetadataLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SlideContent = Vs_Entry & {
  __typename?: 'vs_SlideContent'
  content?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  entryTitle?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_SlideContentLinkingCollections>
  sys: Vs_Sys
}

export type Vs_SlideContentContentArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_SlideContentEntryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SlideContentLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_SlideContentCollection = {
  __typename?: 'vs_SlideContentCollection'
  items: Array<Maybe<Vs_SlideContent>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SlideContentLinkingCollections = {
  __typename?: 'vs_SlideContentLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_SlideContentLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SlideGallery = Vs_Entry & {
  __typename?: 'vs_SlideGallery'
  contentfulMetadata: Vs_ContentfulMetadata
  itemsCollection?: Maybe<Vs_SlideGalleryItemsCollection>
  linkedFrom?: Maybe<Vs_SlideGalleryLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_SlideGalleryItemsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SlideGalleryLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_SlideGalleryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SlideGalleryCollection = {
  __typename?: 'vs_SlideGalleryCollection'
  items: Array<Maybe<Vs_SlideGallery>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SlideGalleryItemsCollection = {
  __typename?: 'vs_SlideGalleryItemsCollection'
  items: Array<Maybe<Vs_Media>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SlideGalleryLinkingCollections = {
  __typename?: 'vs_SlideGalleryLinkingCollections'
  aboutPageCollection?: Maybe<Vs_AboutPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  pagesCollection?: Maybe<Vs_PagesCollection>
  productPageCollection?: Maybe<Vs_ProductPageCollection>
}

export type Vs_SlideGalleryLinkingCollectionsAboutPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SlideGalleryLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SlideGalleryLinkingCollectionsPagesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SlideGalleryLinkingCollectionsProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Social = Vs_Entry & {
  __typename?: 'vs_Social'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_SocialLinkingCollections>
  linksCollection?: Maybe<Vs_SocialLinksCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_SocialLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_SocialLinksCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SocialTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SocialCollection = {
  __typename?: 'vs_SocialCollection'
  items: Array<Maybe<Vs_Social>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SocialLinkingCollections = {
  __typename?: 'vs_SocialLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  footerCollection?: Maybe<Vs_FooterCollection>
}

export type Vs_SocialLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SocialLinkingCollectionsFooterCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SocialLinksCollection = {
  __typename?: 'vs_SocialLinksCollection'
  items: Array<Maybe<Vs_EgLink>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SpecView = Vs_Entry & {
  __typename?: 'vs_SpecView'
  contentfulMetadata: Vs_ContentfulMetadata
  icon?: Maybe<Vs_Asset>
  label?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_SpecViewLinkingCollections>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_SpecViewIconArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_SpecViewLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SpecViewLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_SpecViewValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SpecViewCollection = {
  __typename?: 'vs_SpecViewCollection'
  items: Array<Maybe<Vs_SpecView>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SpecViewLinkingCollections = {
  __typename?: 'vs_SpecViewLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  specificationsCollection?: Maybe<Vs_SpecificationsCollection>
}

export type Vs_SpecViewLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SpecViewLinkingCollectionsSpecificationsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Specifications = Vs_Entry & {
  __typename?: 'vs_Specifications'
  background?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  imageSequencesCollection?: Maybe<Vs_AssetCollection>
  linkedFrom?: Maybe<Vs_SpecificationsLinkingCollections>
  specificationsCollection?: Maybe<Vs_SpecificationsSpecificationsCollection>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  viewsCollection?: Maybe<Vs_SpecificationsViewsCollection>
}

export type Vs_SpecificationsBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_SpecificationsImageSequencesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SpecificationsLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_SpecificationsSpecificationsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SpecificationsTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_SpecificationsViewsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SpecificationsCollection = {
  __typename?: 'vs_SpecificationsCollection'
  items: Array<Maybe<Vs_Specifications>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SpecificationsLinkingCollections = {
  __typename?: 'vs_SpecificationsLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  productPageCollection?: Maybe<Vs_ProductPageCollection>
}

export type Vs_SpecificationsLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SpecificationsLinkingCollectionsProductPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_SpecificationsSpecificationsCollection = {
  __typename?: 'vs_SpecificationsSpecificationsCollection'
  items: Array<Maybe<Vs_SpecView>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_SpecificationsViewsCollection = {
  __typename?: 'vs_SpecificationsViewsCollection'
  items: Array<Maybe<Vs_SpecView>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_Story = Vs_Entry & {
  __typename?: 'vs_Story'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_StoryLinkingCollections>
  media?: Maybe<Vs_Media>
  storyLink?: Maybe<Vs_EgLink>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_StoryLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_StoryMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_StoryStoryLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_StorySubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_StoryTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_StoryCollection = {
  __typename?: 'vs_StoryCollection'
  items: Array<Maybe<Vs_Story>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_StoryLinkingCollections = {
  __typename?: 'vs_StoryLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_StoryLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_StorySection = Vs_Entry & {
  __typename?: 'vs_StorySection'
  additionalMedia?: Maybe<Vs_Media>
  background?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_StorySectionLinkingCollections>
  media?: Maybe<Vs_Media>
  storyLink?: Maybe<Vs_EgLink>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_StorySectionAdditionalMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_StorySectionBackgroundArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_StorySectionDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_StorySectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_StorySectionMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_StorySectionStoryLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_StorySectionSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_StorySectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_StorySectionCollection = {
  __typename?: 'vs_StorySectionCollection'
  items: Array<Maybe<Vs_StorySection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_StorySectionLinkingCollections = {
  __typename?: 'vs_StorySectionLinkingCollections'
  aboutPageCollection?: Maybe<Vs_AboutPageCollection>
  careersPageCollection?: Maybe<Vs_CareersPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  homePageCollection?: Maybe<Vs_HomePageCollection>
}

export type Vs_StorySectionLinkingCollectionsAboutPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_StorySectionLinkingCollectionsCareersPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_StorySectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_StorySectionLinkingCollectionsHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Sys = {
  __typename?: 'vs_Sys'
  environmentId: Scalars['String']
  id: Scalars['String']
  publishedVersion?: Maybe<Scalars['Int']>
  spaceId: Scalars['String']
}

export type Vs_SysFilter = {
  firstPublishedAt_exists?: InputMaybe<Scalars['Boolean']>
  id?: InputMaybe<Scalars['String']>
  id_contains?: InputMaybe<Scalars['String']>
  id_exists?: InputMaybe<Scalars['Boolean']>
  id_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  id_not?: InputMaybe<Scalars['String']>
  id_not_contains?: InputMaybe<Scalars['String']>
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  publishedAt_exists?: InputMaybe<Scalars['Boolean']>
  publishedVersion?: InputMaybe<Scalars['Float']>
  publishedVersion_exists?: InputMaybe<Scalars['Boolean']>
  publishedVersion_gt?: InputMaybe<Scalars['Float']>
  publishedVersion_gte?: InputMaybe<Scalars['Float']>
  publishedVersion_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>
  publishedVersion_lt?: InputMaybe<Scalars['Float']>
  publishedVersion_lte?: InputMaybe<Scalars['Float']>
  publishedVersion_not?: InputMaybe<Scalars['Float']>
  publishedVersion_not_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>
}

export type Vs_T2DUiElement = Vs_Entry & {
  __typename?: 'vs_T2DUiElement'
  asset?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_T2DUiElementLinkingCollections>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_T2DUiElementAssetArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_T2DUiElementKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_T2DUiElementLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_T2DUiElementValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_T2DUiElementCollection = {
  __typename?: 'vs_T2DUiElementCollection'
  items: Array<Maybe<Vs_T2DUiElement>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_T2DUiElementLinkingCollections = {
  __typename?: 'vs_T2DUiElementLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  t2DUiElementsGroupCollection?: Maybe<Vs_T2DUiElementsGroupCollection>
}

export type Vs_T2DUiElementLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_T2DUiElementLinkingCollectionsT2DUiElementsGroupCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_T2DUiElementsGroup = Vs_Entry & {
  __typename?: 'vs_T2DUiElementsGroup'
  contentfulMetadata: Vs_ContentfulMetadata
  elementsCollection?: Maybe<Vs_T2DUiElementsGroupElementsCollection>
  linkedFrom?: Maybe<Vs_T2DUiElementsGroupLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_T2DUiElementsGroupElementsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_T2DUiElementsGroupLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_T2DUiElementsGroupTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_T2DUiElementsGroupCollection = {
  __typename?: 'vs_T2DUiElementsGroupCollection'
  items: Array<Maybe<Vs_T2DUiElementsGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_T2DUiElementsGroupElementsCollection = {
  __typename?: 'vs_T2DUiElementsGroupElementsCollection'
  items: Array<Maybe<Vs_T2DUiElement>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_T2DUiElementsGroupLinkingCollections = {
  __typename?: 'vs_T2DUiElementsGroupLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  t2DUiStringsCollection?: Maybe<Vs_T2DUiStringsCollection>
}

export type Vs_T2DUiElementsGroupLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_T2DUiElementsGroupLinkingCollectionsT2DUiStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_T2DUiStrings = Vs_Entry & {
  __typename?: 'vs_T2DUiStrings'
  contentfulMetadata: Vs_ContentfulMetadata
  elementGroupsCollection?: Maybe<Vs_T2DUiStringsElementGroupsCollection>
  linkedFrom?: Maybe<Vs_T2DUiStringsLinkingCollections>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_T2DUiStringsElementGroupsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_T2DUiStringsLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_T2DUiStringsTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_T2DUiStringsCollection = {
  __typename?: 'vs_T2DUiStringsCollection'
  items: Array<Maybe<Vs_T2DUiStrings>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_T2DUiStringsElementGroupsCollection = {
  __typename?: 'vs_T2DUiStringsElementGroupsCollection'
  items: Array<Maybe<Vs_T2DUiElementsGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_T2DUiStringsLinkingCollections = {
  __typename?: 'vs_T2DUiStringsLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_T2DUiStringsLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TabSection = Vs_Entry & {
  __typename?: 'vs_TabSection'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_TabSectionLinkingCollections>
  sys: Vs_Sys
  tabBodyText?: Maybe<Vs_TabSectionTabBodyText>
  tabId?: Maybe<Scalars['String']>
  tabTitle?: Maybe<Scalars['String']>
}

export type Vs_TabSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_TabSectionTabBodyTextArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TabSectionTabIdArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TabSectionTabTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TabSectionLinkingCollections = {
  __typename?: 'vs_TabSectionLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  faqPageCollection?: Maybe<Vs_FaqPageCollection>
  rivianIdProfilePageCollection?: Maybe<Vs_RivianIdProfilePageCollection>
}

export type Vs_TabSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TabSectionLinkingCollectionsFaqPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TabSectionLinkingCollectionsRivianIdProfilePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TabSectionTabBodyText = {
  __typename?: 'vs_TabSectionTabBodyText'
  links: Vs_TabSectionTabBodyTextLinks
}

export type Vs_TabSectionTabBodyTextAssets = {
  __typename?: 'vs_TabSectionTabBodyTextAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_TabSectionTabBodyTextEntries = {
  __typename?: 'vs_TabSectionTabBodyTextEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_TabSectionTabBodyTextLinks = {
  __typename?: 'vs_TabSectionTabBodyTextLinks'
  assets: Vs_TabSectionTabBodyTextAssets
  entries: Vs_TabSectionTabBodyTextEntries
}

export type Vs_TechnologyFeature = Vs_Entry & {
  __typename?: 'vs_TechnologyFeature'
  contentfulMetadata: Vs_ContentfulMetadata
  firstShot?: Maybe<Vs_Asset>
  lastShot?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_TechnologyFeatureLinkingCollections>
  mobileImage?: Maybe<Vs_Asset>
  sequenceCollection?: Maybe<Vs_AssetCollection>
  slug?: Maybe<Scalars['String']>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_TechnologyFeatureFirstShotArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_TechnologyFeatureLastShotArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_TechnologyFeatureLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_TechnologyFeatureMobileImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_TechnologyFeatureSequenceCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TechnologyFeatureSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TechnologyFeatureSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TechnologyFeatureTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TechnologyFeatureCollection = {
  __typename?: 'vs_TechnologyFeatureCollection'
  items: Array<Maybe<Vs_TechnologyFeature>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_TechnologyFeatureLinkingCollections = {
  __typename?: 'vs_TechnologyFeatureLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  technologyPageCollection?: Maybe<Vs_TechnologyPageCollection>
}

export type Vs_TechnologyFeatureLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TechnologyFeatureLinkingCollectionsTechnologyPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TechnologyPage = Vs_Entry & {
  __typename?: 'vs_TechnologyPage'
  contentfulMetadata: Vs_ContentfulMetadata
  hero?: Maybe<Vs_Heroes>
  linkedFrom?: Maybe<Vs_TechnologyPageLinkingCollections>
  photoHighlight?: Maybe<Vs_HighlightSection>
  sharingMetadata?: Maybe<Vs_EgSharingMetadata>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  techFeaturesCollection?: Maybe<Vs_TechnologyPageTechFeaturesCollection>
  techFeaturesText?: Maybe<Vs_TextBlock>
  technologyTabsCollection?: Maybe<Vs_TechnologyPageTechnologyTabsCollection>
  title?: Maybe<Scalars['String']>
  videoHighlight?: Maybe<Vs_HighlightSection>
}

export type Vs_TechnologyPageHeroArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_TechnologyPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_TechnologyPagePhotoHighlightArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_TechnologyPageSharingMetadataArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_TechnologyPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TechnologyPageTechFeaturesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TechnologyPageTechFeaturesTextArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_TechnologyPageTechnologyTabsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TechnologyPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TechnologyPageVideoHighlightArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_TechnologyPageCollection = {
  __typename?: 'vs_TechnologyPageCollection'
  items: Array<Maybe<Vs_TechnologyPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_TechnologyPageLinkingCollections = {
  __typename?: 'vs_TechnologyPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_TechnologyPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TechnologyPageTechFeaturesCollection = {
  __typename?: 'vs_TechnologyPageTechFeaturesCollection'
  items: Array<Maybe<Vs_TechnologyFeature>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_TechnologyPageTechnologyTabsCollection = {
  __typename?: 'vs_TechnologyPageTechnologyTabsCollection'
  items: Array<Maybe<Vs_TechnologyTab>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_TechnologyTab = Vs_Entry & {
  __typename?: 'vs_TechnologyTab'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_TechnologyTabLinkingCollections>
  sys: Vs_Sys
  tabContent?: Maybe<Vs_Asset>
  tabId?: Maybe<Scalars['String']>
  tabTitle?: Maybe<Scalars['String']>
}

export type Vs_TechnologyTabLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_TechnologyTabTabContentArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_TechnologyTabTabIdArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TechnologyTabTabTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TechnologyTabCollection = {
  __typename?: 'vs_TechnologyTabCollection'
  items: Array<Maybe<Vs_TechnologyTab>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_TechnologyTabLinkingCollections = {
  __typename?: 'vs_TechnologyTabLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  technologyPageCollection?: Maybe<Vs_TechnologyPageCollection>
}

export type Vs_TechnologyTabLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TechnologyTabLinkingCollectionsTechnologyPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TextBlock = Vs_Entry & {
  __typename?: 'vs_TextBlock'
  contentfulMetadata: Vs_ContentfulMetadata
  description?: Maybe<Vs_TextBlockDescription>
  linkedFrom?: Maybe<Vs_TextBlockLinkingCollections>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_TextBlockDescriptionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TextBlockLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_TextBlockSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TextBlockTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_TextBlockDescription = {
  __typename?: 'vs_TextBlockDescription'
  links: Vs_TextBlockDescriptionLinks
}

export type Vs_TextBlockDescriptionAssets = {
  __typename?: 'vs_TextBlockDescriptionAssets'
  block: Array<Maybe<Vs_Asset>>
  hyperlink: Array<Maybe<Vs_Asset>>
}

export type Vs_TextBlockDescriptionEntries = {
  __typename?: 'vs_TextBlockDescriptionEntries'
  block: Array<Maybe<Vs_Entry>>
  hyperlink: Array<Maybe<Vs_Entry>>
  inline: Array<Maybe<Vs_Entry>>
}

export type Vs_TextBlockDescriptionLinks = {
  __typename?: 'vs_TextBlockDescriptionLinks'
  assets: Vs_TextBlockDescriptionAssets
  entries: Vs_TextBlockDescriptionEntries
}

export type Vs_TextBlockLinkingCollections = {
  __typename?: 'vs_TextBlockLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  technologyPageCollection?: Maybe<Vs_TechnologyPageCollection>
  thankYouPageCollection?: Maybe<Vs_ThankYouPageCollection>
}

export type Vs_TextBlockLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TextBlockLinkingCollectionsTechnologyPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_TextBlockLinkingCollectionsThankYouPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ThankYouPage = Vs_Entry & {
  __typename?: 'vs_ThankYouPage'
  alternativeEmailLabel?: Maybe<Scalars['String']>
  banner?: Maybe<Vs_Banner>
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_ThankYouPageLinkingCollections>
  r1SMedia?: Maybe<Vs_Media>
  r1TMedia?: Maybe<Vs_Media>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  thankYouLabel?: Maybe<Scalars['String']>
  thankYouNotesCollection?: Maybe<Vs_ThankYouPageThankYouNotesCollection>
  title?: Maybe<Scalars['String']>
  video?: Maybe<Vs_EgVideo>
}

export type Vs_ThankYouPageAlternativeEmailLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ThankYouPageBannerArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ThankYouPageLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_ThankYouPageR1SMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ThankYouPageR1TMediaArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ThankYouPageSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ThankYouPageThankYouLabelArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ThankYouPageThankYouNotesCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ThankYouPageTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_ThankYouPageVideoArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_ThankYouPageCollection = {
  __typename?: 'vs_ThankYouPageCollection'
  items: Array<Maybe<Vs_ThankYouPage>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_ThankYouPageLinkingCollections = {
  __typename?: 'vs_ThankYouPageLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_ThankYouPageLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_ThankYouPageThankYouNotesCollection = {
  __typename?: 'vs_ThankYouPageThankYouNotesCollection'
  items: Array<Maybe<Vs_TextBlock>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_VersionTracking = Vs_Entry & {
  __typename?: 'vs_VersionTracking'
  contentfulMetadata: Vs_ContentfulMetadata
  linkedFrom?: Maybe<Vs_VersionTrackingLinkingCollections>
  sys: Vs_Sys
  version?: Maybe<Scalars['String']>
}

export type Vs_VersionTrackingLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_VersionTrackingVersionArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VersionTrackingLinkingCollections = {
  __typename?: 'vs_VersionTrackingLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_VersionTrackingLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_Video = Vs_Entry & {
  __typename?: 'vs_Video'
  autoplay?: Maybe<Scalars['Boolean']>
  contentfulMetadata: Vs_ContentfulMetadata
  coverImage?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_VideoLinkingCollections>
  loop?: Maybe<Scalars['Boolean']>
  mediaFile?: Maybe<Vs_Asset>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
  videoCaptions?: Maybe<Vs_Asset>
  videoLink?: Maybe<Scalars['String']>
}

export type Vs_VideoAutoplayArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VideoCoverImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_VideoLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_VideoLoopArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VideoMediaFileArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_VideoSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VideoTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VideoVideoCaptionsArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_VideoVideoLinkArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VideoCollection = {
  __typename?: 'vs_VideoCollection'
  items: Array<Maybe<Vs_Video>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_VideoLinkingCollections = {
  __typename?: 'vs_VideoLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_VideoLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_VideoSection = Vs_Entry & {
  __typename?: 'vs_VideoSection'
  contentfulMetadata: Vs_ContentfulMetadata
  coverImage?: Maybe<Vs_Asset>
  linkedFrom?: Maybe<Vs_VideoSectionLinkingCollections>
  mediaFile?: Maybe<Vs_Asset>
  subtitle?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_VideoSectionCoverImageArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_VideoSectionLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_VideoSectionMediaFileArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_VideoSectionSubtitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VideoSectionTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VideoSectionCollection = {
  __typename?: 'vs_VideoSectionCollection'
  items: Array<Maybe<Vs_VideoSection>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_VideoSectionLinkingCollections = {
  __typename?: 'vs_VideoSectionLinkingCollections'
  egRpvPageCollection?: Maybe<Vs_EgRpvPageCollection>
  entryCollection?: Maybe<Vs_EntryCollection>
  homePageCollection?: Maybe<Vs_HomePageCollection>
}

export type Vs_VideoSectionLinkingCollectionsEgRpvPageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_VideoSectionLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_VideoSectionLinkingCollectionsHomePageCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_VsUiElement = Vs_Entry & {
  __typename?: 'vs_VsUiElement'
  asset?: Maybe<Vs_Asset>
  contentfulMetadata: Vs_ContentfulMetadata
  key?: Maybe<Scalars['String']>
  linkedFrom?: Maybe<Vs_VsUiElementLinkingCollections>
  longTextValue?: Maybe<Scalars['String']>
  sys: Vs_Sys
  value?: Maybe<Scalars['String']>
}

export type Vs_VsUiElementAssetArgs = {
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
}

export type Vs_VsUiElementKeyArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VsUiElementLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_VsUiElementLongTextValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VsUiElementValueArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VsUiElementCollection = {
  __typename?: 'vs_VsUiElementCollection'
  items: Array<Maybe<Vs_VsUiElement>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_VsUiElementFilter = {
  AND?: InputMaybe<Array<InputMaybe<Vs_VsUiElementFilter>>>
  OR?: InputMaybe<Array<InputMaybe<Vs_VsUiElementFilter>>>
  asset_exists?: InputMaybe<Scalars['Boolean']>
  contentfulMetadata?: InputMaybe<Vs_ContentfulMetadataFilter>
  key?: InputMaybe<Scalars['String']>
  key_contains?: InputMaybe<Scalars['String']>
  key_exists?: InputMaybe<Scalars['Boolean']>
  key_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  key_not?: InputMaybe<Scalars['String']>
  key_not_contains?: InputMaybe<Scalars['String']>
  key_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  longTextValue?: InputMaybe<Scalars['String']>
  longTextValue_contains?: InputMaybe<Scalars['String']>
  longTextValue_exists?: InputMaybe<Scalars['Boolean']>
  longTextValue_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  longTextValue_not?: InputMaybe<Scalars['String']>
  longTextValue_not_contains?: InputMaybe<Scalars['String']>
  longTextValue_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  sys?: InputMaybe<Vs_SysFilter>
  value?: InputMaybe<Scalars['String']>
  value_contains?: InputMaybe<Scalars['String']>
  value_exists?: InputMaybe<Scalars['Boolean']>
  value_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  value_not?: InputMaybe<Scalars['String']>
  value_not_contains?: InputMaybe<Scalars['String']>
  value_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_VsUiElementLinkingCollections = {
  __typename?: 'vs_VsUiElementLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  vsUiElementsGroupCollection?: Maybe<Vs_VsUiElementsGroupCollection>
}

export type Vs_VsUiElementLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_VsUiElementLinkingCollectionsVsUiElementsGroupCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export enum Vs_VsUiElementOrder {
  KeyAsc = 'key_ASC',
  KeyDesc = 'key_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  ValueAsc = 'value_ASC',
  ValueDesc = 'value_DESC'
}

export type Vs_VsUiElementsGroup = Vs_Entry & {
  __typename?: 'vs_VsUiElementsGroup'
  contentfulMetadata: Vs_ContentfulMetadata
  elementsCollection?: Maybe<Vs_VsUiElementsGroupElementsCollection>
  linkedFrom?: Maybe<Vs_VsUiElementsGroupLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
  title?: Maybe<Scalars['String']>
}

export type Vs_VsUiElementsGroupElementsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_VsUiElementsGroupLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_VsUiElementsGroupSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VsUiElementsGroupTitleArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VsUiElementsGroupCollection = {
  __typename?: 'vs_VsUiElementsGroupCollection'
  items: Array<Maybe<Vs_VsUiElementsGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_VsUiElementsGroupElementsCollection = {
  __typename?: 'vs_VsUiElementsGroupElementsCollection'
  items: Array<Maybe<Vs_VsUiElement>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_VsUiElementsGroupFilter = {
  AND?: InputMaybe<Array<InputMaybe<Vs_VsUiElementsGroupFilter>>>
  OR?: InputMaybe<Array<InputMaybe<Vs_VsUiElementsGroupFilter>>>
  contentfulMetadata?: InputMaybe<Vs_ContentfulMetadataFilter>
  elementsCollection_exists?: InputMaybe<Scalars['Boolean']>
  slug?: InputMaybe<Scalars['String']>
  slug_contains?: InputMaybe<Scalars['String']>
  slug_exists?: InputMaybe<Scalars['Boolean']>
  slug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  slug_not?: InputMaybe<Scalars['String']>
  slug_not_contains?: InputMaybe<Scalars['String']>
  slug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  sys?: InputMaybe<Vs_SysFilter>
  title?: InputMaybe<Scalars['String']>
  title_contains?: InputMaybe<Scalars['String']>
  title_exists?: InputMaybe<Scalars['Boolean']>
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  title_not?: InputMaybe<Scalars['String']>
  title_not_contains?: InputMaybe<Scalars['String']>
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_VsUiElementsGroupLinkingCollections = {
  __typename?: 'vs_VsUiElementsGroupLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
  vsUiStringsCollection?: Maybe<Vs_VsUiStringsCollection>
}

export type Vs_VsUiElementsGroupLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_VsUiElementsGroupLinkingCollectionsVsUiStringsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export enum Vs_VsUiElementsGroupOrder {
  SlugAsc = 'slug_ASC',
  SlugDesc = 'slug_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type Vs_VsUiStrings = Vs_Entry & {
  __typename?: 'vs_VsUiStrings'
  contentfulMetadata: Vs_ContentfulMetadata
  elementGroupsCollection?: Maybe<Vs_VsUiStringsElementGroupsCollection>
  linkedFrom?: Maybe<Vs_VsUiStringsLinkingCollections>
  slug?: Maybe<Scalars['String']>
  sys: Vs_Sys
}

export type Vs_VsUiStringsElementGroupsCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export type Vs_VsUiStringsLinkedFromArgs = {
  allowedLocales?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
}

export type Vs_VsUiStringsSlugArgs = {
  locale?: InputMaybe<Scalars['String']>
}

export type Vs_VsUiStringsCollection = {
  __typename?: 'vs_VsUiStringsCollection'
  items: Array<Maybe<Vs_VsUiStrings>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_VsUiStringsElementGroupsCollection = {
  __typename?: 'vs_VsUiStringsElementGroupsCollection'
  items: Array<Maybe<Vs_VsUiElementsGroup>>
  limit: Scalars['Int']
  skip: Scalars['Int']
  total: Scalars['Int']
}

export type Vs_VsUiStringsFilter = {
  AND?: InputMaybe<Array<InputMaybe<Vs_VsUiStringsFilter>>>
  OR?: InputMaybe<Array<InputMaybe<Vs_VsUiStringsFilter>>>
  contentfulMetadata?: InputMaybe<Vs_ContentfulMetadataFilter>
  elementGroupsCollection_exists?: InputMaybe<Scalars['Boolean']>
  slug?: InputMaybe<Scalars['String']>
  slug_contains?: InputMaybe<Scalars['String']>
  slug_exists?: InputMaybe<Scalars['Boolean']>
  slug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  slug_not?: InputMaybe<Scalars['String']>
  slug_not_contains?: InputMaybe<Scalars['String']>
  slug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>
  sys?: InputMaybe<Vs_SysFilter>
}

export type Vs_VsUiStringsLinkingCollections = {
  __typename?: 'vs_VsUiStringsLinkingCollections'
  entryCollection?: Maybe<Vs_EntryCollection>
}

export type Vs_VsUiStringsLinkingCollectionsEntryCollectionArgs = {
  limit?: InputMaybe<Scalars['Int']>
  locale?: InputMaybe<Scalars['String']>
  preview?: InputMaybe<Scalars['Boolean']>
  skip?: InputMaybe<Scalars['Int']>
}

export enum Vs_VsUiStringsOrder {
  SlugAsc = 'slug_ASC',
  SlugDesc = 'slug_DESC',
  SysFirstPublishedAtAsc = 'sys_firstPublishedAt_ASC',
  SysFirstPublishedAtDesc = 'sys_firstPublishedAt_DESC',
  SysIdAsc = 'sys_id_ASC',
  SysIdDesc = 'sys_id_DESC',
  SysPublishedAtAsc = 'sys_publishedAt_ASC',
  SysPublishedAtDesc = 'sys_publishedAt_DESC',
  SysPublishedVersionAsc = 'sys_publishedVersion_ASC',
  SysPublishedVersionDesc = 'sys_publishedVersion_DESC'
}
